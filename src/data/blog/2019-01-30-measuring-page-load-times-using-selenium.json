{
  "id": "2019-01-30-measuring-page-load-times-using-selenium",
  "title": "Measuring page load times using Selenium",
  "date": "2019-01-30",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium performance testing"
  ],
  "permalink": "/2019/01/measuring-page-load-times-using-selenium",
  "content": "<p><img src=\"/images/blog/kisscc0-computer-icons-performance-indicator-drawing-bench-performance-by-cyberang3l-5b74ed3ee8fa74.5190956615343895669543.png\" alt=\"\" style=\"width: 100%;\"></p>\n<h2>Introduction</h2>\n<p>It seems like you really liked my latest post<br>about <a href=\"https://www.awesome-testing.com/2019/01/adding-console-error-log-verification.html\" target=\"_blank\" rel=\"noreferrer\">console errors verification</a>.<br>Today I&#39;d like to share another useful extension for your Selenium scripts - page load time measurements. Performance<br>category is slightly underrepresented so far (only one post<br>about <a href=\"https://www.awesome-testing.com/2018/03/five-minutes-performance-report-with.html\" target=\"_blank\" rel=\"noreferrer\">Google Lighthouse</a>) so it&#39;s a<br>perfect opportunity to change it.</p>\n<p>By the way since my last post about Lighthouse using this tool has become even easier. You can run it online on<br>a<a href=\"https://web.dev/measure\" target=\"_blank\" rel=\"noreferrer\">dedicated page</a>. It also helps to optimize your page in SEO domain, for example by<br>suggesting <a href=\"https://github.com/FluentLenium/FluentLenium/pull/687\" target=\"_blank\" rel=\"noreferrer\">meta description</a>.</p>\n<h2>Performance Timing interface</h2>\n<p>Two weeks ago I mentioned that w3c standardization regarding Selenium logging interface progresses rather slowly. This<br>time the story is totally different. We have nicely<br>documented<a href=\"https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface\" target=\"_blank\" rel=\"noreferrer\">PerformanceTiming interface</a>which<br>seems to be the implemented in every browser (I tested Chrome, Firefox, and Edge).</p>\n<p>There&#39;s even an image which visualizes each metric:</p>\n<p><img src=\"/images/blog/timing-overview.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>As you probably know deciding what to measure is crucial for effective performance testing so I suggest you to read it<br>the standard carefully. For my demo I&#39;ll use only two metrics:</p>\n<p><strong>navigationStart</strong> - This attribute must return the time immediately after the user agent<br>finishes <a href=\"http://www.w3.org/TR/html5/browsers.html#prompt-to-unload-a-document\" target=\"_blank\" rel=\"noreferrer\">prompting to unload</a> the previous<br>document. If there is no previous document, this attribute must return the same value<br>as <a href=\"https://www.w3.org/TR/navigation-timing/#dom-performancetiming-fetchstart\" target=\"_blank\" rel=\"noreferrer\">fetchStart</a>.</p>\n<p><strong>loadEventEnd</strong> - This attribute must return the time when the load event of the current document is completed. It must<br>return zero when the load event is not fired or is not completed.</p>\n<p>You can access each of those metrics via browser console. Just start typing <em>window.performance.timing.</em></p>\n<p><img src=\"/images/blog/perfapi.png\" alt=\"\" style=\"width: 100%;\"></p>\n<h2>Demo</h2>\n<p>As usual, I&#39;m going to <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a>in my demo. It&#39;s Selenium extension<br>with few <a href=\"https://fluentlenium.com/\" target=\"_blank\" rel=\"noreferrer\">additional features</a>.</p>\n<p>Let&#39;s use different browser this time - Microsoft Edge. Here is a simple driver setup.</p>\n<pre><code class=\"language-java\">private static final String MY_EDGEDRIVER_PATH = &quot;C:\\\\drivers\\\\MicrosoftWebDriver.exe&quot;;\n\n    @Override\n    public WebDriver newWebDriver() {\n        System.setProperty(&quot;webdriver.edge.driver&quot;, MY_EDGEDRIVER_PATH);\n        return new EdgeDriver();\n    }\n</code></pre>\n<p>We may decide to measure different events at some points so let&#39;s make their setup easy and extendable in a separate<br>PerformanceEvent enum.</p>\n<pre><code class=\"language-java\">public enum PerformanceEvent {\n\n    LOAD_EVENT_END (&quot;loadEventEnd&quot;),\n    NAVIGATION_START (&quot;navigationStart&quot;);\n\n    private final String event;\n\n    PerformanceEvent(String event) {\n        this.event = event;\n    }\n\n    @Override\n    public String toString() {\n        return this.event;\n    }\n}\n</code></pre>\n<p>So how do we access performance timing metrics in Selenium script? We only need to execute simple javascript and return<br>its value (as long). Method gets PerformanceEvent enum value as a parameter.</p>\n<pre><code class=\"language-java\">private long getEventValue(PerformanceEvent event) {\n        String script = String.format(&quot;return window.performance.timing.%s;&quot;, event);\n        return executeScript(script).getLongResult();\n    }\n</code></pre>\n<p>Now let&#39;s move to the most interesting part for every tester - actual Junit implementation. We want to display loading<br>time in seconds on screen and assert that it isn&#39;t greater than 3 seconds.</p>\n<pre><code class=\"language-java\">@Test\n    public void loadTimeTest() {\n        goTo(awesomeTestingPage);\n        long loadEventEnd = getEventValue(LOAD_EVENT_END);\n        long navigationStart = getEventValue(NAVIGATION_START);\n\n        assertThat(getLoadTimeInSeconds(loadEventEnd, navigationStart))\n            .isLessThanOrEqualTo(3);\n    }\n\n    private long getLoadTimeInSeconds(long loadEventEnd, long navigationStart) {\n        long loadTimeInSeconds = (loadEventEnd - navigationStart) / 1000;\n        String logBody = String.format(&quot;Page Load Time is %s seconds.&quot;, loadTimeInSeconds);\n        System.out.println(logBody);\n        return loadTimeInSeconds;\n    }\n</code></pre>\n<p>Pretty simple, isn&#39;t it? By the way, I checked it on Chrome and loading there is usually ~1 second faster than on<br>Microsoft Edge.</p>\n<p>Complete code with all imports, dependencies etc. is available on<br>my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting/tree/2a1526ea8b07dbd18a7960ffa8845beff5083616/src/test/java/com/awesome/testing/performance/timing\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a>.<br>Enjoy :)</p>\n"
}