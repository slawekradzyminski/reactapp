{
  "id": "2019-01-30-measuring-page-load-times-using-selenium",
  "title": "Measuring page load times using Selenium",
  "date": "2019-01-30",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium performance testing"
  ],
  "permalink": "/2019/01/measuring-page-load-times-using-selenium",
  "content": "<img src=\"/images/blog/kisscc0-computer-icons-performance-indicator-drawing-bench-performance-by-cyberang3l-5b74ed3ee8fa74.5190956615343895669543.png\" alt=\"\">\n\n<h2>Introduction</h2>\n<p>It seems like you really liked my latest post about <a href=\"https://www.awesome-testing.com/2019/01/adding-console-error-log-verification.html\" target=\"_blank\" rel=\"noreferrer\">console errors verification</a>.<br>Today I&#39;d like to share another useful extension for your Selenium scripts - page load time measurements. Performance category is slightly underrepresented so far (only one post about <a href=\"https://www.awesome-testing.com/2018/03/five-minutes-performance-report-with.html\" target=\"_blank\" rel=\"noreferrer\">Google Lighthouse</a>) so it&#39;s a perfect opportunity to change it.</p><p>By the way since my last post about Lighthouse using this tool has become even easier. You can run it online on a<a href=\"https://web.dev/measure\" target=\"_blank\" rel=\"noreferrer\">dedicated page</a>. It also helps to optimize your page in SEO domain, for example by suggesting <a href=\"https://github.com/FluentLenium/FluentLenium/pull/687\" target=\"_blank\" rel=\"noreferrer\">meta description</a>.</p><h2>Performance Timing interface</h2>\n<p>Two weeks ago I mentioned that w3c standardization regarding Selenium logging interface progresses rather slowly. This time the story is totally different. We have nicely documented<a href=\"https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface\" target=\"_blank\" rel=\"noreferrer\">PerformanceTiming interface</a>which seems to be the implemented in every browser (I tested Chrome, Firefox, and Edge).</p><p>There&#39;s even an image which visualizes each metric:</p><img src=\"/images/blog/timing-overview.png\" alt=\"\">\n\n<p>As you probably know deciding what to measure is crucial for effective performance testing so I suggest you to read it the standard carefully. For my demo I&#39;ll use only two metrics:</p><p><strong>navigationStart</strong> - This attribute must return the time immediately after the user agent finishes <a href=\"http://www.w3.org/TR/html5/browsers.html#prompt-to-unload-a-document\" target=\"_blank\" rel=\"noreferrer\">prompting to unload</a> the previous document. If there is no previous document, this attribute must return the same value as <a href=\"https://www.w3.org/TR/navigation-timing/#dom-performancetiming-fetchstart\" target=\"_blank\" rel=\"noreferrer\">fetchStart</a>.</p><p><strong>loadEventEnd</strong> - This attribute must return the time when the load event of the current document is completed. It must return zero when the load event is not fired or is not completed.</p><p>You can access each of those metrics via browser console. Just start typing <em>window.performance.timing.</em></p><img src=\"/images/blog/perfapi.png\" alt=\"\">\n\n<h2>Demo</h2>\n<p>As usual, I&#39;m going to <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a>in my demo. It&#39;s Selenium extension with few <a href=\"https://fluentlenium.com/\" target=\"_blank\" rel=\"noreferrer\">additional features</a>.</p><p>Let&#39;s use different browser this time - Microsoft Edge. Here is a simple driver setup.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">MY_EDGEDRIVER_PATH</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;C:\\\\drivers\\\\MicrosoftWebDriver.exe&quot;</span>;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> WebDriver <span class=\"hljs-title function_\">newWebDriver</span><span class=\"hljs-params\">()</span> {\n        System.setProperty(<span class=\"hljs-string\">&quot;webdriver.edge.driver&quot;</span>, MY_EDGEDRIVER_PATH);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EdgeDriver</span>();\n    }\n</code></pre><p>We may decide to measure different events at some points so let&#39;s make their setup easy and extendable in a separate PerformanceEvent enum.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PerformanceEvent</span> {\n\n    LOAD_EVENT_END (<span class=\"hljs-string\">&quot;loadEventEnd&quot;</span>),\n    NAVIGATION_START (<span class=\"hljs-string\">&quot;navigationStart&quot;</span>);\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String event;\n\n    PerformanceEvent(String event) {\n        <span class=\"hljs-built_in\">this</span>.event = event;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.event;\n    }\n}\n</code></pre><p>So how do we access performance timing metrics in Selenium script? We only need to execute simple javascript and return its value (as long). Method gets PerformanceEvent enum value as a parameter.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">getEventValue</span><span class=\"hljs-params\">(PerformanceEvent event)</span> {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">script</span> <span class=\"hljs-operator\">=</span> String.format(<span class=\"hljs-string\">&quot;return window.performance.timing.%s;&quot;</span>, event);\n        <span class=\"hljs-keyword\">return</span> executeScript(script).getLongResult();\n    }\n</code></pre><p>Now let&#39;s move to the most interesting part for every tester - actual Junit implementation. We want to display loading time in seconds on screen and assert that it isn&#39;t greater than 3 seconds.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">loadTimeTest</span><span class=\"hljs-params\">()</span> {\n        goTo(awesomeTestingPage);\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">loadEventEnd</span> <span class=\"hljs-operator\">=</span> getEventValue(LOAD_EVENT_END);\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">navigationStart</span> <span class=\"hljs-operator\">=</span> getEventValue(NAVIGATION_START);\n\n        assertThat(getLoadTimeInSeconds(loadEventEnd, navigationStart))\n            .isLessThanOrEqualTo(<span class=\"hljs-number\">3</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">getLoadTimeInSeconds</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> loadEventEnd, <span class=\"hljs-type\">long</span> navigationStart)</span> {\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">loadTimeInSeconds</span> <span class=\"hljs-operator\">=</span> (loadEventEnd - navigationStart) / <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">logBody</span> <span class=\"hljs-operator\">=</span> String.format(<span class=\"hljs-string\">&quot;Page Load Time is %s seconds.&quot;</span>, loadTimeInSeconds);\n        System.out.println(logBody);\n        <span class=\"hljs-keyword\">return</span> loadTimeInSeconds;\n    }\n</code></pre><p>Pretty simple, isn&#39;t it? By the way, I checked it on Chrome and loading there is usually ~1 second faster than on Microsoft Edge.</p><p>Complete code with all imports, dependencies etc. is available on my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting/tree/2a1526ea8b07dbd18a7960ffa8845beff5083616/src/test/java/com/awesome/testing/performance/timing\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a>.<br>Enjoy :)</p>"
}