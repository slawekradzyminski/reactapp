{
  "id": "2023-05-04-bi-directional-contract-testing",
  "title": "BiDirectional Contract Testing",
  "date": "2023-05-04",
  "categories": [
    "Contract testing"
  ],
  "tags": [
    "pact",
    "contract testing"
  ],
  "permalink": "/2023/05/bi-directional-contract-testing",
  "content": "<p><img src=\"/images/blog/Pactflow-blog-logo.svg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>In today&#39;s world of complex and interconnected software systems, ensuring the reliability and compatibility of various<br>components has become a critical part of the development process. As teams work on different services, the need for<br>effective integration testing becomes more important than ever. Among the various approaches to integration testing,<br>Bidirectional Contract Testing has emerged as a powerful technique that helps teams build more robust and maintainable<br>software systems.</p>\n<p>In this comprehensive guide, we will delve into the world of Bidirectional Contract Testing, exploring how it bridges<br>the gap between end-to-end tests and tests in isolation. We will begin by discussing the testing spectrum, highlighting<br>the advantages and disadvantages of end-to-end tests and tests in isolation, as well as the implications of using Docker<br>Compose for creating isolated testing environments. Next, we will introduce the concept of Contract Testing and discuss<br>its benefits in the context of modern software development.</p>\n<p>Following that, we will cover Consumer-Driven Contract Testing with Pact, a widely used framework for this purpose.<br>Building upon this foundation, we will then introduce Bidirectional Contract Testing, a powerful extension of Contract<br>Testing that offers additional benefits.</p>\n<p>Finally, we will walk you through a demo presentation of a working project in Java, illustrating how to implement<br>Bidirectional Contract Testing in a real-world scenario. By the end of this guide, you will have a solid understanding<br>of the principles and benefits of Bidirectional Contract Testing, empowering you to make more informed decisions about<br>your integration testing strategies.</p>\n<p>Join us on this exciting journey into the world of Bidirectional Contract Testing, and discover how this innovative<br>approach can help you build better, more reliable software systems.</p>\n<h2>The Testing Spectrum: End-to-End Tests vs. Tests in Isolation and the Role of Docker Compose</h2>\n<p>Understanding the testing spectrum is crucial for making informed decisions about your integration testing strategies.<br>In this section, we will explore two distinct types of tests that lie on opposite ends of the spectrum: end-to-end tests<br>and tests in isolation. Additionally, we will discuss the role of Docker Compose in achieving isolation, and how it can<br>influence your testing approach.</p>\n<h3>End-to-end tests: advantages and disadvantages</h3>\n<p>End-to-end tests (E2E tests) involve testing an entire system or application as a whole, from the user interface down to<br>the backend services and databases. These tests simulate real-world user scenarios and interactions, aiming to ensure<br>that all components of a system work together as expected.</p>\n<p><strong>Advantages:</strong></p>\n<ul>\n<li>Realism: E2E tests closely replicate real-world user scenarios, providing a high level of confidence that the system<br>works as intended.</li>\n<li>Comprehensive coverage: By testing the entire system, E2E tests can identify issues that may not be detectable through<br>isolated tests, such as integration problems or performance bottlenecks.</li>\n<li>Business value: E2E tests can provide crucial insights into the overall functionality and performance of the system,<br>helping stakeholders make informed decisions based on a comprehensive understanding of the system&#39;s behavior in<br>real-world scenarios.</li>\n<li>Clear signal for action: When an E2E test fails, it serves as a strong indication that there is an issue within the<br>system that requires investigation, emphasizing the need to address the problem.</li>\n</ul>\n<p><strong>Disadvantages:</strong></p>\n<ul>\n<li>Time-consuming: E2E tests can be slow to execute, as they require the setup and interaction of multiple components.</li>\n<li>Maintenance burden: As the system evolves, E2E tests may need to be updated frequently to accommodate changes in the<br>application&#39;s behavior, user interface, or underlying services.</li>\n<li>Flakiness: E2E tests can be prone to flakiness, often due to issues like network latency or timeouts. This can lead to<br>false negatives and a loss of trust in the testing process.</li>\n<li>Tricky debugging: Debugging E2E tests can be challenging, as the issue could potentially occur anywhere within the<br>system, making it more difficult to pinpoint the exact cause of the problem.</li>\n<li>Incomplete coverage due to mocking: Despite their comprehensive nature, E2E tests may still require mocking external<br>dependencies, such as third-party APIs or services, which can limit the true end-to-end coverage and potentially mask<br>issues related to these external integrations.</li>\n<li>Long feedback loop: E2E tests often require single or multiple deployments, resulting in a longer feedback loop<br>compared to tests in isolation. This can slow down the development process and delay the identification and resolution<br>of issues.</li>\n</ul>\n<p>{% include image.html url=&quot;/images/blog/E2E.png&quot; description=&quot;E2E tests give us confidence that the System works a whole, but do we really need to connect to everything while testing service F?&quot; %}</p>\n<h3>Tests in Isolation: advantages and disadvantages</h3>\n<p>Tests in isolation, also known as unit tests or component tests, focus on testing individual components or functions<br>within a system. These tests typically use mock objects or stubs to simulate dependencies, allowing developers to test a<br>single piece of functionality in isolation from the rest of the system. You can read more about isolated Cypress tests<br>in my <a href=\"https://www.awesome-testing.com/2020/02/isolated-cypress-ui-tests\" target=\"_blank\" rel=\"noreferrer\">post</a>.</p>\n<p><strong>Advantages:</strong></p>\n<ul>\n<li>Speed: Isolated tests are generally faster to execute than E2E tests, as they do not require the setup and interaction<br>of multiple components.</li>\n<li>Precision: When a test in isolation fails, it usually points directly to the faulty component or function, making it<br>easier to identify, debug, and fix issues.</li>\n<li>Maintainability: As these tests focus on specific components, they are less susceptible to changes in the overall<br>system, making them easier to maintain over time.</li>\n<li>Short feedback loop: Tests in isolation can run after each push to a Git repository and do not require deployment,<br>providing developers with a quicker feedback loop, enabling them to identify and address issues more efficiently.</li>\n</ul>\n<p><strong>Disadvantages:</strong></p>\n<ul>\n<li>Limited scope: Since tests in isolation focus on individual components, they may not detect integration issues or<br>problems that arise when the system is used as a whole.</li>\n<li>Overemphasis on implementation details: Writing tests in isolation can sometimes lead to an overemphasis on the<br>internal<br>workings of a component, rather than the desired behavior from a user&#39;s perspective.</li>\n<li>Potential for over-mocking: Relying heavily on mock objects or stubs can lead to tests that are tightly coupled to the<br>implementation, making them brittle and less effective at catching errors.</li>\n<li>Maintenance burden: Keeping mocks up-to-date can be challenging as the system evolves, and failing to do so might<br>result in outdated tests that no longer reflect the actual behavior of the system, causing false confidence in the<br>test results.</li>\n<li>Limited business value: Tests in isolation provide limited insight into the overall functionality and performance of<br>the system. Relying solely on them can be risky, as they do not answer whether the system as a whole<br>is working correctly, which is crucial for making informed decisions about the software&#39;s readiness for production.</li>\n</ul>\n<p>{% include image.html url=&quot;/images/blog/Isolation.png&quot; description=&quot;Isolated tests scope is very small making them very stable. Each service is tested independently using stubs. But how do we make sure these stubs are up-to-date?&quot; %}</p>\n<h3>Achieving Isolation with Docker Compose</h3>\n<p>While there are not many testing approaches that fall between end-to-end tests and tests in isolation, Docker Compose<br>emerges as a potential tool of choice to bridge this gap. Docker Compose is a powerful tool for defining and<br>orchestrating multi-container Docker applications, allowing developers to run and manage multiple services together in<br>an isolated environment, which can be particularly useful for testing purposes.</p>\n<p>As a solution to address the challenges of both end-to-end and isolated tests, Docker Compose enables developers to<br>exercise their applications with real services, while maintaining a consistent and identical testing environment across<br>different stages of development. This approach strikes a balance between the realism of end-to-end tests and the speed<br>of tests in isolation, providing teams with the ability to test complex interactions and integrations with confidence.</p>\n<p>By leveraging Docker Compose, teams not only gain the advantage of identifying potential issues early in the development<br>process but also benefit from a streamlined testing pipeline, making it easier to maintain and manage. With Docker<br>Compose, developers can experience the best of both worlds, harnessing the strengths of both end-to-end and isolated<br>testing approaches.</p>\n<p>Using <code>docker-compose.yml</code> to achieve isolation can have its advantages and challenges:</p>\n<p><strong>Advantages:</strong></p>\n<ul>\n<li>Shorter feedback loop: By running the entire environment using Docker Compose, developers can avoid the need for<br>deployments, thereby shortening the feedback loop and making it easier to identify and resolve issues quickly.</li>\n<li>Reproducible environment: Docker Compose ensures that each service runs in a consistent and reproducible environment,<br>reducing the risk of inconsistencies between development, testing, and production.</li>\n</ul>\n<p><strong>Challenges:</strong></p>\n<ul>\n<li>Dependency management: Implementing a docker-compose.yml setup that correctly manages dependencies can be challenging,<br>as developers must ensure that all required services are configured and connected correctly.</li>\n<li>Resource constraints: As the number of services and their resource requirements grow, starting the whole environment<br>using Docker Compose can become increasingly difficult due to heavy RAM requirements. This can lead to limitations in<br>terms of scalability and the ability to run the environment on local machines.</li>\n<li>Utilizing External APIs: When integrating with external APIs, it&#39;s necessary either for the third-party company to<br>provide a Dockerized version of their service or for your team to build and maintain your own mock of the external API.<br>This can add extra complexity and maintenance overhead to the development process.</li>\n</ul>\n<p>By understanding the advantages and disadvantages of end-to-end tests and tests in isolation, as well as the role of<br>Docker Compose in achieving isolation, you can make more informed decisions about your testing strategy and strike the<br>right balance for your project. In the next section, we will explore how Contract Testing can bridge the gap between<br>these two testing approaches.</p>\n<h2>Contract Tests: An Introduction</h2>\n<p>Contract Testing is an approach to integration testing that focuses on the contracts or interactions between different<br>components of a system. Popularized by Martin Fowler in 2011 through his blog<br>post <a href=\"https://martinfowler.com/bliki/ContractTest.html\" target=\"_blank\" rel=\"noreferrer\">ContractTest</a>, the idea behind<br>Contract Testing is to verify that individual components can correctly communicate with each other, adhering to a shared<br>understanding of how their interactions should work.</p>\n<p>One of the main strengths of Contract Testing lies in its ability to complement the testing in isolation strategy by<br>ensuring that the mocks used in isolated tests are up-to-date and accurate. This is largely due to the asynchronous<br>nature of contract tests, which allows them to be executed independently of the actual integration between services.</p>\n<p>By focusing on the contracts or interactions between components, Contract Testing ensures that the expectations of both<br>the consumer and provider are aligned. This not only verifies that the components can communicate effectively with each<br>other but also promotes a better understanding of the system&#39;s behavior and dependencies.</p>\n<p>At the same time, Contract Testing retains the benefits typically associated with isolated tests, such as speed and fast<br>feedback. As contracts are tested independently, without the need for setting up and interacting with the actual<br>integrated system, these tests can be executed more quickly than end-to-end tests. This results in a shorter feedback<br>loop, enabling developers to identify and address issues more efficiently.</p>\n<p>There are several frameworks available for implementing Contract Testing, with Pact and Spring Cloud Contract being<br>among the most popular. These frameworks offer powerful tools and features for creating and validating contracts between<br>services, ensuring that both consumers and providers adhere to the agreed-upon expectations.</p>\n<p>{% include image.html url=&quot;/images/blog/Contract.png&quot; description=&quot;Contract tests focus on interfaces (red arrows) making them perfect supplementary for isolated tests.&quot; %}</p>\n<h3>Pact: A Language-Agnostic Framework for Contract Testing</h3>\n<p><a href=\"https://docs.pact.io\" target=\"_blank\" rel=\"noreferrer\">Pact</a> is a language-agnostic framework for Contract Testing that enables developers to create and<br>test contracts between services in a variety of programming languages, including Java, JavaScript, Ruby, Go, and others.<br>Pact provides a set of libraries and tools to generate contract files, validate them against the provider&#39;s<br>implementation, and report any discrepancies.</p>\n<p>Key features of Pact include:</p>\n<ul>\n<li>Language-agnostic: Pact supports multiple programming languages, making it suitable for teams working with diverse<br>technology stacks.</li>\n<li>Extensive tooling: Pact offers a range of tools for generating, validating, and sharing contracts, streamlining the<br>Contract Testing process.</li>\n<li>Mock services: Pact provides mock services that can be used by consumers to simulate the behavior of providers during<br>testing, ensuring a consistent testing environment.</li>\n</ul>\n<h3>Spring Cloud Contract: Contract Testing for Spring-Based Applications</h3>\n<p><a href=\"https://spring.io/projects/spring-cloud-contract\" target=\"_blank\" rel=\"noreferrer\">Spring Cloud Contract</a> is a framework specifically designed for<br>implementing Contract Testing in Spring-based applications. It provides support for defining contracts using Groovy or<br>YAML and integrates seamlessly with the Spring ecosystem. Spring Cloud Contract offers features such as automatic<br>generation of tests, stubs, and API documentation based on the contracts, making it an attractive choice for developers<br>working with Spring-based microservices.</p>\n<p>Key features of Spring Cloud Contract include:</p>\n<ul>\n<li>Spring integration: Spring Cloud Contract is tailor-made for Spring-based applications, offering seamless integration<br>with the Spring ecosystem.</li>\n<li>Flexible contract definition: Contracts can be defined using Groovy or YAML, providing developers with flexibility in<br>expressing their expectations.</li>\n<li>Automated test generation: Spring Cloud Contract automatically generates tests and stubs based on the defined<br>contracts,<br>simplifying the testing process.</li>\n</ul>\n<p>By incorporating Contract Testing with popular frameworks like Pact or Spring Cloud Contract, development teams can<br>ensure better communication and alignment of expectations between service consumers and providers. This ultimately<br>leads to more reliable software systems with fewer integration issues. In the next sections, we will explore more<br>advanced concepts and techniques related to Contract Testing, helping you to make the most of this powerful approach to<br>integration testing.</p>\n<h2>Consumer Driven Contract Tests</h2>\n<p>Consumer-Driven Contract Tests (CDCT) is an approach to Contract Testing that puts the focus on the expectations of the<br>consumers (clients) while verifying the integration on the provider (server) side. This method ensures that both parties<br>have a clear understanding of the interactions between them, resulting in more reliable and maintainable software<br>systems.</p>\n<p>The CDCT process consists of five distinct phases:</p>\n<p>{% include image.html url=&quot;/images/blog/cdct.png&quot; description=&quot;CDCT visualisation&quot; %}</p>\n<p><strong>1. Contract creation on the Consumer side</strong></p>\n<p>In this phase, consumers create contracts that define their expectations regarding the API they are consuming. This<br>step requires writing custom code in all consumer codebases, which specifies the expected behavior of the provider&#39;s<br>API.</p>\n<pre><code class=\"language-java\">public class BasicOkTest extends AbstractPactTest {\n\n    @Override\n    public RequestResponsePact createPact(PactDslWithProvider builder) {\n        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();\n        headers.put(&quot;Content-Type&quot;, MediaType.APPLICATION_JSON_VALUE);\n\n        return builder\n                .given(&quot;Two entries exist&quot;)\n                .uponReceiving(&quot;Two entries exist&quot;)\n                .path(&quot;/information&quot;)\n                .query(&quot;name=&quot; + MESSI)\n                .method(&quot;GET&quot;)\n                .willRespondWith()\n                .headers(headers)\n                .status(200)\n                .body(newJsonBody((root) -&gt; {\n                    root.numberType(&quot;salary&quot;, 7500);\n                    root.stringType(&quot;name&quot;, MESSI);\n                    root.stringType(&quot;nationality&quot;, &quot;Argentina&quot;);\n                }).build())\n                .toPact();\n    }\n\n    @Override\n    protected void runTest(MockServer mockServer, PactTestExecutionContext context) {\n        providerService.overrideBackendUrl(mockServer.getUrl());\n        Information information = providerService.getResponseForName(MESSI).getBody();\n        assertThat(information).isNotNull();\n        assertThat(information.getName()).isEqualTo(MESSI);\n    }\n\n}\n</code></pre>\n<p><strong>2. Publishing the contract to a third-party application - Pact Broker</strong></p>\n<p>Once the contracts are created, they are published to a third-party application called the Pact Broker. The Pact<br>Broker serves as a centralized repository for storing and managing the contracts between consumers and providers.</p>\n<p><strong>3. Sharing the contract with the Provider</strong></p>\n<p>The contracts are then shared with the provider, ensuring that both parties have access to the agreed-upon<br>expectations and can work towards fulfilling them.</p>\n<p><strong>4. Contract verification on the Provider side</strong></p>\n<p>In this phase, the provider verifies that their implementation meets the expectations outlined in the contract. This<br>step requires writing custom code on the provider side, which validates that the API behaves as expected according to<br>the contract. The contract testing tool utilizes Wiremock to simulate the interactions defined in the contract,<br>allowing the provider to verify the correctness of their implementation.</p>\n<pre><code class=\"language-java\">@RunWith(SpringRestPactRunner.class)\n@Provider(&quot;ExampleProvider&quot;)\n@PactBroker(host = &quot;localhost&quot;, port = &quot;9292&quot;, tags = {&quot;master&quot;})\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)\npublic class ProviderContractTest {\n\n    @Autowired\n    private InformationService informationService;\n\n    @TestTarget\n    public final Target target = new SpringBootHttpTarget();\n\n    @State(&quot;Empty database state&quot;)\n    public void emptyDatabase() {\n        ContractState.EMPTY.setState(informationService);\n    }\n\n    @State(&quot;Two entries exist&quot;)\n    public void defaultState() {\n        ContractState.DEFAULT.setState(informationService);\n    }\n\n}\n</code></pre>\n<p><strong>5. Publishing the results back to the Pact Broker and verifying the contract</strong></p>\n<p>Once the verification process is complete, the results are published back to the Pact Broker. This allows both<br>parties to review the results and confirm that the contract has been successfully verified, ensuring seamless<br>integration between the consumer and provider.</p>\n<p>{% include image.html url=&quot;/images/blog/pactbroker.png&quot; description=&quot;Pact Broker showing verified contracts&quot; %}</p>\n<p>You can find more information about CDCT and working example in my<br>repository <a href=\"https://github.com/slawekradzyminski/PactExample\" target=\"_blank\" rel=\"noreferrer\">PactExample</a>.</p>\n<h3>Issues with Consumer-Driven Contract Tests</h3>\n<p>Consumer-Driven Contract Testing (CDCT) is a compelling concept that aims to improve integration testing between<br>components. However, it has not gained mainstream adoption in the testing community. It&#39;s rare to find job descriptions<br>explicitly requiring knowledge of contract testing. Several factors contribute to the limited adoption of CDCT, and it&#39;s<br>important to note that many of these issues have been addressed in BiDirectional Contract Testing, which will be<br>discussed later.</p>\n<p><strong>Immature Tooling</strong></p>\n<p>While the CDCT concept started gaining interest among testers, the initial tooling had multiple bugs and limitations<br>that discouraged early adopters. The lack of mature and reliable tools made it difficult for teams to fully embrace<br>CDCT, slowing its adoption in the industry.</p>\n<p><strong>Extra Code for Contract Testing</strong></p>\n<p>The need to write and maintain additional code for contract testing purposes can be a significant investment, especially<br>when dealing with dozens of services. This extra effort might deter teams from adopting CDCT, as it can be seen as an<br>additional burden on top of their existing development and testing responsibilities.</p>\n<p><strong>Complex State Management</strong></p>\n<p>In CDCT, communication between consumer and provider occurs via contract states. The consumer defines a state, which the<br>provider then needs to handle, mock, or prepare. This can become complex when the provider has to synchronize with<br>multiple consumers, each having numerous states. For example, a provider synchronizing with three consumers with 15<br>states each would need to handle 45 different scenarios in their codebase. In real-world situations, provider teams<br>often encourage consumers to use the same states, which introduces invisible coupling in consumer codebases, creating<br>additional complexity.</p>\n<p><strong>Complex Tagging and Change Management</strong></p>\n<p>While the &quot;happy flow&quot; in CDCT is straightforward, things can become complicated when changes need to be made to the<br>contract between the consumer and provider. Initially, tags were used to manage these changes, but this approach has<br>been deprecated in favor of using environments. The transition to environments and the complexities that arise during<br>contract modifications have made CDCT more difficult to manage, hindering its widespread adoption.</p>\n<p><strong>Integration with External APIs</strong></p>\n<p>CDCT presents a challenge when attempting to integrate with external APIs owned by third-party companies. This is<br>because CDCT requires cooperation in defining contract states, which may not be possible when dealing with external<br>providers that are outside your organization&#39;s control.</p>\n<p>It is worth noting that the author of this analysis has never openly endorsed CDCT, acknowledging its limitations and<br>the need for improvements to make it more accessible and practical for teams to adopt. While CDCT has potential, its<br>current challenges have limited its impact on the testing landscape, and it remains a niche approach to integration<br>testing. I recommend to take a look into BiDirectional Contract Testing instead.</p>\n<h2>BiDirectional Contract Testing</h2>\n<p>Bidirectional Contract Testing is a relatively new approach to contract testing that aims to address many of the<br>limitations associated with Consumer-Driven Contract Testing (CDCT). It is available only in the paid version of<br>Pactflow (for teams with 5+ users) and has the potential to revolutionize the field of contract testing. By resolving<br>many of the issues associated with CDCT, Bidirectional Contract Testing makes it more accessible and practical for teams<br>to adopt.</p>\n<p>The Bidirectional Contract Testing flow consists of three main phases:</p>\n<p>{% include image.html url=&quot;/images/blog/bidi.png&quot; description=&quot;BiDirectional Contact Testing&quot; %}</p>\n<p><strong>Provider OpenAPI Specification Upload</strong></p>\n<p>The provider must upload their OpenAPI specification to Pactflow. The OpenAPI specification serves as the source of<br>truth for the API, providing a clear and accurate description of the API&#39;s behavior and functionality.</p>\n<p><strong>Consumer Contract Generation and Upload</strong></p>\n<p>The consumer generates a contract based on their existing isolated tests, using an extension library. Multiple<br>extensions are available, supporting popular tools<br>like <a href=\"https://bitbucket.org/atlassian/wiremock-pact-generator/src/master/\" target=\"_blank\" rel=\"noreferrer\">WireMock</a>, <a href=\"https://www.npmjs.com/package/@pactflow/pact-cypress-adapter\" target=\"_blank\" rel=\"noreferrer\">Cypress</a>,<br>and <a href=\"https://github.com/pactflow/example-bi-directional-consumer-playwright-js\" target=\"_blank\" rel=\"noreferrer\">Playwright</a>. Once the contract is<br>generated, it must be uploaded to Pactflow as well. This approach simplifies the contract generation process and reduces<br>the amount of extra code needed for contract testing, making it more appealing to adopt.</p>\n<p>It is worth noting that the tooling for this method may still appear to be immature in some aspects. However, as with<br>any emerging technology, it may take time for the tooling to mature and become more stable. Early adopters of<br>Bidirectional Contract Testing may encounter limitations, bugs, or other issues that can impact the efficiency and<br>effectiveness of their testing efforts. It is essential for teams considering adopting this approach to be aware of<br>these potential challenges and stay informed about updates and improvements to the tools they use.</p>\n<p><strong>Pactflow Contract Validation</strong></p>\n<p>Pactflow performs its &quot;magic&quot; by analyzing the generated consumer contract and the provider&#39;s OpenAPI specification. It<br>then determines whether the mocks defined in the consumer tests meet the provider&#39;s requirements as described in their<br>OpenAPI specification. This automated validation process ensures that the consumer and provider are aligned, promoting<br>effective communication and reducing the risk of integration issues.</p>\n<p>After the contract validation process, both the provider and consumer teams can use<br>the <a href=\"https://docs.pact.io/pact_broker/can_i_deploy\" target=\"_blank\" rel=\"noreferrer\">can i deploy</a> tool available<br>in Pactflow. This tool helps determine whether it is safe to deploy their respective components to production,<br>considering the current state of contracts and their compatibility. This additional step provides teams with confidence<br>in their deployments and further reduces the risk of integration issues in production environments.</p>\n<p>By addressing the challenges of CDCT, Bidirectional Contract Testing offers a more streamlined and manageable approach<br>to contract testing. It eliminates the need for complex state management, simplifies change management, and removes the<br>burden of writing and maintaining extra code for contract testing purposes. Furthermore, it enables integration with<br>external APIs by leveraging the widely-used OpenAPI standard. With these improvements, Bidirectional Contract Testing<br>has the potential to become a game-changer in the world of integration testing, making it a valuable addition to any<br>team&#39;s testing toolkit.</p>\n<h3>Pactflow pricing</h3>\n<p>While the open-source Pact Broker offers an extensive set of features for contract testing, it is important to note that<br>most of the &quot;magic&quot; behind Bidirectional Contract Testing is available exclusively in the paid Pactflow version.</p>\n<p>Pactflow builds on the capabilities of the free Pact Broker, providing additional features, support, and enhancements<br>that are tailored to the needs of professional teams. One of these key enhancements is the support for Bidirectional<br>Contract Testing.</p>\n<p>The pricing for Pactflow can be found on their official <a href=\"https://pactflow.io/pricing/\" target=\"_blank\" rel=\"noreferrer\">pricing page</a>.</p>\n<h2>Demo: BiDirectional Contract Testing in Action</h2>\n<p>In this demo, we will use the following components:</p>\n<ul>\n<li><a href=\"https://www.bezkoder.com/spring-boot-swagger-3/\" target=\"_blank\" rel=\"noreferrer\">bezkoder Spring Boot 3 + OpenAPI example project</a></li>\n<li>My custom client available on <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer\" target=\"_blank\" rel=\"noreferrer\">GitHub</a></li>\n<li>My free-tier instance of <a href=\"https://awesome-testing.pactflow.io\" target=\"_blank\" rel=\"noreferrer\">Pactflow</a></li>\n</ul>\n<h3>Provider</h3>\n<p>As mentioned earlier, it is impossible to integrate with External APIs using the CDCT approach. With BiDirectional<br>Contract Testing, this becomes possible, as long as the external API we want to integrate with publishes its OpenAPI<br>specification. For this demo, we have chosen an example project found on<br>GitHub: <a href=\"https://www.bezkoder.com/spring-boot-swagger-3/\" target=\"_blank\" rel=\"noreferrer\">https://www.bezkoder.com/spring-boot-swagger-3/</a></p>\n<p>After running the project via <code>./mvnw spring-boot:run</code>, we can access the OpenAPI specification<br>at <a href=\"http://localhost:8080/bezkoder-api-docs\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8080/bezkoder-api-docs</a></p>\n<p>To make the demo easier to follow, the <code>openapi.json</code> has been uploaded to the consumer<br>repository: <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/incompatibleopenapi.json\" target=\"_blank\" rel=\"noreferrer\">incompatible OpenAPI</a></p>\n<p>Please note that there is a bug in the schema (single Tutorial instead of an array of Tutorials) for<br>the <code>/api/tutorials</code><br>GET endpoint, which has been fixed by me. The correct specification can be found<br>here: <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/openapi.json\" target=\"_blank\" rel=\"noreferrer\">openapi.json</a>.<br>Details about the bug are available<br>in <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/README.md\" target=\"_blank\" rel=\"noreferrer\">README.md</a>.<br>Perhaps Pactflow wisely recommends to test OpenAPI specification<br>via <a href=\"https://docs.pactflow.io/docs/workshops/bi-directional/step3\" target=\"_blank\" rel=\"noreferrer\">additional unit tests</a>.</p>\n<p>This demonstrates that BiDirectional Contract Tests have the power to identify bugs and help ensure the accuracy of API<br>contracts.</p>\n<p>Provider contract can be uploaded using<br>the <a href=\"https://docs.pactflow.io/docs/bi-directional-contract-testing/contracts/oas#publishing\" target=\"_blank\" rel=\"noreferrer\">publish-provider-contract</a><br>Pact CLI command. Pactflow assumes that the Provider OpenAPI specification has been unit tested hence the requirement to<br>provide verification result file.</p>\n<pre><code class=\"language-yaml\">pactflow publish-provider-contract ./openapi.json \\\n--broker-token=TOKEN \\\n--broker-base-url=https://awesome-testing.pactflow.io \\\n--content-type application/json \\\n--provider the-provider \\\n--provider-app-version 0.0.4-SNAPSHOT \\\n--verification-results-content-type text/plain \\\n--verification-results ./result.txt \\\n--verification-success \\\n--verifier self-verification \\\n--verbose\n</code></pre>\n<h3>Consumer</h3>\n<p>The consumer has been entirely created by me, and the code is available here:<br><a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer\" target=\"_blank\" rel=\"noreferrer\">https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer</a></p>\n<p>I integrate with Bezkoder&#39;s Provider using a dummy /all endpoint, which essentially acts as a proxy:</p>\n<pre><code class=\"language-java\">@RestController\npublic class ApiController {\n@Autowired\nTutorialClient tutorialClient;\n\n    @GetMapping(&quot;/all&quot;)\n    public List&lt;TutorialDto&gt; getAll() {\n        return tutorialClient.getAll();\n    }\n}\n</code></pre>\n<p>In order to test this endpoint, I have to use Wiremock to stub Bezkoder&#39;s API:</p>\n<pre><code class=\"language-java\">@Test\nvoid shouldGeneratePactInTargetPactsFolder() throws Exception {\n    wiremock.stubFor(WireMock.get(urlEqualTo(&quot;/api/tutorials&quot;)).willReturn(aResponse()\n            .withHeader(&quot;Content-Type&quot;, &quot;application/json&quot;).withBody(&quot;&quot;&quot;\n                    [\n                      {\n                        &quot;id&quot;: 1,\n                        &quot;title&quot;: &quot;ChatGPT&quot;,\n                        &quot;description&quot;: &quot;blablabla&quot;,\n                        &quot;published&quot;: true\n                      }\n                    ]\n                    &quot;&quot;&quot;)));\n\n    this.mockMvc.perform(get(&quot;/all&quot;)).andDo(print()).andExpect(status().isOk())\n            .andExpect(jsonPath(&quot;$[0].id&quot;, is(1)))\n            .andExpect(jsonPath(&quot;$[0].title&quot;, is(&quot;ChatGPT&quot;)))\n            .andExpect(jsonPath(&quot;$[0].description&quot;, is(&quot;blablabla&quot;)))\n            .andExpect(jsonPath(&quot;$[0].published&quot;, is(true)));\n}\n</code></pre>\n<p>I assume that your consumers already have similar code (you may mock the HTTP layer using Cypress or Playwright,<br>but the flow is the same).</p>\n<p>Now we only need to add the custom Wiremock Pact creator dependency:</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.atlassian.ta&lt;/groupId&gt;\n    &lt;artifactId&gt;wiremock-pact-generator&lt;/artifactId&gt;\n    &lt;version&gt;2.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>And configure a listener for the Wiremock Server:</p>\n<pre><code class=\"language-java\">@BeforeAll\nstatic void setupClass() {\n    wiremock.addMockServiceRequestListener(\n            WireMockPactGenerator\n                    .builder(&quot;the-consumer&quot;, &quot;the-provider&quot;)\n                    .build()\n    );\n    wiremock.start();\n}\n</code></pre>\n<p>At this point, after running the tests, the consumer contract file is created in the <code>target/pacts</code> folder.<br>I upload it to Pactflow using the <code>pact-jvm-provider-maven</code> library via the <code>./mvnw pact:publish</code> command.</p>\n<h3>Pactflow</h3>\n<p>At this point, the &quot;magic&quot; happens, and the work related to verifying compatibility takes place on the Pactflow side.<br>Pactflow compares the uploaded provider contract and consumer contract to determine if the API interactions are<br>compatible. This process significantly simplifies the work for development teams and ensures that any potential<br>integration issues are identified before deploying to production.</p>\n<p>Now we can see <code>Success</code> message with correct <code>openapi.json</code></p>\n<p><img src=\"/images/blog/pactflowsuccess.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>And <code>Failed</code> message with incorrect <code>incompatibleopenapi.json</code></p>\n<p><img src=\"/images/blog/pactflowfailure.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>This demonstrates the power of BiDirectional Contract Testing in catching inconsistencies and ensuring<br>that both the consumer and provider are aligned.</p>\n<h2>Summary</h2>\n<p>In this blog post, we explored the concept of BiDirectional Contract Testing and how it can revolutionize contract<br>testing by addressing many of the issues associated with Consumer-Driven Contract Testing (CDCT). We went through the<br>three main phases of the bidirectional contract testing flow and discussed the benefits and limitations of using the<br>paid Pactflow version for BiDirectional Contract Testing. We also provided a hands-on demo using a custom client, the<br>bezkoder Spring Boot 3 + OpenAPI example project, and a free-tier instance of Pactflow.</p>\n<p>It is fascinating to see whether contract testing will finally reach mainstream adoption, given the advancements and<br>improvements offered by BiDirectional Contract Testing. It is a powerful approach that can help development teams ensure<br>the accuracy of their API contracts and significantly reduce the risks associated with integrating external APIs.</p>\n<p>We would love to hear your thoughts on BiDirectional Contract Testing. Have you tried it in your projects? How has it<br>improved your development and testing processes? Do you think this approach will finally bring contract testing into the<br>mainstream? Please share your experiences, opinions, and insights in the comments section below. Let&#39;s foster an<br>engaging discussion on the future of contract testing!</p>\n"
}