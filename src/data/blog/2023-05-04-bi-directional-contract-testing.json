{
  "id": "2023-05-04-bi-directional-contract-testing",
  "title": "BiDirectional Contract Testing",
  "date": "2023-05-04",
  "categories": [
    "Contract testing"
  ],
  "tags": [
    "pact",
    "contract testing"
  ],
  "permalink": "/2023/05/bi-directional-contract-testing",
  "content": "<p><img src=\"/images/blog/Pactflow-blog-logo.svg\" alt=\"\"></p><p>In today&#39;s world of complex and interconnected software systems, ensuring the reliability and compatibility of various components has become a critical part of the development process. As teams work on different services, the need for effective integration testing becomes more important than ever. Among the various approaches to integration testing,<br>Bidirectional Contract Testing has emerged as a powerful technique that helps teams build more robust and maintainable software systems.</p><p>In this comprehensive guide, we will delve into the world of Bidirectional Contract Testing, exploring how it bridges the gap between end-to-end tests and tests in isolation. We will begin by discussing the testing spectrum, highlighting the advantages and disadvantages of end-to-end tests and tests in isolation, as well as the implications of using Docker Compose for creating isolated testing environments. Next, we will introduce the concept of Contract Testing and discuss its benefits in the context of modern software development.</p><p>Following that, we will cover Consumer-Driven Contract Testing with Pact, a widely used framework for this purpose.<br>Building upon this foundation, we will then introduce Bidirectional Contract Testing, a powerful extension of Contract Testing that offers additional benefits.</p><p>Finally, we will walk you through a demo presentation of a working project in Java, illustrating how to implement Bidirectional Contract Testing in a real-world scenario. By the end of this guide, you will have a solid understanding of the principles and benefits of Bidirectional Contract Testing, empowering you to make more informed decisions about your integration testing strategies.</p><p>Join us on this exciting journey into the world of Bidirectional Contract Testing, and discover how this innovative approach can help you build better, more reliable software systems.</p><h2>The Testing Spectrum: End-to-End Tests vs. Tests in Isolation and the Role of Docker Compose</h2>\n<p>Understanding the testing spectrum is crucial for making informed decisions about your integration testing strategies.<br>In this section, we will explore two distinct types of tests that lie on opposite ends of the spectrum: end-to-end tests and tests in isolation. Additionally, we will discuss the role of Docker Compose in achieving isolation, and how it can influence your testing approach.</p><h3>End-to-end tests: advantages and disadvantages</h3>\n<p>End-to-end tests (E2E tests) involve testing an entire system or application as a whole, from the user interface down to the backend services and databases. These tests simulate real-world user scenarios and interactions, aiming to ensure that all components of a system work together as expected.</p><p><strong>Advantages:</strong></p><ul>\n<li>Realism: E2E tests closely replicate real-world user scenarios, providing a high level of confidence that the system<br>works as intended.</li>\n<li>Comprehensive coverage: By testing the entire system, E2E tests can identify issues that may not be detectable through<br>isolated tests, such as integration problems or performance bottlenecks.</li>\n<li>Business value: E2E tests can provide crucial insights into the overall functionality and performance of the system,<br>helping stakeholders make informed decisions based on a comprehensive understanding of the system&#39;s behavior in<br>real-world scenarios.</li>\n<li>Clear signal for action: When an E2E test fails, it serves as a strong indication that there is an issue within the<br>system that requires investigation, emphasizing the need to address the problem.</li>\n</ul>\n<p><strong>Disadvantages:</strong></p><ul>\n<li>Time-consuming: E2E tests can be slow to execute, as they require the setup and interaction of multiple components.</li>\n<li>Maintenance burden: As the system evolves, E2E tests may need to be updated frequently to accommodate changes in the<br>application&#39;s behavior, user interface, or underlying services.</li>\n<li>Flakiness: E2E tests can be prone to flakiness, often due to issues like network latency or timeouts. This can lead to<br>false negatives and a loss of trust in the testing process.</li>\n<li>Tricky debugging: Debugging E2E tests can be challenging, as the issue could potentially occur anywhere within the<br>system, making it more difficult to pinpoint the exact cause of the problem.</li>\n<li>Incomplete coverage due to mocking: Despite their comprehensive nature, E2E tests may still require mocking external<br>dependencies, such as third-party APIs or services, which can limit the true end-to-end coverage and potentially mask<br>issues related to these external integrations.</li>\n<li>Long feedback loop: E2E tests often require single or multiple deployments, resulting in a longer feedback loop<br>compared to tests in isolation. This can slow down the development process and delay the identification and resolution<br>of issues.</li>\n</ul>\n<p>{% include image.html url=&quot;/images/blog/E2E.png&quot; description=&quot;E2E tests give us confidence that the System works a whole, but do we really need to connect to everything while testing service F?&quot; %}</p><h3>Tests in Isolation: advantages and disadvantages</h3>\n<p>Tests in isolation, also known as unit tests or component tests, focus on testing individual components or functions within a system. These tests typically use mock objects or stubs to simulate dependencies, allowing developers to test a single piece of functionality in isolation from the rest of the system. You can read more about isolated Cypress tests in my <a href=\"https://www.awesome-testing.com/2020/02/isolated-cypress-ui-tests\" target=\"_blank\" rel=\"noreferrer\">post</a>.</p><p><strong>Advantages:</strong></p><ul>\n<li>Speed: Isolated tests are generally faster to execute than E2E tests, as they do not require the setup and interaction<br>of multiple components.</li>\n<li>Precision: When a test in isolation fails, it usually points directly to the faulty component or function, making it<br>easier to identify, debug, and fix issues.</li>\n<li>Maintainability: As these tests focus on specific components, they are less susceptible to changes in the overall<br>system, making them easier to maintain over time.</li>\n<li>Short feedback loop: Tests in isolation can run after each push to a Git repository and do not require deployment,<br>providing developers with a quicker feedback loop, enabling them to identify and address issues more efficiently.</li>\n</ul>\n<p><strong>Disadvantages:</strong></p><ul>\n<li>Limited scope: Since tests in isolation focus on individual components, they may not detect integration issues or<br>problems that arise when the system is used as a whole.</li>\n<li>Overemphasis on implementation details: Writing tests in isolation can sometimes lead to an overemphasis on the<br>internal<br>workings of a component, rather than the desired behavior from a user&#39;s perspective.</li>\n<li>Potential for over-mocking: Relying heavily on mock objects or stubs can lead to tests that are tightly coupled to the<br>implementation, making them brittle and less effective at catching errors.</li>\n<li>Maintenance burden: Keeping mocks up-to-date can be challenging as the system evolves, and failing to do so might<br>result in outdated tests that no longer reflect the actual behavior of the system, causing false confidence in the<br>test results.</li>\n<li>Limited business value: Tests in isolation provide limited insight into the overall functionality and performance of<br>the system. Relying solely on them can be risky, as they do not answer whether the system as a whole<br>is working correctly, which is crucial for making informed decisions about the software&#39;s readiness for production.</li>\n</ul>\n<p>{% include image.html url=&quot;/images/blog/Isolation.png&quot; description=&quot;Isolated tests scope is very small making them very stable. Each service is tested independently using stubs. But how do we make sure these stubs are up-to-date?&quot; %}</p><h3>Achieving Isolation with Docker Compose</h3>\n<p>While there are not many testing approaches that fall between end-to-end tests and tests in isolation, Docker Compose emerges as a potential tool of choice to bridge this gap. Docker Compose is a powerful tool for defining and orchestrating multi-container Docker applications, allowing developers to run and manage multiple services together in an isolated environment, which can be particularly useful for testing purposes.</p><p>As a solution to address the challenges of both end-to-end and isolated tests, Docker Compose enables developers to exercise their applications with real services, while maintaining a consistent and identical testing environment across different stages of development. This approach strikes a balance between the realism of end-to-end tests and the speed of tests in isolation, providing teams with the ability to test complex interactions and integrations with confidence.</p><p>By leveraging Docker Compose, teams not only gain the advantage of identifying potential issues early in the development process but also benefit from a streamlined testing pipeline, making it easier to maintain and manage. With Docker Compose, developers can experience the best of both worlds, harnessing the strengths of both end-to-end and isolated testing approaches.</p><p>Using <code>docker-compose.yml</code> to achieve isolation can have its advantages and challenges:</p><p><strong>Advantages:</strong></p><ul>\n<li>Shorter feedback loop: By running the entire environment using Docker Compose, developers can avoid the need for<br>deployments, thereby shortening the feedback loop and making it easier to identify and resolve issues quickly.</li>\n<li>Reproducible environment: Docker Compose ensures that each service runs in a consistent and reproducible environment,<br>reducing the risk of inconsistencies between development, testing, and production.</li>\n</ul>\n<p><strong>Challenges:</strong></p><ul>\n<li>Dependency management: Implementing a docker-compose.yml setup that correctly manages dependencies can be challenging,<br>as developers must ensure that all required services are configured and connected correctly.</li>\n<li>Resource constraints: As the number of services and their resource requirements grow, starting the whole environment<br>using Docker Compose can become increasingly difficult due to heavy RAM requirements. This can lead to limitations in<br>terms of scalability and the ability to run the environment on local machines.</li>\n<li>Utilizing External APIs: When integrating with external APIs, it&#39;s necessary either for the third-party company to<br>provide a Dockerized version of their service or for your team to build and maintain your own mock of the external API.<br>This can add extra complexity and maintenance overhead to the development process.</li>\n</ul>\n<p>By understanding the advantages and disadvantages of end-to-end tests and tests in isolation, as well as the role of Docker Compose in achieving isolation, you can make more informed decisions about your testing strategy and strike the right balance for your project. In the next section, we will explore how Contract Testing can bridge the gap between these two testing approaches.</p><h2>Contract Tests: An Introduction</h2>\n<p>Contract Testing is an approach to integration testing that focuses on the contracts or interactions between different components of a system. Popularized by Martin Fowler in 2011 through his blog post <a href=\"https://martinfowler.com/bliki/ContractTest.html\" target=\"_blank\" rel=\"noreferrer\">ContractTest</a>, the idea behind Contract Testing is to verify that individual components can correctly communicate with each other, adhering to a shared understanding of how their interactions should work.</p><p>One of the main strengths of Contract Testing lies in its ability to complement the testing in isolation strategy by ensuring that the mocks used in isolated tests are up-to-date and accurate. This is largely due to the asynchronous nature of contract tests, which allows them to be executed independently of the actual integration between services.</p><p>By focusing on the contracts or interactions between components, Contract Testing ensures that the expectations of both the consumer and provider are aligned. This not only verifies that the components can communicate effectively with each other but also promotes a better understanding of the system&#39;s behavior and dependencies.</p><p>At the same time, Contract Testing retains the benefits typically associated with isolated tests, such as speed and fast feedback. As contracts are tested independently, without the need for setting up and interacting with the actual integrated system, these tests can be executed more quickly than end-to-end tests. This results in a shorter feedback loop, enabling developers to identify and address issues more efficiently.</p><p>There are several frameworks available for implementing Contract Testing, with Pact and Spring Cloud Contract being among the most popular. These frameworks offer powerful tools and features for creating and validating contracts between services, ensuring that both consumers and providers adhere to the agreed-upon expectations.</p><p>{% include image.html url=&quot;/images/blog/Contract.png&quot; description=&quot;Contract tests focus on interfaces (red arrows) making them perfect supplementary for isolated tests.&quot; %}</p><h3>Pact: A Language-Agnostic Framework for Contract Testing</h3>\n<p><a href=\"https://docs.pact.io\" target=\"_blank\" rel=\"noreferrer\">Pact</a> is a language-agnostic framework for Contract Testing that enables developers to create and test contracts between services in a variety of programming languages, including Java, JavaScript, Ruby, Go, and others.<br>Pact provides a set of libraries and tools to generate contract files, validate them against the provider&#39;s implementation, and report any discrepancies.</p><p>Key features of Pact include:</p><ul>\n<li>Language-agnostic: Pact supports multiple programming languages, making it suitable for teams working with diverse<br>technology stacks.</li>\n<li>Extensive tooling: Pact offers a range of tools for generating, validating, and sharing contracts, streamlining the<br>Contract Testing process.</li>\n<li>Mock services: Pact provides mock services that can be used by consumers to simulate the behavior of providers during<br>testing, ensuring a consistent testing environment.</li>\n</ul>\n<h3>Spring Cloud Contract: Contract Testing for Spring-Based Applications</h3>\n<p><a href=\"https://spring.io/projects/spring-cloud-contract\" target=\"_blank\" rel=\"noreferrer\">Spring Cloud Contract</a> is a framework specifically designed for implementing Contract Testing in Spring-based applications. It provides support for defining contracts using Groovy or YAML and integrates seamlessly with the Spring ecosystem. Spring Cloud Contract offers features such as automatic generation of tests, stubs, and API documentation based on the contracts, making it an attractive choice for developers working with Spring-based microservices.</p><p>Key features of Spring Cloud Contract include:</p><ul>\n<li>Spring integration: Spring Cloud Contract is tailor-made for Spring-based applications, offering seamless integration<br>with the Spring ecosystem.</li>\n<li>Flexible contract definition: Contracts can be defined using Groovy or YAML, providing developers with flexibility in<br>expressing their expectations.</li>\n<li>Automated test generation: Spring Cloud Contract automatically generates tests and stubs based on the defined<br>contracts,<br>simplifying the testing process.</li>\n</ul>\n<p>By incorporating Contract Testing with popular frameworks like Pact or Spring Cloud Contract, development teams can ensure better communication and alignment of expectations between service consumers and providers. This ultimately leads to more reliable software systems with fewer integration issues. In the next sections, we will explore more advanced concepts and techniques related to Contract Testing, helping you to make the most of this powerful approach to integration testing.</p><h2>Consumer Driven Contract Tests</h2>\n<p>Consumer-Driven Contract Tests (CDCT) is an approach to Contract Testing that puts the focus on the expectations of the consumers (clients) while verifying the integration on the provider (server) side. This method ensures that both parties have a clear understanding of the interactions between them, resulting in more reliable and maintainable software systems.</p><p>The CDCT process consists of five distinct phases:</p><p>{% include image.html url=&quot;/images/blog/cdct.png&quot; description=&quot;CDCT visualisation&quot; %}</p><p><strong>1. Contract creation on the Consumer side</strong></p><p>In this phase, consumers create contracts that define their expectations regarding the API they are consuming. This step requires writing custom code in all consumer codebases, which specifies the expected behavior of the provider&#39;s API.</p><pre><code class=\"hljs language-plaintext\">\n    @Override\n    public RequestResponsePact createPact(PactDslWithProvider builder) {\n        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();\n        headers.put(&quot;Content-Type&quot;, MediaType.APPLICATION_JSON_VALUE);\n\n        return builder\n                .given(&quot;Two entries exist&quot;)\n                .uponReceiving(&quot;Two entries exist&quot;)\n                .path(&quot;/information&quot;)\n                .query(&quot;name=&quot; + MESSI)\n                .method(&quot;GET&quot;)\n                .willRespondWith()\n                .headers(headers)\n                .status(200)\n                .body(newJsonBody((root) -&gt; {\n                    root.numberType(&quot;salary&quot;, 7500);\n                    root.stringType(&quot;name&quot;, MESSI);\n                    root.stringType(&quot;nationality&quot;, &quot;Argentina&quot;);\n                }).build())\n                .toPact();\n    }\n\n    @Override\n    protected void runTest(MockServer mockServer, PactTestExecutionContext context) {\n        providerService.overrideBackendUrl(mockServer.getUrl());\n        Information information = providerService.getResponseForName(MESSI).getBody();\n        assertThat(information).isNotNull();\n        assertThat(information.getName()).isEqualTo(MESSI);\n    }\n\n}</code></pre><p><strong>2. Publishing the contract to a third-party application - Pact Broker</strong></p><p>Once the contracts are created, they are published to a third-party application called the Pact Broker. The Pact Broker serves as a centralized repository for storing and managing the contracts between consumers and providers.</p><p><strong>3. Sharing the contract with the Provider</strong></p><p>The contracts are then shared with the provider, ensuring that both parties have access to the agreed-upon expectations and can work towards fulfilling them.</p><p><strong>4. Contract verification on the Provider side</strong></p><p>In this phase, the provider verifies that their implementation meets the expectations outlined in the contract. This step requires writing custom code on the provider side, which validates that the API behaves as expected according to the contract. The contract testing tool utilizes Wiremock to simulate the interactions defined in the contract,<br>allowing the provider to verify the correctness of their implementation.</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@RunWith(SpringRestPactRunner.class)</span>\n<span class=\"hljs-meta\">@Provider(&quot;ExampleProvider&quot;)</span>\n<span class=\"hljs-meta\">@PactBroker(host = &quot;localhost&quot;, port = &quot;9292&quot;, tags = {&quot;master&quot;})</span>\n<span class=\"hljs-meta\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProviderContractTest</span> {\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> InformationService informationService;\n\n    <span class=\"hljs-meta\">@TestTarget</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Target</span> <span class=\"hljs-variable\">target</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SpringBootHttpTarget</span>();\n\n    <span class=\"hljs-meta\">@State(&quot;Empty database state&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">emptyDatabase</span><span class=\"hljs-params\">()</span> {\n        ContractState.EMPTY.setState(informationService);\n    }\n\n    <span class=\"hljs-meta\">@State(&quot;Two entries exist&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">defaultState</span><span class=\"hljs-params\">()</span> {\n        ContractState.DEFAULT.setState(informationService);\n    }\n\n}</code></pre><p><strong>5. Publishing the results back to the Pact Broker and verifying the contract</strong></p><p>Once the verification process is complete, the results are published back to the Pact Broker. This allows both parties to review the results and confirm that the contract has been successfully verified, ensuring seamless integration between the consumer and provider.</p><p>{% include image.html url=&quot;/images/blog/pactbroker.png&quot; description=&quot;Pact Broker showing verified contracts&quot; %}</p><p>You can find more information about CDCT and working example in my repository <a href=\"https://github.com/slawekradzyminski/PactExample\" target=\"_blank\" rel=\"noreferrer\">PactExample</a>.</p><h3>Issues with Consumer-Driven Contract Tests</h3>\n<p>Consumer-Driven Contract Testing (CDCT) is a compelling concept that aims to improve integration testing between components. However, it has not gained mainstream adoption in the testing community. It&#39;s rare to find job descriptions explicitly requiring knowledge of contract testing. Several factors contribute to the limited adoption of CDCT, and it&#39;s important to note that many of these issues have been addressed in BiDirectional Contract Testing, which will be discussed later.</p><p><strong>Immature Tooling</strong></p><p>While the CDCT concept started gaining interest among testers, the initial tooling had multiple bugs and limitations that discouraged early adopters. The lack of mature and reliable tools made it difficult for teams to fully embrace CDCT, slowing its adoption in the industry.</p><p><strong>Extra Code for Contract Testing</strong></p><p>The need to write and maintain additional code for contract testing purposes can be a significant investment, especially when dealing with dozens of services. This extra effort might deter teams from adopting CDCT, as it can be seen as an additional burden on top of their existing development and testing responsibilities.</p><p><strong>Complex State Management</strong></p><p>In CDCT, communication between consumer and provider occurs via contract states. The consumer defines a state, which the provider then needs to handle, mock, or prepare. This can become complex when the provider has to synchronize with multiple consumers, each having numerous states. For example, a provider synchronizing with three consumers with 15 states each would need to handle 45 different scenarios in their codebase. In real-world situations, provider teams often encourage consumers to use the same states, which introduces invisible coupling in consumer codebases, creating additional complexity.</p><p><strong>Complex Tagging and Change Management</strong></p><p>While the &quot;happy flow&quot; in CDCT is straightforward, things can become complicated when changes need to be made to the contract between the consumer and provider. Initially, tags were used to manage these changes, but this approach has been deprecated in favor of using environments. The transition to environments and the complexities that arise during contract modifications have made CDCT more difficult to manage, hindering its widespread adoption.</p><p><strong>Integration with External APIs</strong></p><p>CDCT presents a challenge when attempting to integrate with external APIs owned by third-party companies. This is because CDCT requires cooperation in defining contract states, which may not be possible when dealing with external providers that are outside your organization&#39;s control.</p><p>It is worth noting that the author of this analysis has never openly endorsed CDCT, acknowledging its limitations and the need for improvements to make it more accessible and practical for teams to adopt. While CDCT has potential, its current challenges have limited its impact on the testing landscape, and it remains a niche approach to integration testing. I recommend to take a look into BiDirectional Contract Testing instead.</p><h2>BiDirectional Contract Testing</h2>\n<p>Bidirectional Contract Testing is a relatively new approach to contract testing that aims to address many of the limitations associated with Consumer-Driven Contract Testing (CDCT). It is available only in the paid version of Pactflow (for teams with 5+ users) and has the potential to revolutionize the field of contract testing. By resolving many of the issues associated with CDCT, Bidirectional Contract Testing makes it more accessible and practical for teams to adopt.</p><p>The Bidirectional Contract Testing flow consists of three main phases:</p><p>{% include image.html url=&quot;/images/blog/bidi.png&quot; description=&quot;BiDirectional Contact Testing&quot; %}</p><p><strong>Provider OpenAPI Specification Upload</strong></p><p>The provider must upload their OpenAPI specification to Pactflow. The OpenAPI specification serves as the source of truth for the API, providing a clear and accurate description of the API&#39;s behavior and functionality.</p><p><strong>Consumer Contract Generation and Upload</strong></p><p>The consumer generates a contract based on their existing isolated tests, using an extension library. Multiple extensions are available, supporting popular tools like <a href=\"https://bitbucket.org/atlassian/wiremock-pact-generator/src/master/\" target=\"_blank\" rel=\"noreferrer\">WireMock</a>, <a href=\"https://www.npmjs.com/package/@pactflow/pact-cypress-adapter\" target=\"_blank\" rel=\"noreferrer\">Cypress</a>,<br>and <a href=\"https://github.com/pactflow/example-bi-directional-consumer-playwright-js\" target=\"_blank\" rel=\"noreferrer\">Playwright</a>. Once the contract is generated, it must be uploaded to Pactflow as well. This approach simplifies the contract generation process and reduces the amount of extra code needed for contract testing, making it more appealing to adopt.</p><p>It is worth noting that the tooling for this method may still appear to be immature in some aspects. However, as with any emerging technology, it may take time for the tooling to mature and become more stable. Early adopters of Bidirectional Contract Testing may encounter limitations, bugs, or other issues that can impact the efficiency and effectiveness of their testing efforts. It is essential for teams considering adopting this approach to be aware of these potential challenges and stay informed about updates and improvements to the tools they use.</p><p><strong>Pactflow Contract Validation</strong></p><p>Pactflow performs its &quot;magic&quot; by analyzing the generated consumer contract and the provider&#39;s OpenAPI specification. It then determines whether the mocks defined in the consumer tests meet the provider&#39;s requirements as described in their OpenAPI specification. This automated validation process ensures that the consumer and provider are aligned, promoting effective communication and reducing the risk of integration issues.</p><p>After the contract validation process, both the provider and consumer teams can use the <a href=\"https://docs.pact.io/pact_broker/can_i_deploy\" target=\"_blank\" rel=\"noreferrer\">can i deploy</a> tool available in Pactflow. This tool helps determine whether it is safe to deploy their respective components to production,<br>considering the current state of contracts and their compatibility. This additional step provides teams with confidence in their deployments and further reduces the risk of integration issues in production environments.</p><p>By addressing the challenges of CDCT, Bidirectional Contract Testing offers a more streamlined and manageable approach to contract testing. It eliminates the need for complex state management, simplifies change management, and removes the burden of writing and maintaining extra code for contract testing purposes. Furthermore, it enables integration with external APIs by leveraging the widely-used OpenAPI standard. With these improvements, Bidirectional Contract Testing has the potential to become a game-changer in the world of integration testing, making it a valuable addition to any team&#39;s testing toolkit.</p><h3>Pactflow pricing</h3>\n<p>While the open-source Pact Broker offers an extensive set of features for contract testing, it is important to note that most of the &quot;magic&quot; behind Bidirectional Contract Testing is available exclusively in the paid Pactflow version.</p><p>Pactflow builds on the capabilities of the free Pact Broker, providing additional features, support, and enhancements that are tailored to the needs of professional teams. One of these key enhancements is the support for Bidirectional Contract Testing.</p><p>The pricing for Pactflow can be found on their official <a href=\"https://pactflow.io/pricing/\" target=\"_blank\" rel=\"noreferrer\">pricing page</a>.</p><h2>Demo: BiDirectional Contract Testing in Action</h2>\n<p>In this demo, we will use the following components:</p><ul>\n<li><a href=\"https://www.bezkoder.com/spring-boot-swagger-3/\" target=\"_blank\" rel=\"noreferrer\">bezkoder Spring Boot 3 + OpenAPI example project</a></li>\n<li>My custom client available on <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer\" target=\"_blank\" rel=\"noreferrer\">GitHub</a></li>\n<li>My free-tier instance of <a href=\"https://awesome-testing.pactflow.io\" target=\"_blank\" rel=\"noreferrer\">Pactflow</a></li>\n</ul>\n<h3>Provider</h3>\n<p>As mentioned earlier, it is impossible to integrate with External APIs using the CDCT approach. With BiDirectional Contract Testing, this becomes possible, as long as the external API we want to integrate with publishes its OpenAPI specification. For this demo, we have chosen an example project found on GitHub: <a href=\"https://www.bezkoder.com/spring-boot-swagger-3/\" target=\"_blank\" rel=\"noreferrer\">https://www.bezkoder.com/spring-boot-swagger-3/</a></p><p>After running the project via <code>./mvnw spring-boot:run</code>, we can access the OpenAPI specification at <a href=\"http://localhost:8080/bezkoder-api-docs\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8080/bezkoder-api-docs</a></p><p>To make the demo easier to follow, the <code>openapi.json</code> has been uploaded to the consumer repository: <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/incompatibleopenapi.json\" target=\"_blank\" rel=\"noreferrer\">incompatible OpenAPI</a></p><p>Please note that there is a bug in the schema (single Tutorial instead of an array of Tutorials) for the <code>/api/tutorials</code><br>GET endpoint, which has been fixed by me. The correct specification can be found here: <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/openapi.json\" target=\"_blank\" rel=\"noreferrer\">openapi.json</a>.<br>Details about the bug are available in <a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer/blob/master/README.md\" target=\"_blank\" rel=\"noreferrer\">README.md</a>.<br>Perhaps Pactflow wisely recommends to test OpenAPI specification via <a href=\"https://docs.pactflow.io/docs/workshops/bi-directional/step3\" target=\"_blank\" rel=\"noreferrer\">additional unit tests</a>.</p><p>This demonstrates that BiDirectional Contract Tests have the power to identify bugs and help ensure the accuracy of API contracts.</p><p>Provider contract can be uploaded using the <a href=\"https://docs.pactflow.io/docs/bi-directional-contract-testing/contracts/oas#publishing\" target=\"_blank\" rel=\"noreferrer\">publish-provider-contract</a><br>Pact CLI command. Pactflow assumes that the Provider OpenAPI specification has been unit tested hence the requirement to provide verification result file.</p><pre><code class=\"hljs language-plaintext\">--broker-token=TOKEN \\\n--broker-base-url=https://awesome-testing.pactflow.io \\\n--content-type application/json \\\n--provider the-provider \\\n--provider-app-version 0.0.4-SNAPSHOT \\\n--verification-results-content-type text/plain \\\n--verification-results ./result.txt \\\n--verification-success \\\n--verifier self-verification \\\n--verbose</code></pre><h3>Consumer</h3>\n<p>The consumer has been entirely created by me, and the code is available here:<br><a href=\"https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer\" target=\"_blank\" rel=\"noreferrer\">https://github.com/slawekradzyminski/bidirectional-contract-testing-consumer</a></p><p>I integrate with Bezkoder&#39;s Provider using a dummy /all endpoint, which essentially acts as a proxy:</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@RestController</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiController</span> {\n<span class=\"hljs-meta\">@Autowired</span> TutorialClient tutorialClient;\n\n    <span class=\"hljs-meta\">@GetMapping(&quot;/all&quot;)</span>\n    <span class=\"hljs-keyword\">public</span> List&lt;TutorialDto&gt; <span class=\"hljs-title function_\">getAll</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> tutorialClient.getAll();\n    }\n}</code></pre><p>In order to test this endpoint, I have to use Wiremock to stub Bezkoder&#39;s API:</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldGeneratePactInTargetPactsFolder</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    wiremock.stubFor(WireMock.get(urlEqualTo(<span class=\"hljs-string\">&quot;/api/tutorials&quot;</span>)).willReturn(aResponse()\n            .withHeader(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;application/json&quot;</span>).withBody(<span class=\"hljs-string\">&quot;&quot;&quot;\n                    [\n                      {\n                        &quot;id&quot;: 1,\n                        &quot;title&quot;: &quot;ChatGPT&quot;,\n                        &quot;description&quot;: &quot;blablabla&quot;,\n                        &quot;published&quot;: true\n                      }\n                    ]\n                    &quot;&quot;&quot;</span>)));\n\n    <span class=\"hljs-built_in\">this</span>.mockMvc.perform(get(<span class=\"hljs-string\">&quot;/all&quot;</span>)).andDo(print()).andExpect(status().isOk())\n            .andExpect(jsonPath(<span class=\"hljs-string\">&quot;$[0].id&quot;</span>, is(<span class=\"hljs-number\">1</span>)))\n            .andExpect(jsonPath(<span class=\"hljs-string\">&quot;$[0].title&quot;</span>, is(<span class=\"hljs-string\">&quot;ChatGPT&quot;</span>)))\n            .andExpect(jsonPath(<span class=\"hljs-string\">&quot;$[0].description&quot;</span>, is(<span class=\"hljs-string\">&quot;blablabla&quot;</span>)))\n            .andExpect(jsonPath(<span class=\"hljs-string\">&quot;$[0].published&quot;</span>, is(<span class=\"hljs-literal\">true</span>)));\n}</code></pre><p>I assume that your consumers already have similar code (you may mock the HTTP layer using Cypress or Playwright,<br>but the flow is the same).</p><p>Now we only need to add the custom Wiremock Pact creator dependency:</p><pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.atlassian.ta<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>wiremock-pact-generator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre><p>And configure a listener for the Wiremock Server:</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@BeforeAll</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setupClass</span><span class=\"hljs-params\">()</span> {\n    wiremock.addMockServiceRequestListener(\n            WireMockPactGenerator\n                    .builder(<span class=\"hljs-string\">&quot;the-consumer&quot;</span>, <span class=\"hljs-string\">&quot;the-provider&quot;</span>)\n                    .build()\n    );\n    wiremock.start();\n}</code></pre><p>At this point, after running the tests, the consumer contract file is created in the <code>target/pacts</code> folder.<br>I upload it to Pactflow using the <code>pact-jvm-provider-maven</code> library via the <code>./mvnw pact:publish</code> command.</p><h3>Pactflow</h3>\n<p>At this point, the &quot;magic&quot; happens, and the work related to verifying compatibility takes place on the Pactflow side.<br>Pactflow compares the uploaded provider contract and consumer contract to determine if the API interactions are compatible. This process significantly simplifies the work for development teams and ensures that any potential integration issues are identified before deploying to production.</p><p>Now we can see <code>Success</code> message with correct <code>openapi.json</code></p><p><img src=\"/images/blog/pactflowsuccess.png\" alt=\"\"></p><p>And <code>Failed</code> message with incorrect <code>incompatibleopenapi.json</code></p><p><img src=\"/images/blog/pactflowfailure.png\" alt=\"\"></p><p>This demonstrates the power of BiDirectional Contract Testing in catching inconsistencies and ensuring that both the consumer and provider are aligned.</p><h2>Summary</h2>\n<p>In this blog post, we explored the concept of BiDirectional Contract Testing and how it can revolutionize contract testing by addressing many of the issues associated with Consumer-Driven Contract Testing (CDCT). We went through the three main phases of the bidirectional contract testing flow and discussed the benefits and limitations of using the paid Pactflow version for BiDirectional Contract Testing. We also provided a hands-on demo using a custom client, the bezkoder Spring Boot 3 + OpenAPI example project, and a free-tier instance of Pactflow.</p><p>It is fascinating to see whether contract testing will finally reach mainstream adoption, given the advancements and improvements offered by BiDirectional Contract Testing. It is a powerful approach that can help development teams ensure the accuracy of their API contracts and significantly reduce the risks associated with integrating external APIs.</p><p>We would love to hear your thoughts on BiDirectional Contract Testing. Have you tried it in your projects? How has it improved your development and testing processes? Do you think this approach will finally bring contract testing into the mainstream? Please share your experiences, opinions, and insights in the comments section below. Let&#39;s foster an engaging discussion on the future of contract testing!</p>"
}