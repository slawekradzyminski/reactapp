{
  "id": "2018-05-16-selenium-vs-fluentlenium",
  "title": "Selenium vs FluentLenium",
  "date": "2018-05-16",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium",
    "fluentlenium"
  ],
  "permalink": "/2018/05/selenium-vs-fluentlenium",
  "content": "<p><img src=\"/images/blog/fluentlenium.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>All my previous posts labeled with <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">Selenium tag</a><br>featured <a href=\"http://fluentlenium.org/\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> syntax. Why? Even though I tried to answer it in FluentLenium focused<br>posts (<a href=\"https://www.awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">Introduction</a> &amp; <a href=\"https://www.awesome-testing.com/2016/04/introducing-fluentlenium-2-selenium.html\" target=\"_blank\" rel=\"noreferrer\">Waiting game</a>)<br>I never really did full comparison against Selenium. As you probably already figured out reading the title this post<br>will show how FluentLenium can help you write better, shorter and easier to maintain Selenium tests.</p>\n<p>Just to be clear that we are on the same page: <strong>FluentLenium is only Selenium extension, not alternative</strong>. It&#39;s<br>important to keep in mind that it&#39;s still GUI automation with all it&#39;s flaws and difficulties. FluentLenium was designed<br>to mitigate these problems as shall be shown here.</p>\n<p>Warning: this post is code rich.</p>\n<h2>Selenium</h2>\n<p>I&#39;m going to start with pure Selenium first. Let&#39;s say we want to automate the following scenario:</p>\n<p>a) Search for &#39;public speaking&#39; term on my blog. Make sure the search results page contains some posts.</p>\n<p>b) Open first post and verify that it contains comment section.</p>\n<p>I chose to verify comment section, because it&#39;s loaded dynamically by Blogger. As you shall see pure Selenium struggles<br>a bit with such elements and fancy waiting is required for test stability.</p>\n<p>Our obvious first step is adding Selenium dependency into pom.xml. I&#39;m using 3.9.1 version here:</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-chrome-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n         &lt;/dependency&gt;\n</code></pre>\n<p>We need some properties next. I&#39;m writing those words on Windows so I have to define driver paths. Let&#39;s implement the<br>simplest possible class that handles it:</p>\n<pre><code class=\"language-java\">public class MyProperties {\n\n    private Properties properties;\n\n    public MyProperties() {\n        properties = loadProperties();\n    }\n\n    private static Properties loadProperties() {\n        Properties properties = new Properties();\n        try {\n            properties.load(MyProperties.class.getResourceAsStream(&quot;/user.properties&quot;));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return properties;\n    }\n\n    public String getProperty(String property) {\n        return properties.getProperty(property);\n    }\n}\n</code></pre>\n<p>And next we need user.properties file in test resources folder:</p>\n<pre><code class=\"language-properties\">my_chrome_path=C:\\\\drivers\\\\chromedriver.exe\nmy_gecko_path=C:\\\\drivers\\\\geckodriver.exe\n</code></pre>\n<p>So far so good. We are ready to start defining tests. Let&#39;s create a top level test class responsible for driver<br>handling first. It will be our baseline. Normally I don&#39;t include imports in my snippets, but this Apache Commons entry<br>is necessary for easy understanding of if in setUp() section. I have Mac with chrome driver system property already set<br>by Brew and this line ensures that it will work on it without any changes. I&#39;m using JUnit btw.</p>\n<pre><code class=\"language-java\">import static org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS;\n\npublic class SeleniumTest {\n\n    protected static WebDriver driver;\n    private MyProperties myProperties = new MyProperties();\n\n    @Before\n    public void setUp() {\n        if (IS_OS_WINDOWS) {\n            System.setProperty(&quot;webdriver.chrome.driver&quot;,\n                               myProperties.getProperty(&quot;my_chrome_path&quot;));\n        }\n        driver = new ChromeDriver();\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n}\n</code></pre>\n<p>Now we need baseline for page objects. I don&#39;t want to load elements from @FindBy annotation every single time, so I&#39;m<br>coding it on top level class.</p>\n<pre><code class=\"language-java\">public class PageObject {\n    protected WebDriver driver;\n\n    public PageObject(WebDriver driver){\n        this.driver = driver;\n        PageFactory.initElements(driver, this);\n    }\n}\n</code></pre>\n<p>Framework is ready so we can implement our page objects. Main blog page is obvious place to begin. I&#39;m adding two<br>methods, one to make sure we are indeed on correct page and the second one to use search functionality.</p>\n<pre><code class=\"language-java\">public class MainPage extends PageObject {\n\n    @FindBy(css = &quot;input.gsc-input&quot;)\n    private WebElement searchBar;\n\n    @FindBy(css = &quot;input.gsc-search-button&quot;)\n    private WebElement searchButton;\n\n    @FindBy(css = &quot;h1&quot;)\n    private WebElement post;\n\n    public MainPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(post.isDisplayed()).isTrue();\n    }\n\n    public SearchResultsPage searchFor(String searchTerm) {\n        this.searchBar.clear();\n        this.searchBar.sendKeys(searchTerm);\n        this.searchButton.click();\n        return new SearchResultsPage(driver);\n    }\n\n}\n</code></pre>\n<p>Next in flow is search results page. This time I&#39;m adding two assertions (are we on correct page? are posts displayed?)<br>and method which clicks on first post title.</p>\n<pre><code class=\"language-java\">public class SearchResultsPage extends PageObject {\n\n    @FindBy(className = &quot;status-msg-wrap&quot;)\n    private WebElement searchOptionPanel;\n\n    public SearchResultsPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(searchOptionPanel.isDisplayed()).isTrue();\n    }\n\n    public void assertThatPostsAreDisplayed() {\n        List&lt;WebElement&gt; postsTitles = driver.findElements(By.cssSelector(&quot;h1 a&quot;));\n        assertThat(postsTitles).size().isPositive();\n    }\n\n    public PostPage clickOnFirstPost() {\n        List&lt;WebElement&gt; posts = driver.findElements(By.cssSelector(&quot;h1 a&quot;));\n        posts.get(0).click();\n\n        return new PostPage(driver);\n    }\n\n}\n</code></pre>\n<p>And finally we are on post page. Comment section is not only in an iframe, but it also loads dynamically. In order to<br>handle it I had to implement fancy wait, which polls every 500 milliseconds maximum 10 times. Element is not there at<br>first, but we ignore NoSuchElementException and poll again.</p>\n<pre><code class=\"language-java\">public class PostPage extends PageObject {\n\n    @FindBy(id = &quot;comment-editor&quot;)\n    private WebElement commentsSection;\n\n    public PostPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(commentsSection.isDisplayed()).isTrue();\n    }\n\n    public void checkCommentsSectionPresence() {\n        driver.switchTo().frame(commentsSection);\n        wait.until(ExpectedConditions.presenceOfElementLocated(By.name(&quot;commentBody&quot;)));\n    }\n\n    private Wait&lt;WebDriver&gt; wait = new FluentWait&lt;&gt;(driver)\n            .withTimeout(5, TimeUnit.SECONDS)\n            .pollingEvery(500, TimeUnit.MILLISECONDS)\n            .ignoring(NoSuchElementException.class)\n            .withMessage(&quot;Oops, element didn&#39;t appear!&quot;);\n\n}\n</code></pre>\n<p>Having all pieces implemented we can write a pure Selenium test.</p>\n<pre><code class=\"language-java\">public class SearchTest extends SeleniumTest {\n\n    private static final String BLOG = &quot;https://www.awesome-testing.com&quot;;\n\n    @Test\n    public void shouldSuccessfullyFindPostAndDisplayCommentSection() {\n        driver.get(BLOG);\n        MainPage mainPage = new MainPage(driver);\n        mainPage.isInitialized();\n\n        SearchResultsPage searchResultsPage =  mainPage.searchFor(&quot;public speaking&quot;);\n        searchResultsPage.isInitialized();\n        searchResultsPage.assertThatPostsAreDisplayed();\n\n        PostPage postPage = searchResultsPage.clickOnFirstPost();\n        postPage.isInitialized();\n        postPage.checkCommentsSectionPresence();\n    }\n}\n</code></pre>\n<h2>FluentLenium</h2>\n<p>Now we will write the same test using FluentLenium. Spoiler alert: it will be easier :)</p>\n<p>As usual, we start with dependencies in pom.xml.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-core&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-assertj&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-junit&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Driver handling is already taken care of by FluentLenium (FluentTest class). I want my tests to work both on Windows and<br>Mac, so I&#39;m adding a little extension. FluentLenium also allows to store driver names in human friendly way so I have<br>added driver=chrome property. MyProperties class can be found above.</p>\n<pre><code class=\"language-java\">import static org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS;\n\npublic class FluentLeniumTest extends FluentTest {\n\n    protected static WebDriver driver;\n    private static MyProperties myProperties = new MyProperties();\n\n    @BeforeClass\n    public static void setUp() {\n        if (IS_OS_WINDOWS) {\n            System.setProperty(&quot;webdriver.chrome.driver&quot;,\n                               myProperties.getProperty(&quot;my_chrome_path&quot;));\n        }\n    }\n\n    @Override\n    public String getWebDriver() {\n        return myProperties.getProperty(&quot;driver&quot;);\n    }\n}\n</code></pre>\n<p>In Selenium section I have implemented PageObject class for framework preparations. It isn&#39;t required in FluentLenium.<br>It&#39;s already handled by FluentPage class.</p>\n<p>We can proceed to Page Object definition now. Let&#39;s start with Main Page. @PageUrl annotation is used to tell driver<br>where to go. newInstance() method creates new page object class and isAt() is used for &#39;am I on correct page?&#39;<br>verification.</p>\n<pre><code class=\"language-java\">@PageUrl(&quot;https://www.awesome-testing.com&quot;)\npublic class MainPage extends FluentPage {\n\n    @FindBy(css = &quot;input.gsc-input&quot;)\n    private FluentWebElement searchBar;\n\n    @FindBy(css = &quot;input.gsc-search-button&quot;)\n    private FluentWebElement searchButton;\n\n    @FindBy(css = &quot;h1&quot;)\n    private FluentList&lt;FluentWebElement&gt; posts;\n\n    @Override\n    public void isAt() {\n        assertThat(posts).hasSize().greaterThan(0);\n    }\n\n    public SearchResultsPage searchFor(String searchTerm) {\n        searchBar.fill().with(searchTerm);\n        searchButton.click();\n        return newInstance(SearchResultsPage.class);\n    }\n}\n</code></pre>\n<p>Now search result page with similar methods. Please take a look into @FindBy support for lists. Such feature isn&#39;t<br>implemented in pure Selenium. It really helps to write easy to maintain code.</p>\n<pre><code class=\"language-java\">public class SearchResultsPage extends FluentPage {\n\n    @FindBy(className = &quot;status-msg-wrap&quot;)\n    private FluentWebElement searchOptionPanel;\n\n    @FindBy(css = &quot;h1 a&quot;)\n    private FluentList&lt;FluentWebElement&gt; posts;\n\n    @Override\n    public void isAt() {\n        assertThat(searchOptionPanel).isDisplayed();\n    }\n\n    public void assertThatPostsAreDisplayed() {\n        assertThat(posts).hasSize().greaterThan(0);\n    }\n\n    public PostPage clickOnFirstPost() {\n        posts.first().click();\n        return newInstance(PostPage.class);\n    }\n}\n</code></pre>\n<p>Finally, post page. You can see how useful await() methods are. Instead of defining separate Wait object we can use<br>intuitive syntax. Also NoSuchElementExceptions are ignored by default. We have also very handy switchTo() method which<br>changes context into iframe.</p>\n<pre><code class=\"language-java\">public class PostPage extends FluentPage {\n\n    @FindBy(id = &quot;comment-editor&quot;)\n    private FluentWebElement commentsSection;\n\n    @FindBy(name = &quot;commentBody&quot;)\n    private FluentWebElement commentBody;\n\n    public void isAt() {\n        assertThat(commentsSection).isDisplayed();\n    }\n\n    public void checkCommentsSectionPresence() {\n        switchTo(commentsSection);\n        await().atMost(5, TimeUnit.SECONDS).until(commentBody).displayed();\n    }\n}\n</code></pre>\n<p>Having all pieces ready let&#39;s take a look at our final creation - a FluentLenium test. @Page is pseudo injection - it<br>allow us to predefine pages used in test.</p>\n<pre><code class=\"language-java\">public class SearchTest extends FluentLeniumTest {\n\n    @Page\n    private MainPage mainPage;\n\n    @Page\n    private SearchResultsPage searchResultsPage;\n\n    @Page\n    private PostPage postPage;\n\n    @Test\n    public void shouldSuccessfullySearchForPosts() {\n        mainPage.go();\n        mainPage.isAt();\n        mainPage.searchFor(&quot;public speaking&quot;);\n\n        searchResultsPage.isAt();\n        searchResultsPage.assertThatPostsAreDisplayed();\n        searchResultsPage.clickOnFirstPost();\n\n        postPage.isAt();\n        postPage.checkCommentsSectionPresence();\n    }\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>I&#39;m engineer, and I&#39;m not a fan of arguments about which approach is better. I can only suggest you try FluentLenium and<br>see how it works for you. Personally I&#39;m a huge fan and I hope this post highlighted its features. Doesn&#39;t it?</p>\n<p>As usual all code can be downloaded from by <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub page</a>.</p>\n"
}