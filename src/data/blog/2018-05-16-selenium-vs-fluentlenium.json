{
  "id": "2018-05-16-selenium-vs-fluentlenium",
  "title": "Selenium vs FluentLenium",
  "date": "2018-05-16",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium",
    "fluentlenium"
  ],
  "permalink": "/2018/05/selenium-vs-fluentlenium",
  "content": "<img src=\"/images/blog/fluentlenium.png\" alt=\"\">\n\n<p>All my previous posts labeled with <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">Selenium tag</a><br>featured <a href=\"http://fluentlenium.org/\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> syntax. Why? Even though I tried to answer it in FluentLenium focused posts (<a href=\"https://www.awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">Introduction</a> &amp; <a href=\"https://www.awesome-testing.com/2016/04/introducing-fluentlenium-2-selenium.html\" target=\"_blank\" rel=\"noreferrer\">Waiting game</a>)<br>I never really did full comparison against Selenium. As you probably already figured out reading the title this post will show how FluentLenium can help you write better, shorter and easier to maintain Selenium tests.</p><p>Just to be clear that we are on the same page: <strong>FluentLenium is only Selenium extension, not alternative</strong>. It&#39;s important to keep in mind that it&#39;s still GUI automation with all it&#39;s flaws and difficulties. FluentLenium was designed to mitigate these problems as shall be shown here.</p><p>Warning: this post is code rich.</p><h2>Selenium</h2>\n<p>I&#39;m going to start with pure Selenium first. Let&#39;s say we want to automate the following scenario:</p><p>a) Search for &#39;public speaking&#39; term on my blog. Make sure the search results page contains some posts.</p><p>b) Open first post and verify that it contains comment section.</p><p>I chose to verify comment section, because it&#39;s loaded dynamically by Blogger. As you shall see pure Selenium struggles a bit with such elements and fancy waiting is required for test stability.</p><p>Our obvious first step is adding Selenium dependency into pom.xml. I&#39;m using 3.9.1 version here:</p><pre><code class=\"hljs language-plaintext\">\n         &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-chrome-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;\n            &lt;version&gt;3.9.1&lt;/version&gt;\n         &lt;/dependency&gt;\n</code></pre><p>We need some properties next. I&#39;m writing those words on Windows so I have to define driver paths. Let&#39;s implement the simplest possible class that handles it:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyProperties</span> {\n\n    <span class=\"hljs-keyword\">private</span> Properties properties;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">MyProperties</span><span class=\"hljs-params\">()</span> {\n        properties = loadProperties();\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Properties <span class=\"hljs-title function_\">loadProperties</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">Properties</span> <span class=\"hljs-variable\">properties</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Properties</span>();\n        <span class=\"hljs-keyword\">try</span> {\n            properties.load(MyProperties.class.getResourceAsStream(<span class=\"hljs-string\">&quot;/user.properties&quot;</span>));\n        } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);\n        }\n        <span class=\"hljs-keyword\">return</span> properties;\n    }\n\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getProperty</span><span class=\"hljs-params\">(String property)</span> {\n        <span class=\"hljs-keyword\">return</span> properties.getProperty(property);\n    }\n}\n</code></pre><p>And next we need user.properties file in test resources folder:</p><pre><code class=\"hljs language-plaintext\">\nmy_chrome_path=C:\\\\drivers\\\\chromedriver.exe my_gecko_path=C:\\\\drivers\\\\geckodriver.exe\n</code></pre><p>So far so good. We are ready to start defining tests. Let&#39;s create a top level test class responsible for driver handling first. It will be our baseline. Normally I don&#39;t include imports in my snippets, but this Apache Commons entry is necessary for easy understanding of if in setUp() section. I have Mac with chrome driver system property already set by Brew and this line ensures that it will work on it without any changes. I&#39;m using JUnit btw.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeleniumTest</span> {\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> WebDriver driver;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">MyProperties</span> <span class=\"hljs-variable\">myProperties</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyProperties</span>();\n\n    <span class=\"hljs-meta\">@Before</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUp</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (IS_OS_WINDOWS) {\n            System.setProperty(<span class=\"hljs-string\">&quot;webdriver.chrome.driver&quot;</span>,\n                               myProperties.getProperty(<span class=\"hljs-string\">&quot;my_chrome_path&quot;</span>));\n        }\n        driver = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChromeDriver</span>();\n    }\n\n    <span class=\"hljs-meta\">@After</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">tearDown</span><span class=\"hljs-params\">()</span> {\n        driver.close();\n    }\n}\n</code></pre><p>Now we need baseline for page objects. I don&#39;t want to load elements from @FindBy annotation every single time, so I&#39;m coding it on top level class.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PageObject</span> {\n    <span class=\"hljs-keyword\">protected</span> WebDriver driver;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">PageObject</span><span class=\"hljs-params\">(WebDriver driver)</span>{\n        <span class=\"hljs-built_in\">this</span>.driver = driver;\n        PageFactory.initElements(driver, <span class=\"hljs-built_in\">this</span>);\n    }\n}\n</code></pre><p>Framework is ready so we can implement our page objects. Main blog page is obvious place to begin. I&#39;m adding two methods, one to make sure we are indeed on correct page and the second one to use search functionality.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">PageObject</span> {\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-input&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> WebElement searchBar;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-search-button&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> WebElement searchButton;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;h1&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> WebElement post;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">MainPage</span><span class=\"hljs-params\">(WebDriver driver)</span> {\n        <span class=\"hljs-built_in\">super</span>(driver);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isInitialized</span><span class=\"hljs-params\">()</span> {\n        assertThat(post.isDisplayed()).isTrue();\n    }\n\n    <span class=\"hljs-keyword\">public</span> SearchResultsPage <span class=\"hljs-title function_\">searchFor</span><span class=\"hljs-params\">(String searchTerm)</span> {\n        <span class=\"hljs-built_in\">this</span>.searchBar.clear();\n        <span class=\"hljs-built_in\">this</span>.searchBar.sendKeys(searchTerm);\n        <span class=\"hljs-built_in\">this</span>.searchButton.click();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SearchResultsPage</span>(driver);\n    }\n\n}\n</code></pre><p>Next in flow is search results page. This time I&#39;m adding two assertions (are we on correct page? are posts displayed?)<br>and method which clicks on first post title.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchResultsPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">PageObject</span> {\n\n    <span class=\"hljs-meta\">@FindBy(className = &quot;status-msg-wrap&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> WebElement searchOptionPanel;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">SearchResultsPage</span><span class=\"hljs-params\">(WebDriver driver)</span> {\n        <span class=\"hljs-built_in\">super</span>(driver);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isInitialized</span><span class=\"hljs-params\">()</span> {\n        assertThat(searchOptionPanel.isDisplayed()).isTrue();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">assertThatPostsAreDisplayed</span><span class=\"hljs-params\">()</span> {\n        List&lt;WebElement&gt; postsTitles = driver.findElements(By.cssSelector(<span class=\"hljs-string\">&quot;h1 a&quot;</span>));\n        assertThat(postsTitles).size().isPositive();\n    }\n\n    <span class=\"hljs-keyword\">public</span> PostPage <span class=\"hljs-title function_\">clickOnFirstPost</span><span class=\"hljs-params\">()</span> {\n        List&lt;WebElement&gt; posts = driver.findElements(By.cssSelector(<span class=\"hljs-string\">&quot;h1 a&quot;</span>));\n        posts.get(<span class=\"hljs-number\">0</span>).click();\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PostPage</span>(driver);\n    }\n\n}\n</code></pre><p>And finally we are on post page. Comment section is not only in an iframe, but it also loads dynamically. In order to handle it I had to implement fancy wait, which polls every 500 milliseconds maximum 10 times. Element is not there at first, but we ignore NoSuchElementException and poll again.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">PageObject</span> {\n\n    <span class=\"hljs-meta\">@FindBy(id = &quot;comment-editor&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> WebElement commentsSection;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">PostPage</span><span class=\"hljs-params\">(WebDriver driver)</span> {\n        <span class=\"hljs-built_in\">super</span>(driver);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isInitialized</span><span class=\"hljs-params\">()</span> {\n        assertThat(commentsSection.isDisplayed()).isTrue();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">checkCommentsSectionPresence</span><span class=\"hljs-params\">()</span> {\n        driver.switchTo().frame(commentsSection);\n        wait.until(ExpectedConditions.presenceOfElementLocated(By.name(<span class=\"hljs-string\">&quot;commentBody&quot;</span>)));\n    }\n\n    <span class=\"hljs-keyword\">private</span> Wait&lt;WebDriver&gt; wait = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FluentWait</span>&lt;&gt;(driver)\n            .withTimeout(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS)\n            .pollingEvery(<span class=\"hljs-number\">500</span>, TimeUnit.MILLISECONDS)\n            .ignoring(NoSuchElementException.class)\n            .withMessage(<span class=\"hljs-string\">&quot;Oops, element didn&#x27;t appear!&quot;</span>);\n\n}\n</code></pre><p>Having all pieces implemented we can write a pure Selenium test.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchTest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">SeleniumTest</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">BLOG</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://www.awesome-testing.com&quot;</span>;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldSuccessfullyFindPostAndDisplayCommentSection</span><span class=\"hljs-params\">()</span> {\n        driver.get(BLOG);\n        <span class=\"hljs-type\">MainPage</span> <span class=\"hljs-variable\">mainPage</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MainPage</span>(driver);\n        mainPage.isInitialized();\n\n        <span class=\"hljs-type\">SearchResultsPage</span> <span class=\"hljs-variable\">searchResultsPage</span> <span class=\"hljs-operator\">=</span>  mainPage.searchFor(<span class=\"hljs-string\">&quot;public speaking&quot;</span>);\n        searchResultsPage.isInitialized();\n        searchResultsPage.assertThatPostsAreDisplayed();\n\n        <span class=\"hljs-type\">PostPage</span> <span class=\"hljs-variable\">postPage</span> <span class=\"hljs-operator\">=</span> searchResultsPage.clickOnFirstPost();\n        postPage.isInitialized();\n        postPage.checkCommentsSectionPresence();\n    }\n}\n</code></pre><h2>FluentLenium</h2>\n<p>Now we will write the same test using FluentLenium. Spoiler alert: it will be easier :)</p><p>As usual, we start with dependencies in pom.xml.</p><pre><code class=\"hljs language-plaintext\">\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-core&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-assertj&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;\n            &lt;artifactId&gt;fluentlenium-junit&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre><p>Driver handling is already taken care of by FluentLenium (FluentTest class). I want my tests to work both on Windows and Mac, so I&#39;m adding a little extension. FluentLenium also allows to store driver names in human friendly way so I have added driver=chrome property. MyProperties class can be found above.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FluentLeniumTest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentTest</span> {\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> WebDriver driver;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">MyProperties</span> <span class=\"hljs-variable\">myProperties</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MyProperties</span>();\n\n    <span class=\"hljs-meta\">@BeforeClass</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUp</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (IS_OS_WINDOWS) {\n            System.setProperty(<span class=\"hljs-string\">&quot;webdriver.chrome.driver&quot;</span>,\n                               myProperties.getProperty(<span class=\"hljs-string\">&quot;my_chrome_path&quot;</span>));\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getWebDriver</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> myProperties.getProperty(<span class=\"hljs-string\">&quot;driver&quot;</span>);\n    }\n}\n</code></pre><p>In Selenium section I have implemented PageObject class for framework preparations. It isn&#39;t required in FluentLenium.<br>It&#39;s already handled by FluentPage class.</p><p>We can proceed to Page Object definition now. Let&#39;s start with Main Page. @PageUrl annotation is used to tell driver where to go. newInstance() method creates new page object class and isAt() is used for &#39;am I on correct page?&#39;<br>verification.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@PageUrl(&quot;https://www.awesome-testing.com&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentPage</span> {\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-input&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement searchBar;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-search-button&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement searchButton;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;h1&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentList&lt;FluentWebElement&gt; posts;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isAt</span><span class=\"hljs-params\">()</span> {\n        assertThat(posts).hasSize().greaterThan(<span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> SearchResultsPage <span class=\"hljs-title function_\">searchFor</span><span class=\"hljs-params\">(String searchTerm)</span> {\n        searchBar.fill().with(searchTerm);\n        searchButton.click();\n        <span class=\"hljs-keyword\">return</span> newInstance(SearchResultsPage.class);\n    }\n}\n</code></pre><p>Now search result page with similar methods. Please take a look into @FindBy support for lists. Such feature isn&#39;t implemented in pure Selenium. It really helps to write easy to maintain code.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchResultsPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentPage</span> {\n\n    <span class=\"hljs-meta\">@FindBy(className = &quot;status-msg-wrap&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement searchOptionPanel;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;h1 a&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentList&lt;FluentWebElement&gt; posts;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isAt</span><span class=\"hljs-params\">()</span> {\n        assertThat(searchOptionPanel).isDisplayed();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">assertThatPostsAreDisplayed</span><span class=\"hljs-params\">()</span> {\n        assertThat(posts).hasSize().greaterThan(<span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> PostPage <span class=\"hljs-title function_\">clickOnFirstPost</span><span class=\"hljs-params\">()</span> {\n        posts.first().click();\n        <span class=\"hljs-keyword\">return</span> newInstance(PostPage.class);\n    }\n}\n</code></pre><p>Finally, post page. You can see how useful await() methods are. Instead of defining separate Wait object we can use intuitive syntax. Also NoSuchElementExceptions are ignored by default. We have also very handy switchTo() method which changes context into iframe.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentPage</span> {\n\n    <span class=\"hljs-meta\">@FindBy(id = &quot;comment-editor&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement commentsSection;\n\n    <span class=\"hljs-meta\">@FindBy(name = &quot;commentBody&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement commentBody;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isAt</span><span class=\"hljs-params\">()</span> {\n        assertThat(commentsSection).isDisplayed();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">checkCommentsSectionPresence</span><span class=\"hljs-params\">()</span> {\n        switchTo(commentsSection);\n        await().atMost(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS).until(commentBody).displayed();\n    }\n}\n</code></pre><p>Having all pieces ready let&#39;s take a look at our final creation - a FluentLenium test. @Page is pseudo injection - it allow us to predefine pages used in test.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchTest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentLeniumTest</span> {\n\n    <span class=\"hljs-meta\">@Page</span>\n    <span class=\"hljs-keyword\">private</span> MainPage mainPage;\n\n    <span class=\"hljs-meta\">@Page</span>\n    <span class=\"hljs-keyword\">private</span> SearchResultsPage searchResultsPage;\n\n    <span class=\"hljs-meta\">@Page</span>\n    <span class=\"hljs-keyword\">private</span> PostPage postPage;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldSuccessfullySearchForPosts</span><span class=\"hljs-params\">()</span> {\n        mainPage.go();\n        mainPage.isAt();\n        mainPage.searchFor(<span class=\"hljs-string\">&quot;public speaking&quot;</span>);\n\n        searchResultsPage.isAt();\n        searchResultsPage.assertThatPostsAreDisplayed();\n        searchResultsPage.clickOnFirstPost();\n\n        postPage.isAt();\n        postPage.checkCommentsSectionPresence();\n    }\n}\n</code></pre><h2>Conclusion</h2>\n<p>I&#39;m engineer, and I&#39;m not a fan of arguments about which approach is better. I can only suggest you try FluentLenium and see how it works for you. Personally I&#39;m a huge fan and I hope this post highlighted its features. Doesn&#39;t it?</p><p>As usual all code can be downloaded from by <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub page</a>.</p>"
}