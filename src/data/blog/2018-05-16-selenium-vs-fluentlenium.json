{
  "id": "2018-05-16-selenium-vs-fluentlenium",
  "title": "Selenium vs FluentLenium",
  "date": "2018-05-16",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium",
    "fluentlenium"
  ],
  "permalink": "/2018/05/selenium-vs-fluentlenium",
  "content": "<p><img src=\"/images/blog/fluentlenium.png\" alt=\"\"></p><p>All my previous posts labeled with <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">Selenium tag</a><br>featured <a href=\"http://fluentlenium.org/\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> syntax. Why? Even though I tried to answer it in FluentLenium focused posts (<a href=\"https://www.awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">Introduction</a> &amp; <a href=\"https://www.awesome-testing.com/2016/04/introducing-fluentlenium-2-selenium.html\" target=\"_blank\" rel=\"noreferrer\">Waiting game</a>)<br>I never really did full comparison against Selenium. As you probably already figured out reading the title this post will show how FluentLenium can help you write better, shorter and easier to maintain Selenium tests.</p><p>Just to be clear that we are on the same page: <strong>FluentLenium is only Selenium extension, not alternative</strong>. It&#39;s important to keep in mind that it&#39;s still GUI automation with all it&#39;s flaws and difficulties. FluentLenium was designed to mitigate these problems as shall be shown here.</p><p>Warning: this post is code rich.</p><h2>Selenium</h2>\n<p>I&#39;m going to start with pure Selenium first. Let&#39;s say we want to automate the following scenario:</p><p>a) Search for &#39;public speaking&#39; term on my blog. Make sure the search results page contains some posts.</p><p>b) Open first post and verify that it contains comment section.</p><p>I chose to verify comment section, because it&#39;s loaded dynamically by Blogger. As you shall see pure Selenium struggles a bit with such elements and fancy waiting is required for test stability.</p><p>Our obvious first step is adding Selenium dependency into pom.xml. I&#39;m using 3.9.1 version here:</p><pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.seleniumhq.selenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>selenium-chrome-driver<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.seleniumhq.selenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>selenium-firefox-driver<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.seleniumhq.selenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>selenium-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n         <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre><p>We need some properties next. I&#39;m writing those words on Windows so I have to define driver paths. Let&#39;s implement the simplest possible class that handles it:</p><pre><code class=\"hljs language-plaintext\">\n    private Properties properties;\n\n    public MyProperties() {\n        properties = loadProperties();\n    }\n\n    private static Properties loadProperties() {\n        Properties properties = new Properties();\n        try {\n            properties.load(MyProperties.class.getResourceAsStream(&quot;/user.properties&quot;));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return properties;\n    }\n\n    public String getProperty(String property) {\n        return properties.getProperty(property);\n    }\n}</code></pre><p>And next we need user.properties file in test resources folder:</p><pre><code class=\"hljs language-plaintext\"></code></pre><p>So far so good. We are ready to start defining tests. Let&#39;s create a top level test class responsible for driver handling first. It will be our baseline. Normally I don&#39;t include imports in my snippets, but this Apache Commons entry is necessary for easy understanding of if in setUp() section. I have Mac with chrome driver system property already set by Brew and this line ensures that it will work on it without any changes. I&#39;m using JUnit btw.</p><pre><code class=\"hljs language-plaintext\">\npublic class SeleniumTest {\n\n    protected static WebDriver driver;\n    private MyProperties myProperties = new MyProperties();\n\n    @Before\n    public void setUp() {\n        if (IS_OS_WINDOWS) {\n            System.setProperty(&quot;webdriver.chrome.driver&quot;,\n                               myProperties.getProperty(&quot;my_chrome_path&quot;));\n        }\n        driver = new ChromeDriver();\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n}</code></pre><p>Now we need baseline for page objects. I don&#39;t want to load elements from @FindBy annotation every single time, so I&#39;m coding it on top level class.</p><pre><code class=\"hljs language-plaintext\">    protected WebDriver driver;\n\n    public PageObject(WebDriver driver){\n        this.driver = driver;\n        PageFactory.initElements(driver, this);\n    }\n}</code></pre><p>Framework is ready so we can implement our page objects. Main blog page is obvious place to begin. I&#39;m adding two methods, one to make sure we are indeed on correct page and the second one to use search functionality.</p><pre><code class=\"hljs language-plaintext\">\n    @FindBy(css = &quot;input.gsc-input&quot;)\n    private WebElement searchBar;\n\n    @FindBy(css = &quot;input.gsc-search-button&quot;)\n    private WebElement searchButton;\n\n    @FindBy(css = &quot;h1&quot;)\n    private WebElement post;\n\n    public MainPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(post.isDisplayed()).isTrue();\n    }\n\n    public SearchResultsPage searchFor(String searchTerm) {\n        this.searchBar.clear();\n        this.searchBar.sendKeys(searchTerm);\n        this.searchButton.click();\n        return new SearchResultsPage(driver);\n    }\n\n}</code></pre><p>Next in flow is search results page. This time I&#39;m adding two assertions (are we on correct page? are posts displayed?)<br>and method which clicks on first post title.</p><pre><code class=\"hljs language-plaintext\">\n    @FindBy(className = &quot;status-msg-wrap&quot;)\n    private WebElement searchOptionPanel;\n\n    public SearchResultsPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(searchOptionPanel.isDisplayed()).isTrue();\n    }\n\n    public void assertThatPostsAreDisplayed() {\n        List&lt;WebElement&gt; postsTitles = driver.findElements(By.cssSelector(&quot;h1 a&quot;));\n        assertThat(postsTitles).size().isPositive();\n    }\n\n    public PostPage clickOnFirstPost() {\n        List&lt;WebElement&gt; posts = driver.findElements(By.cssSelector(&quot;h1 a&quot;));\n        posts.get(0).click();\n\n        return new PostPage(driver);\n    }\n\n}</code></pre><p>And finally we are on post page. Comment section is not only in an iframe, but it also loads dynamically. In order to handle it I had to implement fancy wait, which polls every 500 milliseconds maximum 10 times. Element is not there at first, but we ignore NoSuchElementException and poll again.</p><pre><code class=\"hljs language-plaintext\">\n    @FindBy(id = &quot;comment-editor&quot;)\n    private WebElement commentsSection;\n\n    public PostPage(WebDriver driver) {\n        super(driver);\n    }\n\n    public void isInitialized() {\n        assertThat(commentsSection.isDisplayed()).isTrue();\n    }\n\n    public void checkCommentsSectionPresence() {\n        driver.switchTo().frame(commentsSection);\n        wait.until(ExpectedConditions.presenceOfElementLocated(By.name(&quot;commentBody&quot;)));\n    }\n\n    private Wait&lt;WebDriver&gt; wait = new FluentWait&lt;&gt;(driver)\n            .withTimeout(5, TimeUnit.SECONDS)\n            .pollingEvery(500, TimeUnit.MILLISECONDS)\n            .ignoring(NoSuchElementException.class)\n            .withMessage(&quot;Oops, element didn&#x27;t appear!&quot;);\n\n}</code></pre><p>Having all pieces implemented we can write a pure Selenium test.</p><pre><code class=\"hljs language-plaintext\">\n    private static final String BLOG = &quot;https://www.awesome-testing.com&quot;;\n\n    @Test\n    public void shouldSuccessfullyFindPostAndDisplayCommentSection() {\n        driver.get(BLOG);\n        MainPage mainPage = new MainPage(driver);\n        mainPage.isInitialized();\n\n        SearchResultsPage searchResultsPage =  mainPage.searchFor(&quot;public speaking&quot;);\n        searchResultsPage.isInitialized();\n        searchResultsPage.assertThatPostsAreDisplayed();\n\n        PostPage postPage = searchResultsPage.clickOnFirstPost();\n        postPage.isInitialized();\n        postPage.checkCommentsSectionPresence();\n    }\n}</code></pre><h2>FluentLenium</h2>\n<p>Now we will write the same test using FluentLenium. Spoiler alert: it will be easier :)</p><p>As usual, we start with dependencies in pom.xml.</p><pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.fluentlenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fluentlenium-core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.fluentlenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fluentlenium-assertj<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.fluentlenium<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>fluentlenium-junit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre><p>Driver handling is already taken care of by FluentLenium (FluentTest class). I want my tests to work both on Windows and Mac, so I&#39;m adding a little extension. FluentLenium also allows to store driver names in human friendly way so I have added driver=chrome property. MyProperties class can be found above.</p><pre><code class=\"hljs language-plaintext\">\npublic class FluentLeniumTest extends FluentTest {\n\n    protected static WebDriver driver;\n    private static MyProperties myProperties = new MyProperties();\n\n    @BeforeClass\n    public static void setUp() {\n        if (IS_OS_WINDOWS) {\n            System.setProperty(&quot;webdriver.chrome.driver&quot;,\n                               myProperties.getProperty(&quot;my_chrome_path&quot;));\n        }\n    }\n\n    @Override\n    public String getWebDriver() {\n        return myProperties.getProperty(&quot;driver&quot;);\n    }\n}</code></pre><p>In Selenium section I have implemented PageObject class for framework preparations. It isn&#39;t required in FluentLenium.<br>It&#39;s already handled by FluentPage class.</p><p>We can proceed to Page Object definition now. Let&#39;s start with Main Page. @PageUrl annotation is used to tell driver where to go. newInstance() method creates new page object class and isAt() is used for &#39;am I on correct page?&#39;<br>verification.</p><pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@PageUrl(&quot;https://www.awesome-testing.com&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentPage</span> {\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-input&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement searchBar;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;input.gsc-search-button&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentWebElement searchButton;\n\n    <span class=\"hljs-meta\">@FindBy(css = &quot;h1&quot;)</span>\n    <span class=\"hljs-keyword\">private</span> FluentList&lt;FluentWebElement&gt; posts;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">isAt</span><span class=\"hljs-params\">()</span> {\n        assertThat(posts).hasSize().greaterThan(<span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> SearchResultsPage <span class=\"hljs-title function_\">searchFor</span><span class=\"hljs-params\">(String searchTerm)</span> {\n        searchBar.fill().with(searchTerm);\n        searchButton.click();\n        <span class=\"hljs-keyword\">return</span> newInstance(SearchResultsPage.class);\n    }\n}</code></pre><p>Now search result page with similar methods. Please take a look into @FindBy support for lists. Such feature isn&#39;t implemented in pure Selenium. It really helps to write easy to maintain code.</p><pre><code class=\"hljs language-plaintext\">\n    @FindBy(className = &quot;status-msg-wrap&quot;)\n    private FluentWebElement searchOptionPanel;\n\n    @FindBy(css = &quot;h1 a&quot;)\n    private FluentList&lt;FluentWebElement&gt; posts;\n\n    @Override\n    public void isAt() {\n        assertThat(searchOptionPanel).isDisplayed();\n    }\n\n    public void assertThatPostsAreDisplayed() {\n        assertThat(posts).hasSize().greaterThan(0);\n    }\n\n    public PostPage clickOnFirstPost() {\n        posts.first().click();\n        return newInstance(PostPage.class);\n    }\n}</code></pre><p>Finally, post page. You can see how useful await() methods are. Instead of defining separate Wait object we can use intuitive syntax. Also NoSuchElementExceptions are ignored by default. We have also very handy switchTo() method which changes context into iframe.</p><pre><code class=\"hljs language-plaintext\">\n    @FindBy(id = &quot;comment-editor&quot;)\n    private FluentWebElement commentsSection;\n\n    @FindBy(name = &quot;commentBody&quot;)\n    private FluentWebElement commentBody;\n\n    public void isAt() {\n        assertThat(commentsSection).isDisplayed();\n    }\n\n    public void checkCommentsSectionPresence() {\n        switchTo(commentsSection);\n        await().atMost(5, TimeUnit.SECONDS).until(commentBody).displayed();\n    }\n}</code></pre><p>Having all pieces ready let&#39;s take a look at our final creation - a FluentLenium test. @Page is pseudo injection - it allow us to predefine pages used in test.</p><pre><code class=\"hljs language-plaintext\">\n    @Page\n    private MainPage mainPage;\n\n    @Page\n    private SearchResultsPage searchResultsPage;\n\n    @Page\n    private PostPage postPage;\n\n    @Test\n    public void shouldSuccessfullySearchForPosts() {\n        mainPage.go();\n        mainPage.isAt();\n        mainPage.searchFor(&quot;public speaking&quot;);\n\n        searchResultsPage.isAt();\n        searchResultsPage.assertThatPostsAreDisplayed();\n        searchResultsPage.clickOnFirstPost();\n\n        postPage.isAt();\n        postPage.checkCommentsSectionPresence();\n    }\n}</code></pre><h2>Conclusion</h2>\n<p>I&#39;m engineer, and I&#39;m not a fan of arguments about which approach is better. I can only suggest you try FluentLenium and see how it works for you. Personally I&#39;m a huge fan and I hope this post highlighted its features. Doesn&#39;t it?</p><p>As usual all code can be downloaded from by <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub page</a>.</p>"
}