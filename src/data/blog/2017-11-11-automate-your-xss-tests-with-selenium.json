{
  "id": "2017-11-11-automate-your-xss-tests-with-selenium",
  "title": "Automate your XSS tests with Selenium",
  "date": "2017-11-11",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium",
    "security"
  ],
  "permalink": "/2017/11/automate-your-xss-tests-with-selenium",
  "content": "<p><img src=\"/images/blog/safety-lock-logo_23-2147493514.jpg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>We are heading into an era where potential attackers have very easy knowledge access. In some instances proper training<br>isn&#39;t even required, because offensive tools are getting better and better. A lot of companies decided that it&#39;s better<br>to pay real money for security bugs (see <a href=\"https://hackerone.com/bug-bounty-programs\" target=\"_blank\" rel=\"noreferrer\">Bug Bounty list</a>) than take a risk<br>hostile exposure.</p>\n<p>As testers we shouldn&#39;t ignore this trend. This is already reflected in job offers - you may often notice that<br>defensive/offensive security knowledge is starting to appear not only in &#39;nice to have&#39; section, but also in<br>requirements. I have already made <a href=\"http://www.awesome-testing.com/search/label/security\" target=\"_blank\" rel=\"noreferrer\">2 posts</a> about various security<br>testing aspects.</p>\n<p>XSS (cross-site scripting) is one of the easiest vulnerabilities to<br>test (<a href=\"https://www.owasp.org/index.php/Category:Vulnerability_Scanning_Tools\" target=\"_blank\" rel=\"noreferrer\">for example by scanners</a>). It&#39;s also the<br>second most prevalent issue in the <a href=\"https://www.owasp.org/images/b/b0/OWASP_Top_10_2017_RC2_Final.pdf\" target=\"_blank\" rel=\"noreferrer\">OWASP Top 10</a>,<br>and is found in around two thirds of all applications. Today I want to show you how to test against XSS using Selenium.<br>We would focus our attention on the most popular and common type of XSS - Reflected Cross-Site Scripting.</p>\n<p><strong>Reflected Cross-Site Scripting basics</strong></p>\n<p><a href=\"https://www.owasp.org/index.php/Testing_for_Cross_site_scripting\" target=\"_blank\" rel=\"noreferrer\">OWASP</a> provides excellent description of Reflected<br>XSS which doesn&#39;t require much explanation:</p>\n<blockquote class=\"blog-quote\"><p>These holes show up when data provided by a web client is used immediately by server-side scripts to generate a page</p><p>of results for that user. If unvalidated user-supplied data is included in the resulting page without HTML encoding,</p><p>this will allow client-side code to be injected into the dynamic page. A classic example of this is in site search</p><p>engines: if one searches for a string which includes some HTML special characters, often the search string will be</p><p>redisplayed on the result page to indicate what was searched for, or will at least include the search terms in the text</p><p>box for easier editing. If all occurrences of the search terms are not HTML entity encoded, an XSS hole will result.__  </p></p></blockquote><p>For more information see <a href=\"https://www.owasp.org/images/1/19/OTGv4.pdf\" target=\"_blank\" rel=\"noreferrer\">OWASP Testing Guide</a> which is amazing resource<br>available for free.</p>\n<p><strong>Example in Java</strong></p>\n<p>As usual I enjoyed the most coding part. I commited it on<br>my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting/commit/907e6f7de8702d8da6db1c78d9fcdb5fb278a1b2\" target=\"_blank\" rel=\"noreferrer\">Github project</a>.</p>\n<p>Let&#39;s split the explanation into few parts:</p>\n<p><strong><em>Driver preparation</em></strong></p>\n<p>This step can be omitted entirely if you are using Firefox. I usually prefer Chrome (chromedriver is in my opinion the<br>most reliable driver) so I had to disable built-in client xss protection first. I have already covered it extensively in<br>my <a href=\"http://www.awesome-testing.com/2016/02/selenium-browser-capabilities-explained.html\" target=\"_blank\" rel=\"noreferrer\">Browser Capabilites Explained post</a><br>so I assume reader doesn&#39;t require additional explanation.</p>\n<p>XSS protection in Google Chrome is disabled by_--disable-xss-auditor_ option.</p>\n<pre><code class=\"language-java\">public class XssDisabledChromeConfig extends FluentTestNg {\n\n    private static final String DISABLE_XSS_AUDITOR = &quot;--disable-xss-auditor&quot;;\n\n    @Override\n    public WebDriver newWebDriver() {\n        return new ChromeDriver(getChromeCapabilities());\n    }\n\n    private DesiredCapabilities getChromeCapabilities() {\n        DesiredCapabilities capabilities = DesiredCapabilities.chrome();\n        capabilities.setCapability(ChromeOptions.CAPABILITY, getChromeOptions());\n        return capabilities;\n    }\n\n    private ChromeOptions getChromeOptions() {\n        ChromeOptions options = new ChromeOptions();\n        options.addArguments(getChromeSwitches());\n        return options;\n    }\n\n    private List&lt;String&gt; getChromeSwitches() {\n        List&lt;String&gt; chromeSwitches = new ArrayList&lt;&gt;();\n        chromeSwitches.add(DISABLE_XSS_AUDITOR);\n        return chromeSwitches;\n    }\n</code></pre>\n<p><strong><em>Picking a vulnerable page</em></strong></p>\n<p>Obviously in order to show you how to test against XSS I had to find a vulnerable page. I decided to<br>use <a href=\"https://xss-game.appspot.com/\" target=\"_blank\" rel=\"noreferrer\">XSS game</a> level 1.</p>\n<p>That&#39;s the Page Object implementation using <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a>.</p>\n<pre><code class=\"language-java\">@PageUrl(&quot;https://xss-game.appspot.com/level1/frame&quot;)\npublic class XssGameLevelOnePage extends FluentPage {\n\n    @FindBy(id = &quot;level1&quot;)\n    private FluentWebElement body;\n\n    @FindBy(id = &quot;query&quot;)\n    private FluentWebElement queryInput;\n\n    @FindBy(id = &quot;button&quot;)\n    private FluentWebElement sarchButton;\n\n    @Override\n    public void isAt() {\n        await().atMost(5, TimeUnit.SECONDS).until(body).displayed();\n    }\n\n    public void searchFor(String content) {\n        queryInput.fill().with(content);\n        sarchButton.click();\n    }\n}\n</code></pre>\n<p><strong><em>Test implementation</em></strong></p>\n<p>Having Page Object implemented we are ready for testing. Here is complete code of my test:</p>\n<pre><code class=\"language-java\">public class XssGameTest extends XssDisabledChromeConfig {\n\n    private static final String MY_CHROME_PATH = &quot;C:\\\\drivers\\\\chromedriver.exe&quot;;\n    private static final String XSS_CONTENT = &quot;&lt;script&gt;alert(\\&quot;1\\&quot;);&lt;/script&gt;&quot;;\n\n    @BeforeTest\n    public void setUp() {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            System.setProperty(&quot;webdriver.chrome.driver&quot;, MY_CHROME_PATH);\n        }\n    }\n\n    @Page\n    private XssGameLevelOnePage xssGameLevelOnePage;\n\n    @Test\n    public void xssShouldNotWork() {\n        goTo(xssGameLevelOnePage).isAt();\n\n        xssGameLevelOnePage.searchFor(XSS_CONTENT);\n\n        assertThat(xssGameLevelOnePage.isAlertDisplayed()).isFalse();\n    }\n}\n</code></pre>\n<p>As you can see there is weirdly lookin CSS_CONTENT string which require further explanation:</p>\n<p>This is actual XSS. We are searching for something that may lead to client-side code injection on attacked webpage. This<br>particular JavaScript opens only silly alert, but attacker may use it for something more serious.</p>\n<pre><code class=\"language-java\">XSS_CONTENT = &quot;&lt;script&gt;alert(\\&quot;1\\&quot;);&lt;/script&gt;&quot;;\n</code></pre>\n<p><strong><em>Assertion</em></strong></p>\n<p>Usually we want our test to have clear success/failure criteria. That&#39;s why I implemented the following method in my<br>PageObject:</p>\n<pre><code class=\"language-java\">public boolean isAlertDisplayed() {\n        boolean foundAlert;\n        WebDriverWait wait = new WebDriverWait(getDriver(), 2);\n        try {\n            wait.until(ExpectedConditions.alertIsPresent());\n            foundAlert = true;\n        } catch (TimeoutException e) {\n            foundAlert = false;\n        }\n        return foundAlert;\n    }\n</code></pre>\n<p>This method is returning true if popup is displayed in 2 seconds time.</p>\n<p>Execute the test on your computer and you will see that it fails - we have found XSS!</p>\n"
}