{
  "id": "2023-03-12-understanding-cypress-synchronousasynchronous-duality",
  "title": "Understanding Cypress synchronous/asynchronous duality",
  "date": "2023-03-12",
  "categories": [
    "Cypress"
  ],
  "tags": [
    "cypress",
    "test automation",
    "UI testing"
  ],
  "permalink": "/2023/03/understanding-cypress",
  "content": "<img src=\"/images/blog/cypress.png\" alt=\"\">\n\n<p>Cypress is a widely used end-to-end testing framework for web applications that offers an easy-to-use API and a powerful command-line interface. It enables developers to write tests that mimic end-users&#39; interactions with their applications.<br>Understanding how sync/async works is a crucial concept for developers using Cypress.</p><p>However, one of the common criticisms leveled against Cypress is its approach to handling asynchronous behavior in JavaScript. To ensure that commands are executed synchronously, Cypress uses a technique called &quot;<a href=\"https://learn.cypress.io/cypress-fundamentals/command-chaining\" target=\"_blank\" rel=\"noreferrer\">command chaining</a>.&quot; This can result in Cypress &quot;hacking&quot; the JavaScript code running in the browser by overriding certain native browser APIs. It ensures that the test runner waits for commands to complete before moving on to the next one.</p><p>Some testers argue that this approach can cause unexpected behavior in certain situations and interfere with the application code. Nevertheless, Cypress has implemented this technique to address the problem of flaky tests caused by race conditions and other timing issues. Cypress also provides tools to help developers understand what&#39;s happening under the hood, such as the ability to log and debug the commands being executed.</p><h2>Synchronous vs asynchronous Javascript</h2>\n<p>JavaScript is a versatile programming language used for building web applications. In web development, asynchronous programming is a common concept, as JavaScript code often has to interact with web APIs, databases, and other remote services. Understanding how sync and async JavaScript works is essential for building efficient, scalable, and error-free web applications.</p><h3>Synchronous Javascript</h3>\n<p>Synchronous JavaScript is straightforward to understand as it operates in a blocking or synchronous manner. This means that when a piece of code executes, the next line of code will not execute until the current line has finished executing. For example, consider the following code:</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;start&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;middle&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>);\n</code></pre><p>This code will output:</p><blockquote class=\"blog-quote\"><p>start</p><p></p><p>middle</p><p></p><p>end</p><p></p></blockquote><p>In synchronous JavaScript, each console.log statement executes in order, and the second statement will not start executing until the first one has finished.</p><h3>Asynchronous Javascript</h3>\n<p>Asynchronous JavaScript is different from synchronous JavaScript because it operates in a non-blocking or asynchronous manner. This means that when a piece of code executes, the next line of code can execute before the current line has finished executing. For example, consider the following code:</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;start&#x27;</span>);\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;middle&#x27;</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>);\n</code></pre><p>This code will output:</p><blockquote class=\"blog-quote\"><p>start</p><p></p><p>end</p><p></p><p>middle</p><p></p></blockquote><p>In asynchronous JavaScript, the setTimeout function executes asynchronously. It starts a timer for one second and then returns immediately. Meanwhile, the console.log(&#39;end&#39;) statement executes before the timer has finished. When the timer finishes after one second, the function passed to setTimeout executes, and the console.log(&#39;middle&#39;) statement is output to the console.</p><p>Asynchronous JavaScript can be challenging to work with as it requires the use of callbacks, promises, or async/await.<br>Callbacks are a function that is passed as an argument to another function and is called when the other function has finished executing. Promises are an object that represents a value that may not be available yet but will be resolved at some point in the future. Async/await is a modern approach that makes asynchronous programming in JavaScript more comfortable to work with by using a combination of promises and generators.</p><p>Callbacks are an older approach to asynchronous programming in JavaScript. They can be challenging to manage and can lead to &quot;callback hell,&quot; where nested callbacks become difficult to read and maintain. Promises were introduced in ECMAScript 6 as a better way of dealing with asynchronous programming. They allow developers to chain asynchronous operations together, making the code easier to read and understand.</p><p>Async/await is a new approach to asynchronous programming in JavaScript that was introduced in ECMAScript 2017. It is a cleaner and more concise way of handling asynchronous operations, and it makes the code more readable and maintainable.<br>Async/await uses promises and generators to make asynchronous programming easier to work with, and it has quickly become the preferred way of handling asynchronous operations in modern JavaScript.</p><h2>Understanding Cypress chain of command</h2>\n<p>Understanding how Cypress handles asynchronous operations is a crucial concept for developers to grasp. Misunderstanding how Cypress deals with asynchronous tasks can create issues and confusion during the debugging process of tests.</p><p>Cypress test steps are inherently asynchronous, but the framework includes an engine that enforces the sequential execution of commands. When a Cypress command is invoked, it is not executed immediately but is instead added to a queue for later execution.</p><p>To illustrate how Cypress command chaining works using promises, consider the following test example:</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-comment\">/// &lt;reference types=&quot;cypress&quot; /&gt;</span>\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;Awesome tests&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-string\">&#x27;https://awesome-testing.com/&#x27;</span>)\n    })\n\n    <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should find Cypress posts&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-input input&#x27;</span>).<span class=\"hljs-title function_\">type</span>(<span class=\"hljs-string\">&#x27;Cypress&#x27;</span>)\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-search-button input&#x27;</span>).<span class=\"hljs-title function_\">click</span>()\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.post-title&#x27;</span>).<span class=\"hljs-title function_\">should</span>(<span class=\"hljs-string\">&#x27;have.length.above&#x27;</span>, <span class=\"hljs-number\">1</span>)\n    })\n\n})\n</code></pre><p>Effectively, this is the JavaScript code that is executed in the browser (the details may vary but it&#39;s a chain of promises):</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-comment\">/// &lt;reference types=&quot;cypress&quot; /&gt;</span>\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;Awesome tests&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should find Cypress posts&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-string\">&#x27;https://awesome-testing.com/&#x27;</span>)\n            .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n                cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-input input&#x27;</span>)\n            }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">$input</span>) =&gt;</span> {\n                cy.<span class=\"hljs-title function_\">wrap</span>($input).<span class=\"hljs-title function_\">type</span>(<span class=\"hljs-string\">&#x27;Cypress&#x27;</span>)\n            }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n                cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-search-button input&#x27;</span>)\n            }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">$btn</span>) =&gt;</span> {\n                cy.<span class=\"hljs-title function_\">wrap</span>($btn).<span class=\"hljs-title function_\">click</span>()\n            }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n                cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.post-title&#x27;</span>).<span class=\"hljs-title function_\">should</span>(<span class=\"hljs-string\">&#x27;have.length.above&#x27;</span>, <span class=\"hljs-number\">1</span>)\n            })\n    })\n\n})\n</code></pre><p>Note: there is <a href=\"https://docs.cypress.io/api/commands/should#Differences\" target=\"_blank\" rel=\"noreferrer\">special logic</a> for handling .should() hence the last line is simplified.</p><p>The second code snippet demonstrates how Cypress commands return a promise that can be used to chain together a sequence of commands that are executed in order. This approach ensures that commands are executed synchronously and that the test runner can wait for commands to complete before moving on to the next one.</p><h3>beforeEach</h3>\n<p>One thing which complicates the picture even more is <a href=\"https://mochajs.org\" target=\"_blank\" rel=\"noreferrer\">Mocha</a> <em>beforeEach</em> webhook. All the commands, including Cypress chain of commands (<em>cy.something()</em>) are guaranteed to execute before tests. It effectively means that Cypress builds a separate chain of command per <em>before</em>, <em>beforeEach</em>, <em>after</em> and <em>afterEach</em>.</p><p>Described behaviour has very significant impact on <a href=\"https://docs.cypress.io/guides/guides/debugging\" target=\"_blank\" rel=\"noreferrer\">debugging</a>.<br>Consider the following example:</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-comment\">/// &lt;reference types=&quot;cypress&quot; /&gt;</span>\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;Awesome tests&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n<span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =&gt;</span> {\ncy.<span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-string\">&#x27;https://www.awesome-testing.com/&#x27;</span>)\ncy.<span class=\"hljs-title function_\">viewport</span>(<span class=\"hljs-number\">1920</span>, <span class=\"hljs-number\">1080</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;This will be logged before cy.visit&#x27;</span>)\n})\n\n    <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should find Cypress posts&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-input input&#x27;</span>).<span class=\"hljs-title function_\">type</span>(<span class=\"hljs-string\">&#x27;Cypress&#x27;</span>)\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.gsc-search-button input&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">$btn</span>) =&gt;</span> {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;This will be logged after typing Cypress&#x27;</span>)\n        })\n        cy.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;.post-title&#x27;</span>).<span class=\"hljs-title function_\">should</span>(<span class=\"hljs-string\">&#x27;have.length.above&#x27;</span>, <span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;This will be logged after cy.visit&#x27;</span>)\n    })\n\n    <span class=\"hljs-title function_\">afterEach</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">wait</span>(<span class=\"hljs-number\">2000</span>)\n        cy.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;This is Cypress logging hence it will log after waiting&#x27;</span>)\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;This will log after test before waiting&#x27;</span>)\n    })\n\n})\n</code></pre><p>The order of execution is as follows:</p><ul>\n<li>synchronous commands in <em>beforeEach</em></li>\n<li>Cypress commands (<em>cy.something()</em>) in <em>beforeEach</em></li>\n<li>synchronous commands in <em>it</em></li>\n<li>Cypress commands (<em>cy.something()</em>) in_it_</li>\n<li>synchronous commands in_afterEach_</li>\n<li>Cypress commands (<em>cy.something()</em>) in_afterEach_</li>\n</ul>\n<p>As you can see for the most effective debugging we have to write code in <em><a href=\"https://docs.cypress.io/api/commands/then\" target=\"_blank\" rel=\"noreferrer\">then()</a></em> section. However, <em>.then()</em> is a Cypress command, not a Promise.<br>This means you cannot use things like async/await within your Cypress tests.</p><h2>Conclusion</h2>\n<p>Cypress offers a low entry level for developers to start testing their web applications, with its easy-to-use API and user-friendly command-line interface. However, this simplicity comes at a cost. The framework is effectively sandboxed,<br>meaning that performing tasks outside of its defined parameters can be difficult. This can limit the ability of developers to fully customize their testing environment and address more complex testing scenarios. Despite its limitations, Cypress provides a solid foundation for web application testing and can be a valuable tool for developers looking to quickly and effectively test their applications. However, it&#39;s important to consider the trade-offs when deciding whether to use Cypress, and to understand its limitations before getting started.</p>"
}