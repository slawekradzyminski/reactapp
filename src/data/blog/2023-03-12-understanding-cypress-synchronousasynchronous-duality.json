{
  "id": "2023-03-12-understanding-cypress-synchronousasynchronous-duality",
  "title": "Understanding Cypress synchronous/asynchronous duality",
  "date": "2023-03-12",
  "categories": [
    "Cypress"
  ],
  "tags": [
    "cypress",
    "test automation",
    "UI testing"
  ],
  "permalink": "/2023/03/understanding-cypress",
  "content": "<p><img src=\"/images/blog/cypress.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Cypress is a widely used end-to-end testing framework for web applications that offers an easy-to-use API and a powerful<br>command-line interface. It enables developers to write tests that mimic end-users&#39; interactions with their applications.<br>Understanding how sync/async works is a crucial concept for developers using Cypress.</p>\n<p>However, one of the common criticisms leveled against Cypress is its approach to handling asynchronous behavior in<br>JavaScript. To ensure that commands are executed synchronously, Cypress uses a technique<br>called &quot;<a href=\"https://learn.cypress.io/cypress-fundamentals/command-chaining\" target=\"_blank\" rel=\"noreferrer\">command chaining</a>.&quot; This can result in<br>Cypress &quot;hacking&quot; the JavaScript code running in the browser by overriding certain native browser APIs. It ensures that<br>the test runner waits for commands to complete before moving on to the next one.</p>\n<p>Some testers argue that this approach can cause unexpected behavior in certain situations and interfere with the<br>application code. Nevertheless, Cypress has implemented this technique to address the problem of flaky tests caused by<br>race conditions and other timing issues. Cypress also provides tools to help developers understand what&#39;s happening<br>under the hood, such as the ability to log and debug the commands being executed.</p>\n<h2>Synchronous vs asynchronous Javascript</h2>\n<p>JavaScript is a versatile programming language used for building web applications. In web development, asynchronous<br>programming is a common concept, as JavaScript code often has to interact with web APIs, databases, and other remote<br>services. Understanding how sync and async JavaScript works is essential for building efficient, scalable, and<br>error-free web applications.</p>\n<h3>Synchronous Javascript</h3>\n<p>Synchronous JavaScript is straightforward to understand as it operates in a blocking or synchronous manner. This means<br>that when a piece of code executes, the next line of code will not execute until the current line has finished<br>executing. For example, consider the following code:</p>\n<pre><code class=\"language-javascript\">console.log(&#39;start&#39;);\nconsole.log(&#39;middle&#39;);\nconsole.log(&#39;end&#39;);\n</code></pre>\n<p>This code will output:</p>\n<pre><code class=\"language-bash\">start\nmiddle\nend\n</code></pre>\n<p>In synchronous JavaScript, each console.log statement executes in order, and the second statement will not start<br>executing until the first one has finished.</p>\n<h3>Asynchronous Javascript</h3>\n<p>Asynchronous JavaScript is different from synchronous JavaScript because it operates in a non-blocking or asynchronous<br>manner. This means that when a piece of code executes, the next line of code can execute before the current line has<br>finished executing. For example, consider the following code:</p>\n<pre><code class=\"language-javascript\">console.log(&#39;start&#39;);\nsetTimeout(() =&gt; {\nconsole.log(&#39;middle&#39;);\n}, 1000);\nconsole.log(&#39;end&#39;);\n</code></pre>\n<p>This code will output:</p>\n<pre><code class=\"language-bash\">start\nend\nmiddle\n</code></pre>\n<p>In asynchronous JavaScript, the setTimeout function executes asynchronously. It starts a timer for one second and then<br>returns immediately. Meanwhile, the console.log(&#39;end&#39;) statement executes before the timer has finished. When the timer<br>finishes after one second, the function passed to setTimeout executes, and the console.log(&#39;middle&#39;) statement is output<br>to the console.</p>\n<p>Asynchronous JavaScript can be challenging to work with as it requires the use of callbacks, promises, or async/await.<br>Callbacks are a function that is passed as an argument to another function and is called when the other function has<br>finished executing. Promises are an object that represents a value that may not be available yet but will be resolved at<br>some point in the future. Async/await is a modern approach that makes asynchronous programming in JavaScript more<br>comfortable to work with by using a combination of promises and generators.</p>\n<p>Callbacks are an older approach to asynchronous programming in JavaScript. They can be challenging to manage and can<br>lead to &quot;callback hell,&quot; where nested callbacks become difficult to read and maintain. Promises were introduced in<br>ECMAScript 6 as a better way of dealing with asynchronous programming. They allow developers to chain asynchronous<br>operations together, making the code easier to read and understand.</p>\n<p>Async/await is a new approach to asynchronous programming in JavaScript that was introduced in ECMAScript 2017. It is a<br>cleaner and more concise way of handling asynchronous operations, and it makes the code more readable and maintainable.<br>Async/await uses promises and generators to make asynchronous programming easier to work with, and it has quickly become<br>the preferred way of handling asynchronous operations in modern JavaScript.</p>\n<h2>Understanding Cypress chain of command</h2>\n<p>Understanding how Cypress handles asynchronous operations is a crucial concept for developers to grasp. Misunderstanding<br>how Cypress deals with asynchronous tasks can create issues and confusion during the debugging process of tests.</p>\n<p>Cypress test steps are inherently asynchronous, but the framework includes an engine that enforces the sequential<br>execution of commands. When a Cypress command is invoked, it is not executed immediately but is instead added to a queue<br>for later execution.</p>\n<p>To illustrate how Cypress command chaining works using promises, consider the following test example:</p>\n<pre><code class=\"language-javascript\">/// &lt;reference types=&quot;cypress&quot; /&gt;\n\ndescribe(&#39;Awesome tests&#39;, () =&gt; {\n    beforeEach(() =&gt; {\n        cy.visit(&#39;https://awesome-testing.com/&#39;)\n    })\n\n    it(&#39;should find Cypress posts&#39;, () =&gt; {\n        cy.get(&#39;.gsc-input input&#39;).type(&#39;Cypress&#39;)\n        cy.get(&#39;.gsc-search-button input&#39;).click()\n        cy.get(&#39;.post-title&#39;).should(&#39;have.length.above&#39;, 1)\n    })\n\n})\n</code></pre>\n<p>Effectively, this is the JavaScript code that is executed in the browser (the details may vary but it&#39;s a chain of<br>promises):</p>\n<pre><code class=\"language-javascript\">/// &lt;reference types=&quot;cypress&quot; /&gt;\n\ndescribe(&#39;Awesome tests&#39;, () =&gt; {\n\n    it(&#39;should find Cypress posts&#39;, () =&gt; {\n        cy.visit(&#39;https://awesome-testing.com/&#39;)\n            .then(() =&gt; {\n                cy.get(&#39;.gsc-input input&#39;)\n            }).then(($input) =&gt; {\n                cy.wrap($input).type(&#39;Cypress&#39;)\n            }).then(() =&gt; {\n                cy.get(&#39;.gsc-search-button input&#39;)\n            }).then(($btn) =&gt; {\n                cy.wrap($btn).click()\n            }).then(() =&gt; {\n                cy.get(&#39;.post-title&#39;).should(&#39;have.length.above&#39;, 1)\n            })\n    })\n\n})\n</code></pre>\n<p>Note: there is <a href=\"https://docs.cypress.io/api/commands/should#Differences\" target=\"_blank\" rel=\"noreferrer\">special logic</a> for handling .should() hence the<br>last line is simplified.</p>\n<p>The second code snippet demonstrates how Cypress commands return a promise that can be used to chain together a sequence<br>of commands that are executed in order. This approach ensures that commands are executed synchronously and that the test<br>runner can wait for commands to complete before moving on to the next one.</p>\n<h3>beforeEach</h3>\n<p>One thing which complicates the picture even more is <a href=\"https://mochajs.org\" target=\"_blank\" rel=\"noreferrer\">Mocha</a> <em>beforeEach</em> webhook. All the<br>commands, including Cypress chain of commands (<em>cy.something()</em>) are guaranteed to execute before tests. It effectively<br>means that Cypress builds a separate chain of command per <em>before</em>, <em>beforeEach</em>, <em>after</em> and <em>afterEach</em>.</p>\n<p>Described behaviour has very significant impact on <a href=\"https://docs.cypress.io/guides/guides/debugging\" target=\"_blank\" rel=\"noreferrer\">debugging</a>.<br>Consider the following example:</p>\n<pre><code class=\"language-javascript\">/// &lt;reference types=&quot;cypress&quot; /&gt;\n\ndescribe(&#39;Awesome tests&#39;, () =&gt; {\nbeforeEach(() =&gt; {\ncy.visit(&#39;https://www.awesome-testing.com/&#39;)\ncy.viewport(1920, 1080)\nconsole.log(&#39;This will be logged before cy.visit&#39;)\n})\n\n    it(&#39;should find Cypress posts&#39;, () =&gt; {\n        cy.get(&#39;.gsc-input input&#39;).type(&#39;Cypress&#39;)\n        cy.get(&#39;.gsc-search-button input&#39;).then(($btn) =&gt; {\n            console.log(&#39;This will be logged after typing Cypress&#39;)\n        })\n        cy.get(&#39;.post-title&#39;).should(&#39;have.length.above&#39;, 1)\n        console.log(&#39;This will be logged after cy.visit&#39;)\n    })\n\n    afterEach(() =&gt; {\n        cy.wait(2000)\n        cy.log(&#39;This is Cypress logging hence it will log after waiting&#39;)\n        console.log(&#39;This will log after test before waiting&#39;)\n    })\n\n})\n</code></pre>\n<p>The order of execution is as follows:</p>\n<ul>\n<li>synchronous commands in <em>beforeEach</em></li>\n<li>Cypress commands (<em>cy.something()</em>) in <em>beforeEach</em></li>\n<li>synchronous commands in <em>it</em></li>\n<li>Cypress commands (<em>cy.something()</em>) in_it_</li>\n<li>synchronous commands in_afterEach_</li>\n<li>Cypress commands (<em>cy.something()</em>) in_afterEach_</li>\n</ul>\n<p>As you can see for the most effective debugging we have to write code in<br><em><a href=\"https://docs.cypress.io/api/commands/then\" target=\"_blank\" rel=\"noreferrer\">then()</a></em> section. However, <em>.then()</em> is a Cypress command, not a Promise.<br>This means you cannot use things like async/await within your Cypress tests.</p>\n<h2>Conclusion</h2>\n<p>Cypress offers a low entry level for developers to start testing their web applications, with its easy-to-use API and<br>user-friendly command-line interface. However, this simplicity comes at a cost. The framework is effectively sandboxed,<br>meaning that performing tasks outside of its defined parameters can be difficult. This can limit the ability of<br>developers to fully customize their testing environment and address more complex testing scenarios. Despite its<br>limitations, Cypress provides a solid foundation for web application testing and can be a valuable tool for developers<br>looking to quickly and effectively test their applications. However, it&#39;s important to consider the trade-offs when<br>deciding whether to use Cypress, and to understand its limitations before getting started.</p>\n"
}