{
  "id": "2016-10-20-testops-3-continuous-testing",
  "title": "TestOps - Continuous Testing",
  "date": "2016-10-20",
  "category": "TestOps",
  "permalink": "/2016/10/testops-3-continuous-testing",
  "content": "<img src=\"/images/blog/jquery-ajax-loader.jpg\" alt=\"\">\n\n<p>Part 3 of my <a href=\"https://awesome-testing.com/search/label/testops\" target=\"_blank\" rel=\"noreferrer\">TestOps</a> series focuses on an extremely important subject that spans throughout the full <a href=\"https://en.wikipedia.org/wiki/Systems_development_life_cycle\" target=\"_blank\" rel=\"noreferrer\">Systems development life cycle</a> (SDLC). Some may argue that apart from understanding obvious<a href=\"https://awesome-testing.com/2016/07/testops-missing-piece-of-puzzle.html\" target=\"_blank\" rel=\"noreferrer\">TestOps benefits</a>it&#39;s the key for a successful release and effective development.</p><p>From what I saw reading various articles and books about the subject no clear Continuous Testing (CT) definition exists.<br>In such cases it&#39;s always best to use <a href=\"https://en.wikipedia.org/wiki/Continuous_testing\" target=\"_blank\" rel=\"noreferrer\">Wikipedia</a>:</p><blockquote class=\"blog-quote\"><p>Continuous testing is the process of</p><p></p><p>executing<a href=\"https://en.wikipedia.org/wiki/Test_automation\" target=\"_blank\" rel=\"noreferrer\" title=\"Test automation\">automated tests</a>as part of the software</p><p></p><p>delivery pipeline to obtain immediate feedback on the business risks associated with a software release candidate.</p><p></p></blockquote><p>Every CT step except exploratory testing should be fully automated and run as often as possible. Basically speaking if our infrastructure allows us to run every CT step after every commit on every branch we should take full advantage of that. If not CT can be performed nightly. CT should be integrated into<a href=\"http://cdn.infoq.com/statics_s2_20150819-0313/resource/articles/orch-pipelines-jenkins/en/resources/Fig1-large.png\" target=\"_blank\" rel=\"noreferrer\">the delivery pipeline</a><br>using tools like Jenkins, TeamCity, Go, GitLab CI, etc.</p><p>I believe we can distinguish a few things that make CT complete:</p><p><strong>Continuous Integration (CI) and unit tests</strong></p><p>After every single commit to the main branch application should be compiled and build. Unit tests should also be executed at this point to give as quickest feedback as possible. In case of failure, some kind of event (mail, slack notification) is advisable for team or culprits only (the people whose changes lead to failure). Unit tests must be executed quickly in parallel. Developers should see failure notification before they begin the next task to avoid distractions. Unit tests should be written by developers (ideally in TDD fashion),<br>but<a href=\"https://testing.googleblog.com/\" target=\"_blank\" rel=\"noreferrer\">Google Testing Blogs</a>advises testers to have strong skills in this area. In case of bad practices (too slow tests, no parallelism, too few tests, not following <a href=\"http://martinfowler.com/bliki/TestPyramid.html\" target=\"_blank\" rel=\"noreferrer\">test pyramid</a>, poor test quality/readability/maintainability)<br>we should initiate change and improvement. Also sometimes it is advisable to move integration/E2E tests to lower levels to speed up the whole pipeline.</p><p>Few authors distinguish <a href=\"http://pitest.org/\" target=\"_blank\" rel=\"noreferrer\">mutation testing</a>as a separate CT step. I don&#39;t agree with that. Mutation testing is a way to check how good our unit tests are doing. We basically make sure that they can report failure in case of reverted logic.</p><p><strong>Code coverage and static analysis</strong></p><p>After the developer commits code to the main branch he should be informed how his feature changed overall code coverage statistics. You may be surprised here, but the introduction of <a href=\"https://en.wikipedia.org/wiki/Gamification\" target=\"_blank\" rel=\"noreferrer\">the gamification</a> element to your pipeline usually has a very positive effect on the number of unit tests written. No developer wants to be a laggard who worsens statistics. Example code coverage tools: <a href=\"http://www.eclemma.org/jacoco/\" target=\"_blank\" rel=\"noreferrer\">JaCoCo</a> and <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"noreferrer\">Istanbul</a>.</p><p>Static code analysis tools like <a href=\"http://www.sonarqube.org/\" target=\"_blank\" rel=\"noreferrer\">SonarQube</a>are also very useful. They&#39;re capable of doing non-personal code reviews and white box testing in an automated fashion. They identify security issues, bugs, code smells, etc. You can not only modify/remove existing rules but also add new ones.</p><p>Ideally, you want a static code analysis tool integrated with the code review process. This allows reviewers to focus on the broad picture (architecture, maintainability) instead of debating if the given variable should be final.</p><p><strong>Continuous Delivery / Automated deployment</strong></p><p>When application building finishes you want to test your deployment process. Ideally, it should be done in the same fashion as a production release. Performing lots of test environment deployments daily gives you confidence that your release pipeline is working fine.</p><p><strong>Integration / E2E / Visual testing</strong></p><p>After the application was successfully deployed on the testing environment you can begin higher-level tests. I&#39;m analyzing them as a whole because the actual distribution of test cases depends pretty much on your strategy. Generally speaking, you want to cover as many functionalities on integration/API level to shrink expensive E2E/Selenium tests.<br>This sometimes creates a void in visual verification which can be fulfilled by tools like <a href=\"https://github.com/garris/BackstopJS\" target=\"_blank\" rel=\"noreferrer\">BackstopJS</a> or <a href=\"http://galenframework.com/\" target=\"_blank\" rel=\"noreferrer\">Galen Framework</a>.</p><p>An important note here: testing on this level should be owned by the whole team, not only testers. This means that your testing strategy should be discussed and agreed on by everyone in your project.</p><p>Examples of this level tests can be found on my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">Github Awesome Testing</a> project.</p><p><strong>Performance testing</strong></p><p>Along with functional testing, you want to check how your application is doing under heavy load. I&#39;m planning a separate post on this subject, but at this point, it&#39;s worth to note that:</p><p><em>Performance tests should have a separate environment which is as close to production as possible - if you can&#39;t achieve that it&#39;s usually better to do performance testing on production environment</em></p><p>This sometimes means that you can&#39;t add performance testing to your pipeline.</p><p><strong>Security testing (DevSecOps)</strong></p><p>The latest trend with a terrible name - <a href=\"http://www.devsecops.org/\" target=\"_blank\" rel=\"noreferrer\">DevSecOps</a>. Security is becoming more and more important as hacking is getting increasingly easier with powerful tools like <a href=\"https://portswigger.net/burp/\" target=\"_blank\" rel=\"noreferrer\">Burp</a>.<br>Sometimes you can have quick victories by integrating existing tools into your pipeline. Examples are <a href=\"https://www.owasp.org/index.php/OWASP_Dependency_Check\" target=\"_blank\" rel=\"noreferrer\">the OWASP dependency check</a>, <a href=\"https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project\" target=\"_blank\" rel=\"noreferrer\">OWASP Zed Attack Proxy (ZAP)</a>,<br>or<a href=\"http://gauntlt.org/\" target=\"_blank\" rel=\"noreferrer\">Gauntlt</a>. If you don&#39;t do security testing already it&#39;s highly recommended to start as soon as possible.</p><p><strong>Exploratory testing</strong></p><p>Time for the most controversial topic of all - manual exploratory testing. The word which triggers endless debate here is most likely &#39;manual&#39;. Now I&#39;m definitely no fan of manual activities, but I also see a value in skilled exploratory testing. I think it&#39;s worth to execute them after completing big features and before releases.</p><p>Evaluate often if there is value in this step though - you don&#39;t want to have useless manual activities slowing down your process.</p><p>If you want to expand your knowledge in exploratory testing I suggest reading <a href=\"http://testobsessed.com/2006/04/rigorous-exploratory-testing/\" target=\"_blank\" rel=\"noreferrer\">Elisabeth Hendrickson</a>.</p><p><strong>Testing in Production (TiP)</strong><br></p><p>Set of continuous activities which test live application. I already described it fully in my previous <a href=\"https://awesome-testing.com/2016/09/testops-2-testing-in-production.html\" target=\"_blank\" rel=\"noreferrer\">TestOps #2 - Testing in Production</a><br>post.</p>"
}