{
  "id": "2019-05-22-performance-testing-benchmarking-java-code-with-jmh",
  "title": "Performance testing (benchmarking) Java code with JMH",
  "date": "2019-05-22",
  "category": "Performance testing",
  "permalink": "/2019/05/performance-testing-benchmarking-java",
  "content": "<img src=\"/images/blog/performance-icon-png-8.png\" alt=\"\">\n\n<p>As test engineers when we approach performance testing we usually only think about final end-to-end application verification with tools such as <a href=\"https://jmeter.apache.org/\" target=\"_blank\" rel=\"noreferrer\">JMeter</a>, <a href=\"https://locust.io/\" target=\"_blank\" rel=\"noreferrer\">Locust</a><br>or <a href=\"https://gatling.io/\" target=\"_blank\" rel=\"noreferrer\">Gatling</a>. We know that such tests should run on a separate environment with conditions resembling production as close as possible. Unfortunately in some cases (especially with monolithic architecture)<br>dedicated performance testing environment is hard to get. What to do in such cases? Should we test on common test environment? Or should we test on production? Or maybe we should change our approach to performance testing? Each option has advantages and disadvantages.</p><p>Today I&#39;d like to describe low-level performance testing (often called benchmarking) of Java code. It does not require a separate environment. It can be executed directly from your IDE (although that&#39;s not recommended) or from the command line. Measuring the performance of critical pieces of code is essential for everyone who creates applications,<br>frameworks, and tools. Testers are co-creators so it&#39;s also our responsibility.</p><h2>Is it easy?</h2>\n<p>Benchmarking correctly is hard. There are multiple optimizations implemented on the JVM/OS/hardware side which make it challenging. In order to measure right, you need to understand how to avoid those optimizations because they may not happen in the real production system.</p><p>Thankfully, there is a tool which helps you mitigate those issues called JMH (Java Microbenchmark Harness). It was created for building, running, and analyzing nano/micro/milli/macro benchmarks written in Java and other languages targetting the JVM. The tool is developed by <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\" target=\"_blank\" rel=\"noreferrer\">OpenJDK</a>.</p><h2>Common pitfalls</h2>\n<p>JMH tool does not guarantee that your benchmark is implemented correctly. You still need to avoid common pitfalls.<br>According to tool creators, the best way to learn how to use JMH is to read through the official JMH samples before implementing your own benchmarks.</p><p>I&#39;ll describe only the four most common pitfalls. For a more complete list please refer to other sources(see the further reading section at the bottom).</p><p><strong><em>a) Dead code elimination</em></strong></p><p>JVM is smart enough to detect that certain code is never used. That&#39;s why the methods you measure should always return something. Alternatively, you can use JMH consume method which guarantees that consumed code will never be buried by JVM.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(Blackhole blackhole)</span> {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">a</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">b</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">sum</span> <span class=\"hljs-operator\">=</span> a - b;\n        blackhole.consume(sum);\n    }\n</code></pre><p><strong><em>b) Constant folding</em></strong></p><p>If JVM realizes the result of the computation is the same no matter what, it can cleverly optimize it. That&#39;s why you should act against your IDE suggestion and don&#39;t make any fields final.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> Math.PI;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">wrongX</span> <span class=\"hljs-operator\">=</span> Math.PI;\n\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">wrong</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> Math.log(wrongX);\n    }\n\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">right</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> Math.log(x);\n    }\n</code></pre><p><em><strong>c) Loop optimizations</strong></em></p><p>You need to be very careful benchmarking unit operations within loops and dividing measurements by the number of iterations. JVM optimizes the loop, so the cost of the loop is smaller than the sum of the costs of its parts measured in isolation.</p><p>It&#39;s a bit tricky (I have misunderstood how it works at first) so I suggest to take a closer look at JMH example <a href=\"https://github.com/Valloric/jmh-playground/blob/master/src/jmh/java/org/openjdk/jmh/samples/JMHSample_11_Loops.java\" target=\"_blank\" rel=\"noreferrer\">11</a><br>and <a href=\"https://github.com/Valloric/jmh-playground/blob/master/src/jmh/java/org/openjdk/jmh/samples/JMHSample_34_SafeLooping.java\" target=\"_blank\" rel=\"noreferrer\">34</a>.</p><p><strong><em>d) Warmup</em></strong></p><p>From official <a href=\"https://github.com/Valloric/jmh-playground\" target=\"_blank\" rel=\"noreferrer\">JMH playground GitHub</a> repository:</p><ul>\n<li>You need warmup iterations because of JVM and JIT warmup. How many depends on the benchmark, but probably no less than<ol start=\"5\">\n<li>A safer number is 10.</li>\n</ol>\n</li>\n<li>The more measurement iterations you use, the smaller the error margin reported by JMH at the end! A solid choice is 20<br>iterations.</li>\n</ul>\n<h2>Setup</h2>\n<p>JMH is very easy to start working with. You can create your own project in a couple of seconds. Just execute the following command in your ~/IdeaProjects folder and open first-benchmark project.</p><p><code>mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DgroupId=com.awesome.testing -DartifactId=first-benchmark -Dversion=1.21</code></p><p>Alternatively, if you want to create tests in existing project, you can follow the same steps I did for my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">AwesomeTesting Github</a> repository. First, add maven dependencies. In a real-world scenario you probably also need to add your application here(in order to call methods you want to measure).</p><pre><code class=\"hljs language-plaintext\">\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;\n            &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;\n            &lt;version&gt;1.21&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;\n            &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;\n            &lt;version&gt;1.21&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre><p>After that you need to configure maven-shade-plugin which will be responsible for creating an executable jar.</p><pre><code class=\"hljs language-plaintext\">\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.2.1&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;shade&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                            &lt;finalName&gt;benchmarks&lt;/finalName&gt;\n                            &lt;transformers&gt;\n                                &lt;transformer\n                                        implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;\n                                    &lt;manifestEntries&gt;\n                                        &lt;Main-Class&gt;org.openjdk.jmh.Main&lt;/Main-Class&gt;\n                                        &lt;X-Compile-Source-JDK&gt;1.8&lt;/X-Compile-Source-JDK&gt;\n                                        &lt;X-Compile-Target-JDK&gt;1.8&lt;/X-Compile-Target-JDK&gt;\n                                    &lt;/manifestEntries&gt;\n                                &lt;/transformer&gt;\n                            &lt;/transformers&gt;\n                            &lt;filters&gt;\n                                &lt;filter&gt;\n                                    &lt;artifact&gt;*:*&lt;/artifact&gt;\n                                    &lt;excludes&gt;\n                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;\n                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;\n                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;\n                                    &lt;/excludes&gt;\n                                &lt;/filter&gt;\n                            &lt;/filters&gt;\n                        &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n</code></pre><p>Now create your jar:</p><p><code>mvn clean package -DskipTests=true</code></p><p>And execute benchmarks (provide the class name which contains @Benchmark annotated methods)</p><p><code>java -jar target/benchmarks.jar BenchMark</code></p><h2>Configuration</h2>\n<p>There are three alternative ways of configuring JMH:</p><p><strong><em>a) Annotations</em></strong></p><p>You can use Java annotations which is very convenient. That&#39;s my favorite type by far because I can easily access nicely written Javadoc for each option. Here is how I configured my demo (each option would be described below):</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@Fork(value = 3, warmups = 0)</span>\n<span class=\"hljs-meta\">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>\n<span class=\"hljs-meta\">@BenchmarkMode(Mode.AverageTime)</span>\n<span class=\"hljs-meta\">@Warmup(iterations = 5, time = 10)</span>\n<span class=\"hljs-meta\">@Measurement(iterations = 5, time = 10)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BenchMark</span> {\n</code></pre><p><strong><em>b) Java API</em></strong></p><p>If you prefer Java API you can use builder configuration and run your tests from IDE. That&#39;s not recommended because Benchmark should ideally run with every single application closed.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> RunnerException {\n        <span class=\"hljs-type\">Options</span> <span class=\"hljs-variable\">opt</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OptionsBuilder</span>()\n                .include(BenchMark.class.getSimpleName())\n                .warmupIterations(<span class=\"hljs-number\">5</span>)\n                .measurementIterations(<span class=\"hljs-number\">5</span>)\n                .forks(<span class=\"hljs-number\">1</span>)\n                .build();\n\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Runner</span>(opt).run();\n    }\n</code></pre><p><strong><em>c) Command line</em></strong></p><p>Last but not least, you can the command line to override configuration. See help for more info:</p><p><code>java -jar target/benchmarks.jar BenchMark -h</code></p><p>Example: 5 warmup/measurement iterations, single fork</p><p><code>java -jar target/benchmarks.jar BenchMark -wi 5 -i 5 -f 1</code></p><h2>Configuration options</h2>\n<p>JMH provides multiple configuration options which can be used in our benchmarks. You can find detailed descriptions in excellent JMH Javadoc.</p><p><strong><em>a) BenchmarkMode</em></strong></p><p>Defines the mode in which this benchmark will run.</p><ul>\n<li>Throughput: measures the number of operations per time unit</li>\n<li>AverageTime: measures the average time it takes for the benchmark method to execute (timeunit/operation)</li>\n<li>SampleTime: samples the time for each operation (min, max, etc.)</li>\n<li>SingleShotTime:measures the time for a single operation.</li>\n<li>All: All modes</li>\n</ul>\n<p><em><strong>b) OutputTimeUnit</strong></em></p><p>Defines a time-unit for results (nanoseconds, milliseconds, seconds, minutes, etfc.)</p><p><em><strong>c) Fork</strong></em></p><p>The fork allows setting the default forking parameters for the benchmark.</p><ul>\n<li>value() defines how many times the benchmark will execute</li>\n<li>warmups() defines how many time the benchmark will execute ignoring results</li>\n</ul>\n<p>Additionally, you can modify JVM options using this annotation.</p><p><em><strong>d) Warmup</strong></em></p><p>Warmup allows setting the default warmup parameters for the benchmark which will execute before each fork (including warmup forks).</p><ul>\n<li>iterations() sets the number of iterations</li>\n<li>time() sets the time for each iteration</li>\n<li>batchSize() sets the number of benchmark method calls per operation</li>\n</ul>\n<p><em><strong>e) Measurement</strong></em></p><p>Measurement allow setting the default measurement parameters for the actual benchmark. Parameters the same as @Warmup.</p><p><strong><em>f) Threads</em></strong></p><p>Threads provides the default number of threads to run. By default, this setting is set to 1. If you want to use maximum set value to Threads.MAX (the equivalent of <em>Runtime.getRuntime().availableProcessors()</em>)</p><h2>Predefining state</h2>\n<p>Unfortunately, two sections of this article aren&#39;t enough to fully describe the JMH configuration. One of the most challenging tasks when it comes to benchmarking is ensuring clean and not JVM-optimized state before each measurement.</p><p>Of course, JMH helps us in this domain as well with class-level @State annotation. This has to be nested public static class defined in a class which contains our Benchmark methods.</p><p>The Scope class gives us the following options:</p><ul>\n<li>Thread: Each thread running the benchmark will create its own instance of the state object.</li>\n<li>Group: Each thread group running the benchmark will create its own instance of the state object.</li>\n<li>Benchmark: All threads running the benchmark share the same state object.</li>\n</ul>\n<p>Having State class in place we can now use @Setup (the equivalent of Junit/TestNG Before) and @TearDown (Junit/TestNG After) which will execute before/after @Benchmark methods. The execution time of these methods will not be counted in our benchmark results.</p><p>Setup and Teardown can be set for three levels:</p><ul>\n<li>Trial: before/after each fork</li>\n<li>Iteration: before/after each iteration</li>\n<li>Invocation: before/after measured method invocation. Javadoc for this option starts with WARNING: HERE BE DRAGONS! so<br>unless you want to meet Game of Thrones dragons don&#39;t use it</li>\n</ul>\n<p>In order to fully understand @Scope, you need to take a look into an actual example.</p><p>Let&#39;s suppose we want to measure multiplication in 4 scenarios (1*1, 1*31, 31*1, 31*31). We also want to start each fork with 0 as a result. After each iteration, we want to do garbage collection. Here is how our benchmark should look like:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExplainingState</span> {\n\n    <span class=\"hljs-meta\">@State(Scope.Thread)</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PredefinedState</span> {\n\n        <span class=\"hljs-meta\">@Param({&quot;1&quot;, &quot;31&quot;})</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> a;\n\n        <span class=\"hljs-meta\">@Param({&quot;1&quot;, &quot;31&quot;})</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> b;\n\n        <span class=\"hljs-meta\">@Setup(Level.Trial)</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doForkSetup</span><span class=\"hljs-params\">()</span> {\n            multiplicationResult = <span class=\"hljs-number\">0</span>;\n            System.out.println(<span class=\"hljs-string\">&quot;\\n Do Setup before each fork \\n&quot;</span>);\n        }\n\n        <span class=\"hljs-meta\">@Setup(Level.Iteration)</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doIterationSetup</span><span class=\"hljs-params\">()</span> {\n            System.out.println(<span class=\"hljs-string\">&quot;\\n Do Setup before each iteration \\n&quot;</span>);\n        }\n\n        <span class=\"hljs-meta\">@TearDown(Level.Iteration)</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doIterationTeardown</span><span class=\"hljs-params\">()</span> {\n            System.out.println(<span class=\"hljs-string\">&quot;\\n Do teardown after each iteration \\n&quot;</span>);\n            System.gc();\n        }\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> multiplicationResult ;\n    }\n\n    <span class=\"hljs-meta\">@BenchmarkMode(Mode.Throughput)</span>\n    <span class=\"hljs-meta\">@OutputTimeUnit(TimeUnit.MINUTES)</span>\n    <span class=\"hljs-meta\">@Fork(value = 1, warmups = 0)</span>\n    <span class=\"hljs-meta\">@Measurement(time = 1, iterations = 3)</span>\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testMethod</span><span class=\"hljs-params\">(PredefinedState predefinedState)</span> {\n        predefinedState.multiplicationResult = predefinedState.a * predefinedState.b;\n    }\n}\n</code></pre><p>If you still don&#39;t understand please run the benchmark and analyze console output in order to see what&#39;s going on and when.</p><h2>Demo</h2>\n<p>Uff... finally, demo time! After this long introduction, we can do something interesting. Let&#39;s say we want to measure how fast different implementations of methods summing 20000000 longs work. It&#39;s 1 + 2 + 3 +... + 20000000.</p><p>We have 5 contenders (full credit for problem definition goes to <a href=\"https://www.amazon.com/Modern-Java-Action-functional-programming/dp/1617293563\" target=\"_blank\" rel=\"noreferrer\">Modern Java in Action</a> book which I can recommend).</p><p><strong><em>a) iterativeSum()</em></strong></p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">iterativeSum</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1L</span>; i &lt;= N; i++) {\n            result += i;\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\nview raw\n</code></pre><p><strong><em>b) sequentialSum()</em></strong></p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">sequentialSum</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> Stream.iterate(<span class=\"hljs-number\">1L</span>, i -&gt; i + <span class=\"hljs-number\">1</span>)\n                .limit(N)\n                .reduce(<span class=\"hljs-number\">0L</span>, Long::sum);\n    }\n</code></pre><p><strong><em>c) parallelSum()</em></strong></p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">parallelSum</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> Stream.iterate(<span class=\"hljs-number\">1L</span>, i -&gt; i + <span class=\"hljs-number\">1</span>)\n                .parallel()\n                .limit(N)\n                .reduce(<span class=\"hljs-number\">0L</span>, Long::sum);\n    }\n</code></pre><p><strong><em>d) rangedSum()</em></strong></p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">rangedSum</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> LongStream.rangeClosed(<span class=\"hljs-number\">1</span>, N)\n                .reduce(<span class=\"hljs-number\">0L</span>, Long::sum);\n    }\n</code></pre><p><strong><em>e) parallelRangedSum()</em></strong></p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Benchmark</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">parallelRangedSum</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> LongStream.rangeClosed(<span class=\"hljs-number\">1</span>, N)\n                .parallel()\n                .reduce(<span class=\"hljs-number\">0L</span>, Long::sum);\n    }\n</code></pre><p>What do you think which implementation would be the best? We can theorize that implementations 2 and 3 would be slower because of <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\" target=\"_blank\" rel=\"noreferrer\">autoboxing</a>, but let&#39;s see!</p><h2>Results</h2>\n<p>So here are result on my Mac with Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz:</p><p>Setup:</p><img src=\"/images/blog/Screen%2BShot%2B2019-05-25%2Bat%2B14.51.04.png\" alt=\"\">\n\n<p>Measurements:</p><img src=\"/images/blog/Screen%2BShot%2B2019-05-25%2Bat%2B14.50.18.png\" alt=\"\">\n\n<p>Verdict:paralledRangedSum() has won the contest :)</p><p>As a homework you can try to parametrise N and see if parallelRangedSum() is still the best.</p><h2>Further reading</h2>\n<ul>\n<li><a href=\"https://www.amazon.com/Modern-Java-Action-functional-programming/dp/1617293563\" target=\"_blank\" rel=\"noreferrer\">Modern Java in Action</a></li>\n<li><a href=\"https://www.baeldung.com/java-microbenchmark-harness\" target=\"_blank\" rel=\"noreferrer\">https://www.baeldung.com/java-microbenchmark-harness</a></li>\n<li><a href=\"https://github.com/Valloric/jmh-playground\" target=\"_blank\" rel=\"noreferrer\">https://github.com/Valloric/jmh-playground</a></li>\n<li><a href=\"http://tutorials.jenkov.com/java-performance/jmh.html\" target=\"_blank\" rel=\"noreferrer\">http://tutorials.jenkov.com/java-performance/jmh.html</a></li>\n<li><a href=\"https://openjdk.java.net/projects/code-tools/jmh/\" target=\"_blank\" rel=\"noreferrer\">https://openjdk.java.net/projects/code-tools/jmh/</a></li>\n<li><a href=\"https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html\" target=\"_blank\" rel=\"noreferrer\">https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html</a></li>\n<li><a href=\"https://shipilev.net/\" target=\"_blank\" rel=\"noreferrer\">https://shipilev.net</a></li>\n<li><a href=\"https://shipilev.net/talks/jvmls-July2014-benchmarking.mp4\" target=\"_blank\" rel=\"noreferrer\">https://shipilev.net/talks/jvmls-July2014-benchmarking.mp4</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=VaWgOCDBxYw\" target=\"_blank\" rel=\"noreferrer\">https://www.youtube.com/watch?v=VaWgOCDBxYw</a></li>\n<li><a href=\"https://shipilev.net/talks/j1-Oct2011-21682-benchmarking.pdf\" target=\"_blank\" rel=\"noreferrer\">https://shipilev.net/talks/j1-Oct2011-21682-benchmarking.pdf</a></li>\n<li><a href=\"http://leogomes.github.io/assets/JMH_cheatsheet.pdf\" target=\"_blank\" rel=\"noreferrer\">http://leogomes.github.io/assets/JMH_cheatsheet.pdf</a></li>\n</ul>\n"
}