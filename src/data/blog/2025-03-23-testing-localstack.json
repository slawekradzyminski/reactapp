{
  "id": "2025-03-23-testing-localstack",
  "title": "A Comprehensive Local Testing Stack to Hone Your Skills",
  "date": "2025-03-23",
  "category": "Testing",
  "permalink": "/2025/03/comprehensive-local-testing-stack",
  "content": "<img src=\"/images/blog/localstack.png\" alt=\"\">\n\n<p>Among the many tools released in recent years, a robust local environment for testing and experimentation has remained surprisingly elusive. This post introduces a <strong>brand-new local testing stack</strong> that&#39;s both easy to run and advanced enough to challenge testers of all skill levels.</p><p>One frequent struggle for testers is finding an application that&#39;s complex enough to simulate real-world conditions yet not too cumbersome to set up. <strong>This local testing stack</strong> addresses exactly that need—giving you real services, real dependencies, and a variety of features, all configured to run locally via Docker Compose.</p><p>All code is available online for inspection:</p><ul>\n<li><a href=\"https://github.com/slawekradzyminski/vite-react-frontend\" target=\"_blank\" rel=\"noreferrer\">Vite React Frontend</a></li>\n<li><a href=\"https://github.com/slawekradzyminski/awesome-localstack\" target=\"_blank\" rel=\"noreferrer\">Awesome LocalStack</a></li>\n<li><a href=\"https://github.com/slawekradzyminski/test-secure-backend\" target=\"_blank\" rel=\"noreferrer\">Test Secure Backend</a></li>\n</ul>\n<h2>Why Use This Local Testing Stack?</h2>\n<p>Many testing demonstrations rely on trivial examples that don&#39;t mirror genuine production complexities. In contrast, this stack provides:</p><ol>\n<li><strong>Simple Setup</strong>: Just a couple of Docker commands, and you have a fully functioning environment.</li>\n<li><strong>Multiple Services</strong>: A React-based frontend, a Spring Boot backend, a message broker, a local language-model-based assistant, monitoring tools, and more.</li>\n<li><strong>Realistic Features</strong>: User authentication, role-based access, product management, data persistence, asynchronous events, and real-time monitoring.</li>\n<li><strong>Test-Focused Design</strong>: Plenty of endpoints, concurrency possibilities, and advanced flows that let you practice functional, security, performance, and exploratory testing.</li>\n</ol>\n<h2>Architecture Overview</h2>\n<p>The architecture consists of several key components working together:</p><h3>Key Components:</h3>\n<ul>\n<li><strong>Backend</strong>: Spring Boot with JWT authentication, PostgreSQL, and ActiveMQ integration.</li>\n<li><strong>Frontend</strong>: React + Vite for fast builds and a modern UI.</li>\n<li><strong>Email &amp; Messaging</strong>: ActiveMQ for asynchronous tasks, MailHog for email capture.</li>\n<li><strong>Monitoring</strong>: Prometheus &amp; Grafana for performance metrics, plus a WebSocket-based traffic monitor for real-time request logs.</li>\n<li><strong>Local LLM Server</strong>: Explore language-model-based suggestions or text generation without external dependencies.</li>\n<li><strong>Nginx</strong>: Serves static assets, emulating a lightweight CDN.</li>\n</ul>\n<h2>Major Features</h2>\n<p>Below is a quick tour of the built-in features you can test right away:</p><h3>Product Management</h3>\n<ul>\n<li>View, Add, Edit, and Delete products in the system.</li>\n<li>Designed to test CRUD endpoints, concurrency, and validation scenarios.</li>\n</ul>\n<h3>User Management</h3>\n<ul>\n<li>Control user roles (Admin vs. Client) and handle sign-up and sign-in flows.</li>\n<li>Perfect for testing role-based access control and JWT token handling.</li>\n</ul>\n<h3>Order Processing &amp; Profile</h3>\n<ul>\n<li>Place orders, track statuses, manage your profile info, and review order history.</li>\n<li>Exercises cart logic, inventory updates, and state transitions in a realistic setting.</li>\n</ul>\n<h3>Advanced Monitoring: Traffic Monitor</h3>\n<ul>\n<li>A WebSocket-based tool that streams all HTTP requests and responses in real time.</li>\n<li>Ideal for immediate debugging, performance checks, or concurrency validation.</li>\n</ul>\n<h3>LLM Integration</h3>\n<ul>\n<li>LLM Assistant: A local text generator that streams responses via Server-Sent Events (SSE).</li>\n<li>Test how prompts and conversation flows are handled in real time—no external calls required.</li>\n</ul>\n<h3>Utilities</h3>\n<ul>\n<li>QR Code Generator: Generate scannable QR codes for any text or URL.</li>\n<li>Email Service: Submit emails asynchronously and see them delivered after a short delay in MailHog.</li>\n</ul>\n<p>Each feature is substantial enough to challenge testers, providing ample opportunities to practice scenario testing, negative testing, security checks, performance runs, and more.</p><h2>Quick Start Guide</h2>\n<h3>Clone the Repository</h3>\n<p>Access the code here: <a href=\"https://github.com/slawekradzyminski/awesome-localstack\" target=\"_blank\" rel=\"noreferrer\">awesome-localstack</a></p><h3>Spin Up the Full Stack</h3>\n<pre><code class=\"hljs language-bash\">\ndocker compose up\n</code></pre><p>All containers—backend, frontend, database, broker, monitoring, local language-model service, etc.—will start.</p><h3>Check Your Services</h3>\n<ul>\n<li>Backend: <a href=\"http://localhost:4001/swagger-ui/index.html\" target=\"_blank\" rel=\"noreferrer\">http://localhost:4001/swagger-ui/index.html</a></li>\n<li>Frontend: <a href=\"http://localhost:8081/login\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8081/login</a></li>\n<li>Prometheus: <a href=\"http://localhost:9090/\" target=\"_blank\" rel=\"noreferrer\">http://localhost:9090/</a></li>\n<li>Grafana: <a href=\"http://localhost:3000/login\" target=\"_blank\" rel=\"noreferrer\">http://localhost:3000/login</a> (admin/grafana)</li>\n<li>ActiveMQ: <a href=\"http://localhost:8161/\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8161/</a></li>\n<li>MailHog: <a href=\"http://localhost:8025/\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8025/</a></li>\n<li>Local LLM Server: <a href=\"http://localhost:11434/api/tags\" target=\"_blank\" rel=\"noreferrer\">http://localhost:11434/api/tags</a></li>\n</ul>\n<h3>Spin Up the Lightweight Stack</h3>\n<pre><code class=\"hljs language-bash\">\ndocker compose -f lightweight-docker-compose.yml up\n</code></pre><h3>Check Your Services</h3>\n<ul>\n<li>Backend: <a href=\"http://localhost:4001/swagger-ui/index.html\" target=\"_blank\" rel=\"noreferrer\">http://localhost:4001/swagger-ui/index.html</a></li>\n<li>Frontend: <a href=\"http://localhost:8081/login\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8081/login</a></li>\n</ul>\n<h3>Start Exploring</h3>\n<ul>\n<li>Log in with admin or client credentials.</li>\n<li>Try product management flows, experiment with sending emails, or watch the traffic monitor to see every request.</li>\n</ul>\n<h2>Why Testers Should Embrace This Stack</h2>\n<ul>\n<li><strong>Realistic Complexity</strong>: Databases, messaging queues, authentication, and concurrency can all be tested in a single environment.</li>\n<li><strong>Ease of Deployment</strong>: Start and stop all services with Docker—no separate installs needed.</li>\n<li><strong>Built-In Observability</strong>: Track performance and request logs in real time, enabling a deeper understanding of system behavior.</li>\n<li><strong>Safe Environment</strong>: Experiment freely without risking production incidents or incurring external API costs.</li>\n</ul>\n<h2>Potential Test Strategies</h2>\n<p>Here are a few ways you can leverage this stack for testing:</p><h3>Authentication &amp; Authorization</h3>\n<ul>\n<li>Validate role restrictions. Confirm that unauthorized users can&#39;t access admin-specific endpoints.</li>\n<li>Verify token generation, refresh flows, and expiration edge cases.</li>\n</ul>\n<h3>Performance &amp; Load</h3>\n<ul>\n<li>Use k6 (or similar) to generate traffic.</li>\n<li>Monitor metrics in Prometheus/Grafana. Observe concurrency handling in the traffic monitor.</li>\n</ul>\n<h3>Security Checks</h3>\n<ul>\n<li>Look for potential SQL injection or XSS vulnerabilities.</li>\n<li>Attempt unauthorized data access using forged or tampered tokens.</li>\n</ul>\n<h3>Messaging &amp; Asynchronous Flows</h3>\n<ul>\n<li>Place multiple orders quickly to test queue handling in ActiveMQ.</li>\n<li>Inspect MailHog to ensure no email is lost under load or concurrency.</li>\n</ul>\n<h3>Real-Time Monitoring</h3>\n<ul>\n<li>Combine the traffic monitor&#39;s immediate feedback with conventional logs.</li>\n<li>Debug and isolate issues faster by pairing request details with backend logs.</li>\n</ul>\n<h2>Challenging Questions for Testers</h2>\n<ul>\n<li><p>How does the system behave under concurrency when multiple users attempt to update the same product simultaneously?</p><ul>\n<li>Check for race conditions, locked tables, or inconsistent data states in the database.</li>\n</ul>\n</li>\n<li><p>What happens to email requests if ActiveMQ becomes overloaded or temporarily unavailable?</p><ul>\n<li>Will the system retry, queue them up, or fail immediately?</li>\n</ul>\n</li>\n<li><p>Are you able to break or exceed any parameter limits in the product creation endpoints?</p><ul>\n<li>Consider boundary testing for name, price, and quantity.</li>\n</ul>\n</li>\n<li><p>Can you identify areas where load testing reveals performance bottlenecks?</p><ul>\n<li>Use the real-time traffic monitor and Prometheus metrics to pinpoint slow endpoints or resource contention.</li>\n</ul>\n</li>\n<li><p>What does the local language model assistant do if provided with a particularly large or malformed prompt?</p><ul>\n<li>Does the system degrade gracefully or show any unexpected failures?</li>\n</ul>\n</li>\n</ul>\n<h2>Conclusion</h2>\n<p>This local testing stack offers a comprehensive setup to practice and refine your testing strategies. Whether you&#39;re exploring security, performance, or everyday functional testing, you&#39;ll find plenty of scenarios that mimic real-world challenges—without the headache of scattered cloud services or complicated manual configurations.</p><p>Get started by running the stack in Docker, dive into the user flows, check out the monitoring dashboards, and push the system to its limits. The combination of a feature-rich frontend, robust backend, async messaging, database, and local language-model integration ensures there&#39;s always more to discover.</p><p>If you&#39;re looking to take your skills even further, try extending this base environment with additional microservices or custom test frameworks. The sky&#39;s the limit with a self-contained local stack that you can tweak, break, and fix at will. Happy testing!</p>"
}