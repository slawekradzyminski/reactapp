{
  "id": "2018-12-15-continuous-security-with-owasp-zap",
  "title": "Continuous Security with OWASP ZAP",
  "date": "2018-12-15",
  "category": "Security",
  "permalink": "/2018/12/continuous-security-with-owasp-zap",
  "content": "<img src=\"/images/blog/051e0245d787d1f71246d515e88a8564_zap256x256-oversize.png\" alt=\"\">\n\n<p>Referring nicely to &#39;continuous&#39; word in the title I&#39;m following up previous posts about <a href=\"https://www.awesome-testing.com/2017/02/continuous-security-with-owasp.html\" target=\"_blank\" rel=\"noreferrer\">OWASP Dependency Checker</a> and<a href=\"https://www.awesome-testing.com/2018/11/continuous-security-with-find-sec-bugs.html\" target=\"_blank\" rel=\"noreferrer\">Find Sec Bugs</a>by presenting yet another tool which can help ensure security during Continuous Integration (CI) pipeline run - OWASP Zedd Proxy Attack (more popular with OWASP ZAP name).</p><p>OWASP ZAP is one of the world&#39;s most popular free security tools which can help you find security vulnerabilities in your web application. It allows you to catch HTTP traffic via locally configured proxy. Such traffic can then be used to modify requests in order to exploit an app. Tweaks don&#39;t have to be done by a human. There is a possibility to actively scan an app using built-in logic. In this article, I&#39;ll show you how to trigger such actions using Java.</p><p>Usual word of caution: security is a very high-risk area which probably shouldn&#39;t be ensured by tools only. Human penetration testing is advised. For details, I invite you to take a look at my <a href=\"https://www.awesome-testing.com/2017/03/automated-testing-vs-manual-testing.html\" target=\"_blank\" rel=\"noreferrer\">Automated testing vs manual testing - security perspective</a> post where I outlined my thoughts about security testing in details.</p><h2>Prerequisites</h2>\n<p>In order to see OWASP ZAP in action you need few things:</p><p>a) OWASP ZAP</p><ul>\n<li>Download it from<a href=\"https://github.com/zaproxy/zaproxy/wiki/Downloads\" target=\"_blank\" rel=\"noreferrer\">Github</a></li>\n<li>Run it</li>\n<li>Configure proxy: Tools -&gt; Options -&gt; Local Proxies. Set port to 8888</li>\n</ul>\n<p>b) Vulnerable application - system under test</p><ul>\n<li>Install docker and run docker service</li>\n<li>Run <a href=\"https://hub.docker.com/r/psiinon/bodgeit/\" target=\"_blank\" rel=\"noreferrer\">bodgeit docker container</a>(or any app<a href=\"https://github.com/psiinon/bodgeit\" target=\"_blank\" rel=\"noreferrer\">)</a></li>\n<li>Make sure it&#39;s running on <a href=\"http://localhost:8080/bodgeit/\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8080/bodgeit/</a></li>\n</ul>\n<p>c) Selenium code</p><ul>\n<li>Download my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a></li>\n<li>Get API key from your ZAP instance: Tools -&gt; Options -&gt; API</li>\n<li>Update <code>ZAP_API_KEY</code> in ZapApi class</li>\n<li>I&#39;m skipping Chrome, chromedriver, Maven, SDK, and other Selenium-related setups as I&#39;ve covered it already multiple times in <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">multiple GUI automation posts</a>.</li>\n</ul>\n<h2>High-level view</h2>\n<p>The following image visualizes what&#39;s going to happen:</p><img src=\"/images/blog/Przechwytywanie3.PNG\" alt=\"\">\n\n<p>Selenium traffic will go through ZAP proxy in order to capture all traffic. It&#39;s not exactly necessary for the bodgeit shop, but in real-world applications spider would struggle to find URLs requiring logged in access.</p><p>After Selenium run spidering, passive &amp; active scanning will be triggered via <a href=\"https://github.com/zaproxy/zaproxy/wiki/ApiDetails\" target=\"_blank\" rel=\"noreferrer\">ZAP API</a>. In order to increase code readability, I created an interface.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ZapFunctionalities</span> {\n\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSpidering</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ClientApiException, InterruptedException;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doPassiveScan</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ClientApiException, InterruptedException;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doActiveScan</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ClientApiException, InterruptedException;\n\n}\n</code></pre><p>Before we move on into practice, some necessary theory from <a href=\"https://github.com/zaproxy/zap-core-help\" target=\"_blank\" rel=\"noreferrer\">ZAP User Guide</a>.</p><p>a) Spider</p><p>A spider is a tool that is used to automatically discover new resources (URLs) on a particular Site. It begins with a list of URLs to visit, called the seeds, which depends on how the Spider is started. The Spider then visits these URLs, it identifies all the hyperlinks in the page and adds them to the list of URLs to visit and the process continues recursively as long as new resources are found.</p><p>b) Passive Scan</p><p>ZAP by default passively scans all HTTP messages (requests and responses) sent to the web application being tested. Passive scanning does not change the requests nor the responses in any way and is, therefore, safe to use. Scanning is performed in a background thread to ensure that it does not slow down the exploration of an application.</p><p>c) Active Scan</p><p>Active scanning attempts to find potential vulnerabilities by using known attacks against the selected targets. Active scanning is an attack on those targets. You should NOT use it on web applications that you do not own. It should be noted that active scanning can only find certain types of vulnerabilities. Logical vulnerabilities, such as broken access control, will not be found by any active or automated vulnerability scanning.</p><h2>Selenium setup</h2>\n<p>In order to use OWASP ZAP, you have to configure a local proxy for functional tests. Thankfully, I have already covered such topic in my <a href=\"https://www.awesome-testing.com/2018/01/how-to-use-automated-functional-tests.html\" target=\"_blank\" rel=\"noreferrer\">How to use automated functional tests to drive your testing efforts post</a>. In addition to Selenium config, there is also a Rest-Assured example (API tests can be used to capture traffic as well).</p><p>The following snippet shows a brief summary of what needs to be done for Selenium tests using chromedriver. Chrome needs to know about proxy so an additional flag is required.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">public</span> WebDriver <span class=\"hljs-title function_\">newWebDriver</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChromeDriver</span>(getChromeOptions());\n    }\n\n    <span class=\"hljs-keyword\">private</span> ChromeOptions <span class=\"hljs-title function_\">getChromeOptions</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">ChromeOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ChromeOptions</span>();\n        options.addArguments(getChromeSwitches());\n        <span class=\"hljs-keyword\">return</span> options;\n    }\n\n    <span class=\"hljs-keyword\">private</span> List&lt;String&gt; <span class=\"hljs-title function_\">getChromeSwitches</span><span class=\"hljs-params\">()</span> {\n        List&lt;String&gt; chromeSwitches = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n        chromeSwitches.add(<span class=\"hljs-string\">&quot;--proxy-server=http://localhost:8888&quot;</span>);\n        chromeSwitches.add(<span class=\"hljs-string\">&quot;--ignore-certificate-errors&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> chromeSwitches;\n    }\n</code></pre><p>Seleniums I have written as an example are pretty dumb. They just crawl the page.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@PageUrl(&quot;http://localhost:8080/bodgeit/&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggedOutHomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">FluentPage</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">crawlSiteToSimulateSeleniumTraffic</span><span class=\"hljs-params\">()</span> {\n        el(By.linkText(<span class=\"hljs-string\">&quot;Home&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;Doodahs&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;Zip a dee doo dah&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;About Us&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;Scoring page&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;Your Basket&quot;</span>)).click();\n        el(By.linkText(<span class=\"hljs-string\">&quot;Search&quot;</span>)).click();\n    }\n}\n</code></pre><p>They crawl logged in pages as well.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Test</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">loggedOutCrawl</span><span class=\"hljs-params\">()</span> {\n        goTo(loggedOutHomePage).crawlSiteToSimulateSeleniumTraffic();\n    }\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">loggedInCrawl</span><span class=\"hljs-params\">()</span> {\n        goTo(registerPage).registerUser(USERNAME, PASSWORD);\n        goTo(loginPage).login(USERNAME, PASSWORD);\n        goTo(loggedInHomePage).crawlPageToSimulateSeleniumTraffic();\n    }\n</code></pre><p>If you have done everything right you should now see a couple of requests on ZAP GUI.</p><img src=\"/images/blog/owaspzap.PNG\" alt=\"\">\n\n<h2>ZAP API</h2>\n<p>Time to move on into actual OWASP ZAP stuff. There is Java ZAP API client library available. Add it as a dependency first.</p><pre><code class=\"hljs language-plaintext\">\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.zaproxy&lt;/groupId&gt;\n            &lt;artifactId&gt;zap-clientapi&lt;/artifactId&gt;\n            &lt;version&gt;1.6.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre><p>Its syntax is quite lengthy so I decided to create two util classes: one for ZAP tasks (see interface above) and one for API calls.</p><p>This is how ZAP task implementation looks like:</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doActiveScan</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ClientApiException, InterruptedException {\n        System.out.println(<span class=\"hljs-string\">&quot;Active scanning started.&quot;</span>);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">activeScanTaskId</span> <span class=\"hljs-operator\">=</span> zapApi.getActiveScanTaskId();\n        <span class=\"hljs-type\">int</span> progress;\n        <span class=\"hljs-keyword\">do</span> {\n            Thread.sleep(<span class=\"hljs-number\">5000</span>);\n            progress = zapApi.getActiveScanProgress(activeScanTaskId);\n            System.out.println(<span class=\"hljs-string\">&quot;Active Scan progress : &quot;</span> + progress + <span class=\"hljs-string\">&quot;%&quot;</span>);\n        } <span class=\"hljs-keyword\">while</span> (progress &lt; <span class=\"hljs-number\">100</span>);\n        System.out.println(<span class=\"hljs-string\">&quot;Active Scan complete&quot;</span>);\n    }\n</code></pre><p>As you can see we get taskId from API and then periodically check it&#39;s progress. Polling time seems big at first look (5 seconds), but active scanning is a very lengthy process which can take even hours. It&#39;s recommended that such security tests should be executed daily during nighttime. Not only time but also the high amount of traffic would quickly discourage you from adding them into a functional regression test suite.</p><p>JAVA API client is a bit awkward, but you can always rewrite it to Spring Template and do not use provided library.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getActiveScanProgress</span><span class=\"hljs-params\">(String taskId)</span> <span class=\"hljs-keyword\">throws</span> ClientApiException {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">status</span> <span class=\"hljs-operator\">=</span> ((ApiResponseElement) api.ascan.status(taskId)).getValue();\n        <span class=\"hljs-keyword\">return</span> Integer.parseInt(status);\n    }\n</code></pre><h2>Demo</h2>\n<p>After an extremely long journey with lots of coding and configuration (I even had to enable virtualization in BIOS in order to use Docker in Windows) the security test is ready. It looks nice:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SecurityTest</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">TARGET</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;http://localhost:8080/bodgeit&quot;</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">ZapApi</span> <span class=\"hljs-variable\">zapApi</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ZapApi</span>(TARGET);\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Zap</span> <span class=\"hljs-variable\">zap</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Zap</span>(zapApi);\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">zapSecurityTest</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ClientApiException, InterruptedException {\n        zap.doSpidering();\n        zap.doPassiveScan();\n        zap.doActiveScan();\n\n        zapApi.generateHtmlReport(<span class=\"hljs-string\">&quot;report.html&quot;</span>);\n\n        assertThat(zapApi.getNumberOfAlerts()).isZero();\n    }\n}\n</code></pre><p>It&#39;s up to you whether you want to use assertions or simply read the final report.</p><p><a href=\"https://htmlpreview.github.io/?https://github.com/slawekradzyminski/AwesomeTesting/blob/50435473147b6a90964ea8c0832f453ee3414c69/src/test/resources/report.html\" target=\"_blank\" rel=\"noreferrer\">An example report can be viewed here</a>.</p><h2>Other sources</h2>\n<ul>\n<li>Scanning job implemented in bash and SSL handling can be found in <a href=\"https://www.owasp.org/images/2/27/OWASPLondon-OWASP-ZAP-Selenium-20180830-PDF.pdf\" target=\"_blank\" rel=\"noreferrer\">OWASP London slides pack</a>.</li>\n<li>My code was based on <a href=\"https://github.com/zaproxy/zap-api-java/blob/develop/subprojects/zap-clientapi/src/examples/java/org/zaproxy/clientapi/examples/SimpleExample.java\" target=\"_blank\" rel=\"noreferrer\">an official example</a>, but with lots of refactoring</li>\n<li><a href=\"https://github.com/continuumsecurity\" target=\"_blank\" rel=\"noreferrer\">Continuumsecurity</a> has two projects - <a href=\"https://github.com/continuumsecurity/zap-webdriver\" target=\"_blank\" rel=\"noreferrer\">zap-webdriver</a> and <a href=\"https://github.com/continuumsecurity/bdd-security\" target=\"_blank\" rel=\"noreferrer\">bdd-security</a>, but approach and libraries are totally different</li>\n<li>New book -<a href=\"https://www.amazon.com/Hands-Security-DevOps-continuous-deployment-ebook/dp/B07FNXVKCH\" target=\"_blank\" rel=\"noreferrer\">Hands-On Security in DevOps</a> short Continuous Security chapter</li>\n<li><a href=\"https://sekurak.pl/wprowadzenie-do-narzedzia-zed-attack-proxy-zap/\" target=\"_blank\" rel=\"noreferrer\">Sekurak</a> has a comprehensive introduction to OWASP ZAP (polish only, sorry English-speaking readers)</li>\n</ul>\n"
}