{
  "id": "2018-12-15-continuous-security-with-owasp-zap",
  "title": "Continuous Security with OWASP ZAP",
  "date": "2018-12-15",
  "categories": [
    "Security"
  ],
  "tags": [
    "security"
  ],
  "permalink": "/2018/12/continuous-security-with-owasp-zap",
  "content": "<p><img src=\"/images/blog/051e0245d787d1f71246d515e88a8564_zap256x256-oversize.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Referring nicely to &#39;continuous&#39; word in the title I&#39;m following up previous posts<br>about <a href=\"https://www.awesome-testing.com/2017/02/continuous-security-with-owasp.html\" target=\"_blank\" rel=\"noreferrer\">OWASP Dependency Checker</a><br>and<a href=\"https://www.awesome-testing.com/2018/11/continuous-security-with-find-sec-bugs.html\" target=\"_blank\" rel=\"noreferrer\">Find Sec Bugs</a>by presenting yet<br>another tool which can help ensure security during Continuous Integration (CI) pipeline run - OWASP Zedd Proxy Attack (<br>more popular with OWASP ZAP name).</p>\n<p>OWASP ZAP is one of the worldâ€™s most popular free security tools which can help you find security vulnerabilities in<br>your web application. It allows you to catch HTTP traffic via locally configured proxy. Such traffic can then be used to<br>modify requests in order to exploit an app. Tweaks don&#39;t have to be done by a human. There is a possibility to actively<br>scan an app using built-in logic. In this article, I&#39;ll show you how to trigger such actions using Java.</p>\n<p>Usual word of caution: security is a very high-risk area which probably shouldn&#39;t be ensured by tools only. Human<br>penetration testing is advised. For details, I invite you to take a look at<br>my <a href=\"https://www.awesome-testing.com/2017/03/automated-testing-vs-manual-testing.html\" target=\"_blank\" rel=\"noreferrer\">Automated testing vs manual testing - security perspective</a><br>post where I outlined my thoughts about security testing in details.</p>\n<h2>Prerequisites</h2>\n<p>In order to see OWASP ZAP in action you need few things:</p>\n<p>a) OWASP ZAP</p>\n<ul>\n<li>Download it from<a href=\"https://github.com/zaproxy/zaproxy/wiki/Downloads\" target=\"_blank\" rel=\"noreferrer\">Github</a></li>\n<li>Run it</li>\n<li>Configure proxy: Tools -&gt; Options -&gt; Local Proxies. Set port to 8888</li>\n</ul>\n<p>b) Vulnerable application - system under test</p>\n<ul>\n<li>Install docker and run docker service</li>\n<li>Run <a href=\"https://hub.docker.com/r/psiinon/bodgeit/\" target=\"_blank\" rel=\"noreferrer\">bodgeit docker container</a>(or any<br>app<a href=\"https://github.com/psiinon/bodgeit\" target=\"_blank\" rel=\"noreferrer\">)</a></li>\n<li>Make sure it&#39;s running on <a href=\"http://localhost:8080/bodgeit/\" target=\"_blank\" rel=\"noreferrer\">http://localhost:8080/bodgeit/</a></li>\n</ul>\n<p>c) Selenium code</p>\n<ul>\n<li>Download my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a></li>\n<li>Get API key from your ZAP instance: Tools -&gt; Options -&gt; API</li>\n<li>Update <code>ZAP_API_KEY</code> in ZapApi class</li>\n<li>I&#39;m skipping Chrome, chromedriver, Maven, SDK, and other Selenium-related setups as I&#39;ve covered it already multiple<br>times in <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">multiple GUI automation posts</a>.</li>\n</ul>\n<h2>High-level view</h2>\n<p>The following image visualizes what&#39;s going to happen:</p>\n<p><img src=\"/images/blog/Przechwytywanie3.PNG\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Selenium traffic will go through ZAP proxy in order to capture all traffic. It&#39;s not exactly necessary for the bodgeit<br>shop, but in real-world applications spider would struggle to find URLs requiring logged in access.</p>\n<p>After Selenium run spidering, passive &amp; active scanning will be triggered<br>via <a href=\"https://github.com/zaproxy/zaproxy/wiki/ApiDetails\" target=\"_blank\" rel=\"noreferrer\">ZAP API</a>. In order to increase code readability, I created an<br>interface.</p>\n<pre><code class=\"language-java\">public interface ZapFunctionalities {\n\n    void doSpidering() throws ClientApiException, InterruptedException;\n    void doPassiveScan() throws ClientApiException, InterruptedException;\n    void doActiveScan() throws ClientApiException, InterruptedException;\n\n}\n</code></pre>\n<p>Before we move on into practice, some necessary theory from <a href=\"https://github.com/zaproxy/zap-core-help\" target=\"_blank\" rel=\"noreferrer\">ZAP User Guide</a>.</p>\n<p>a) Spider</p>\n<p>A spider is a tool that is used to automatically discover new resources (URLs) on a particular Site. It begins with a<br>list of URLs to visit, called the seeds, which depends on how the Spider is started. The Spider then visits these URLs,<br>it identifies all the hyperlinks in the page and adds them to the list of URLs to visit and the process continues<br>recursively as long as new resources are found.</p>\n<p>b) Passive Scan</p>\n<p>ZAP by default passively scans all HTTP messages (requests and responses) sent to the web application being tested.<br>Passive scanning does not change the requests nor the responses in any way and is, therefore, safe to use. Scanning is<br>performed in a background thread to ensure that it does not slow down the exploration of an application.</p>\n<p>c) Active Scan</p>\n<p>Active scanning attempts to find potential vulnerabilities by using known attacks against the selected targets. Active<br>scanning is an attack on those targets. You should NOT use it on web applications that you do not own. It should be<br>noted that active scanning can only find certain types of vulnerabilities. Logical vulnerabilities, such as broken<br>access control, will not be found by any active or automated vulnerability scanning.</p>\n<h2>Selenium setup</h2>\n<p>In order to use OWASP ZAP, you have to configure a local proxy for functional tests. Thankfully, I have already covered<br>such topic in<br>my <a href=\"https://www.awesome-testing.com/2018/01/how-to-use-automated-functional-tests.html\" target=\"_blank\" rel=\"noreferrer\">How to use automated functional tests to drive your testing efforts post</a>.<br>In addition to Selenium config, there is also a Rest-Assured example (API tests can be used to capture traffic as well).</p>\n<p>The following snippet shows a brief summary of what needs to be done for Selenium tests using chromedriver. Chrome needs<br>to know about proxy so an additional flag is required.</p>\n<pre><code class=\"language-java\">public WebDriver newWebDriver() {\n        return new ChromeDriver(getChromeOptions());\n    }\n\n    private ChromeOptions getChromeOptions() {\n        ChromeOptions options = new ChromeOptions();\n        options.addArguments(getChromeSwitches());\n        return options;\n    }\n\n    private List&lt;String&gt; getChromeSwitches() {\n        List&lt;String&gt; chromeSwitches = new ArrayList&lt;&gt;();\n        chromeSwitches.add(&quot;--proxy-server=http://localhost:8888&quot;);\n        chromeSwitches.add(&quot;--ignore-certificate-errors&quot;);\n        return chromeSwitches;\n    }\n</code></pre>\n<p>Seleniums I have written as an example are pretty dumb. They just crawl the page.</p>\n<pre><code class=\"language-java\">@PageUrl(&quot;http://localhost:8080/bodgeit/&quot;)\npublic class LoggedOutHomePage extends FluentPage {\n\n    public void crawlSiteToSimulateSeleniumTraffic() {\n        el(By.linkText(&quot;Home&quot;)).click();\n        el(By.linkText(&quot;Doodahs&quot;)).click();\n        el(By.linkText(&quot;Zip a dee doo dah&quot;)).click();\n        el(By.linkText(&quot;About Us&quot;)).click();\n        el(By.linkText(&quot;Scoring page&quot;)).click();\n        el(By.linkText(&quot;Your Basket&quot;)).click();\n        el(By.linkText(&quot;Search&quot;)).click();\n    }\n}\n</code></pre>\n<p>They crawl logged in pages as well.</p>\n<pre><code class=\"language-java\">@Test\n        public void loggedOutCrawl() {\n        goTo(loggedOutHomePage).crawlSiteToSimulateSeleniumTraffic();\n    }\n\n    @Test\n    public void loggedInCrawl() {\n        goTo(registerPage).registerUser(USERNAME, PASSWORD);\n        goTo(loginPage).login(USERNAME, PASSWORD);\n        goTo(loggedInHomePage).crawlPageToSimulateSeleniumTraffic();\n    }\n</code></pre>\n<p>If you have done everything right you should now see a couple of requests on ZAP GUI.</p>\n<p><img src=\"/images/blog/owaspzap.PNG\" alt=\"\" style=\"width: 100%;\"></p>\n<h2>ZAP API</h2>\n<p>Time to move on into actual OWASP ZAP stuff. There is Java ZAP API client library available. Add it as a dependency<br>first.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.zaproxy&lt;/groupId&gt;\n            &lt;artifactId&gt;zap-clientapi&lt;/artifactId&gt;\n            &lt;version&gt;1.6.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Its syntax is quite lengthy so I decided to create two util classes: one for ZAP tasks (see interface above) and one for<br>API calls.</p>\n<p>This is how ZAP task implementation looks like:</p>\n<pre><code class=\"language-java\">@Override\n    public void doActiveScan() throws ClientApiException, InterruptedException {\n        System.out.println(&quot;Active scanning started.&quot;);\n        String activeScanTaskId = zapApi.getActiveScanTaskId();\n        int progress;\n        do {\n            Thread.sleep(5000);\n            progress = zapApi.getActiveScanProgress(activeScanTaskId);\n            System.out.println(&quot;Active Scan progress : &quot; + progress + &quot;%&quot;);\n        } while (progress &lt; 100);\n        System.out.println(&quot;Active Scan complete&quot;);\n    }\n</code></pre>\n<p>As you can see we get taskId from API and then periodically check it&#39;s progress. Polling time seems big at first look (5<br>seconds), but active scanning is a very lengthy process which can take even hours. It&#39;s recommended that such security<br>tests should be executed daily during nighttime. Not only time but also the high amount of traffic would quickly<br>discourage you from adding them into a functional regression test suite.</p>\n<p>JAVA API client is a bit awkward, but you can always rewrite it to Spring Template and do not use provided library.</p>\n<pre><code class=\"language-java\">public int getActiveScanProgress(String taskId) throws ClientApiException {\n        String status = ((ApiResponseElement) api.ascan.status(taskId)).getValue();\n        return Integer.parseInt(status);\n    }\n</code></pre>\n<h2>Demo</h2>\n<p>After an extremely long journey with lots of coding and configuration (I even had to enable virtualization in BIOS in<br>order to use Docker in Windows) the security test is ready. It looks nice:</p>\n<pre><code class=\"language-java\">public class SecurityTest {\n\n    private static final String TARGET = &quot;http://localhost:8080/bodgeit&quot;;\n\n    private ZapApi zapApi = new ZapApi(TARGET);\n    private Zap zap = new Zap(zapApi);\n\n    @Test\n    public void zapSecurityTest() throws ClientApiException, InterruptedException {\n        zap.doSpidering();\n        zap.doPassiveScan();\n        zap.doActiveScan();\n\n        zapApi.generateHtmlReport(&quot;report.html&quot;);\n\n        assertThat(zapApi.getNumberOfAlerts()).isZero();\n    }\n}\n</code></pre>\n<p>It&#39;s up to you whether you want to use assertions or simply read the final report.</p>\n<p><a href=\"https://htmlpreview.github.io/?https://github.com/slawekradzyminski/AwesomeTesting/blob/50435473147b6a90964ea8c0832f453ee3414c69/src/test/resources/report.html\" target=\"_blank\" rel=\"noreferrer\">An example report can be viewed here</a>.</p>\n<h2>Other sources</h2>\n<ul>\n<li>Scanning job implemented in bash and SSL handling can be found<br>in <a href=\"https://www.owasp.org/images/2/27/OWASPLondon-OWASP-ZAP-Selenium-20180830-PDF.pdf\" target=\"_blank\" rel=\"noreferrer\">OWASP London slides pack</a>.</li>\n<li>My code was based<br>on <a href=\"https://github.com/zaproxy/zap-api-java/blob/develop/subprojects/zap-clientapi/src/examples/java/org/zaproxy/clientapi/examples/SimpleExample.java\" target=\"_blank\" rel=\"noreferrer\">an official example</a>,<br>but with lots of refactoring</li>\n<li><a href=\"https://github.com/continuumsecurity\" target=\"_blank\" rel=\"noreferrer\">Continuumsecurity</a> has two<br>projects - <a href=\"https://github.com/continuumsecurity/zap-webdriver\" target=\"_blank\" rel=\"noreferrer\">zap-webdriver</a><br>and <a href=\"https://github.com/continuumsecurity/bdd-security\" target=\"_blank\" rel=\"noreferrer\">bdd-security</a>, but approach and libraries are totally different</li>\n<li>New<br>book -<a href=\"https://www.amazon.com/Hands-Security-DevOps-continuous-deployment-ebook/dp/B07FNXVKCH\" target=\"_blank\" rel=\"noreferrer\">Hands-On Security in DevOps</a><br>short Continuous Security chapter</li>\n<li><a href=\"https://sekurak.pl/wprowadzenie-do-narzedzia-zed-attack-proxy-zap/\" target=\"_blank\" rel=\"noreferrer\">Sekurak</a> has a comprehensive introduction to<br>OWASP ZAP (polish only, sorry English-speaking readers)</li>\n</ul>\n"
}