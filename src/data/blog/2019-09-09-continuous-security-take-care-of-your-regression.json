{
  "id": "2019-09-09-continuous-security-take-care-of-your-regression",
  "title": "Continuous Security - take care of your regression",
  "date": "2019-09-09",
  "categories": [
    "Security"
  ],
  "tags": [
    "security",
    "API testing"
  ],
  "permalink": "/2019/09/continuous-security-take-care-of-your",
  "content": "<p><img src=\"/images/blog/photo-1519575706483-221027bfbb31.jpeg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>In my<br>last &#39;<a href=\"https://www.awesome-testing.com/2019/08/continuous-security-how-to-get-involved.html\" target=\"_blank\" rel=\"noreferrer\">Continuous Security - how to get involved</a>?&#39;<br>post I showed you quickstart guide on how to start helping your team in reaching the desired security level. The article<br>contained simple <a href=\"https://www.awesome-testing.com/2018/12/continuous-security-with-owasp-zap.html\" target=\"_blank\" rel=\"noreferrer\">OWASP ZAP</a> scanning<br>technique and very<br>easy <a href=\"https://www.awesome-testing.com/2016/07/restful-api-testing-with-rest-assured-1.html\" target=\"_blank\" rel=\"noreferrer\">Rest Assured</a> tests which<br>were ensuring HTTP headers presence. Today I&#39;ll focus on yet another avenue where testers can excel: regression testing.</p>\n<p>Software testing can never prove that application under test contains no bugs. Even if we spend a significant amount of<br>time doing all things correctly, bugs may still get through. It&#39;s a good practice to add automated tests which check<br>that bugs found on production can never happen again. Security bugs are no different. Once detected, they should never<br>happen again.</p>\n<p>As usual, there will be a practical demo explaining a theory in action.</p>\n<h2>OWASP Juice Shop</h2>\n<p><a href=\"https://www.owasp.org/index.php/OWASP_Juice_Shop_Project\" target=\"_blank\" rel=\"noreferrer\">OWASP Juice Shop</a> will be an application under test.<br>According to the official description, it&#39;s the most modern and sophisticated insecure web application. It can be used<br>in security training, awareness demos, CTFs and as a guinea pig for security tools. Juice Shop encompasses<br>vulnerabilities from the entire <a href=\"https://www.owasp.org/index.php/OWASP_Top_Ten\" target=\"_blank\" rel=\"noreferrer\">OWASP Top Ten</a>along with many other<br>security flaws found in real-world applications.</p>\n<p>WARNING: This article contains spoilers for existing vulnerabilities in Juice Shop. If you prefer to find them by<br>yourself come back here later.</p>\n<h2>Rest Template</h2>\n<p>Just to change things a bit we will use Spring Rest Template. If you are not familiar with this library I<br>recommend <a href=\"https://www.baeldung.com/rest-template\" target=\"_blank\" rel=\"noreferrer\">Baeldung tutorial</a>. A more complete description can be found<br>in <a href=\"https://www.amazon.com/Spring-Action-Craig-Walls/dp/1617294942\" target=\"_blank\" rel=\"noreferrer\">Spring in Action</a> book.</p>\n<p>To start we need to add a couple of dependencies:</p>\n<p>a) <a href=\"https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/integration.html#rest-client-access\" target=\"_blank\" rel=\"noreferrer\">Spring web</a><br>for core Rest Template methods</p>\n<p>b) <a href=\"https://github.com/FasterXML/jackson\" target=\"_blank\" rel=\"noreferrer\">Jackson</a> for Java JSON serialization</p>\n<p>c) <a href=\"https://github.com/stleary/JSON-java\" target=\"_blank\" rel=\"noreferrer\">JSON-Java</a></p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n&lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n&lt;version&gt;5.1.9.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n            &lt;version&gt;2.9.9.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n            &lt;version&gt;2.9.9&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.json&lt;/groupId&gt;\n            &lt;artifactId&gt;json&lt;/artifactId&gt;\n            &lt;version&gt;20190722&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Each test will require simple setup. Juice Shop runs on default port 3000.</p>\n<pre><code class=\"language-java\">private RestTemplate restTemplate;\n\n    @Before\n    public void setUp() {\n        restTemplate = new RestTemplate();\n        restTemplate.setUriTemplateHandler(\n                new DefaultUriBuilderFactory(&quot;http://localhost:3000&quot;));\n    }\n</code></pre>\n<h2>Vulnerability a - client-side error</h2>\n<p>The secure application should never show internal errors to end-user. It does not only create a terrible user experience<br>for the customer but also leaves a risk of exposing sensitive data. Attacker benefits a lot in such a situation because<br>he can understand what&#39;s going on internally on server-side.</p>\n<p>When we try to log in as an inexisting user we receive HTTP 401 which is correct.</p>\n<pre><code class=\"language-java\">@Test\npublic void shouldNotBeAbleToLoginOnInexisingUser() {\nLoginDto loginDto = new LoginDto(INVALID_LOGIN, PASSWORD);\nHttpEntity&lt;LoginDto&gt; body = new HttpEntity&lt;&gt;(loginDto);\nassertThatThrownBy(() -&gt; restTemplate.postForEntity(LOGIN_ENDPOINT, body, String.class))\n.isInstanceOf(HttpClientErrorException.class)\n.hasMessageContaining(&quot;401 Unauthorized&quot;);\n}\n</code></pre>\n<p>However when we use &#39; as login server responds with HTTP 500 and exposes implementation details.</p>\n<p><img src=\"/images/blog/error_js-console.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>The following test reproduces this vulnerability:</p>\n<pre><code class=\"language-java\">private static final String REDIRECTION_URL = &quot;https://awesome-testing.com&quot;;\n\n    @Test\n    public void shouldNotFollowRedirectWithWhitelistedUrl() {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrlWithWhitelistedUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(&quot;406 Not Acceptable&quot;);\n    }\n\n    private String getRedirectionUrlWithWhitelistedUrl() {\n        return String.format(\n            &quot;/redirect?to=%s?pwned=https://github.com/bkimminich/juice-shop&quot;, REDIRECTION_URL);\n    }\n</code></pre>\n<h2>Vulnerability b - open redirect</h2>\n<p>Juice shop allows for redirection on a whitelisted <a href=\"https://github.com/bkimminich/juice-shop\" target=\"_blank\" rel=\"noreferrer\">GitHub page</a>. When we try<br>to change this URL application correctly blocks us with HTTP 406.</p>\n<pre><code class=\"language-java\">private static final String REDIRECTION_URL = &quot;https://awesome-testing.com&quot;;\n\n    @Test\n    public void shouldNotFollowRedirect() {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(&quot;406 Not Acceptable&quot;);\n    }\n\n    private String getRedirectionUrl() {\n        return String.format(&quot;/redirect?to=%s&quot;, REDIRECTION_URL);\n    }\n</code></pre>\n<p>Unfortunately whitelisting isn&#39;t implemented on <em>to</em> parameter but on any of them. Adding a dummy parameter meeting<br>whitelisting criteria results in redirection to any website.</p>\n<p>The following test reproduces this vulnerability:</p>\n<pre><code class=\"language-java\">private static final String REDIRECTION_URL = &quot;https://awesome-testing.com&quot;;\n\n    @Test\n    public void shouldNotFollowRedirectWithWhitelistedUrl() {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrlWithWhitelistedUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(&quot;406 Not Acceptable&quot;);\n    }\n\n    private String getRedirectionUrlWithWhitelistedUrl() {\n        return String.format(\n            &quot;/redirect?to=%s?pwned=https://github.com/bkimminich/juice-shop&quot;, REDIRECTION_URL);\n    }\n</code></pre>\n<h2>Vulnerability 3 - admin access</h2>\n<p>The last vulnerability is probably the worst one. An attacker can prepare JSON request which will register him as shop<br>admin. Only a couple of Java code lines are required!</p>\n<pre><code class=\"language-java\">@Test\npublic void shouldNotBeAbleToRegisterAsAdmin() {\nAdminRegisterDto adminRegisterDto = new AdminRegisterDto();\nJSONObject jsonObj = new JSONObject(adminRegisterDto);\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity&lt;String&gt; body = new HttpEntity&lt;&gt;(jsonObj.toString(), headers);\n\n        assertThatThrownBy(\n                () -&gt; restTemplate.postForEntity(&quot;/api/Users&quot;, body, AdminRegisterResultDto.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(&quot;401 Unauthorized&quot;);\n    }\n</code></pre>\n<h2>Summary</h2>\n<p>I didn&#39;t delve too deep into why those bugs exist (although it&#39;s perfectly reasonable for you to do a root cause<br>analysis in a similar situation) or how those tests implementation (details on<br>my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a>). I just wanted to you show a certain mindset.<br>If there is a bug on production you should think how to avoid it next time, but also add a regression tests just to make<br>sure it never happens again. For security bugs there is an additional benefit, you expand your knowledge in much-needed<br>field!</p>\n"
}