{
  "id": "2019-09-09-continuous-security-take-care-of-your-regression",
  "title": "Continuous Security - take care of your regression",
  "date": "2019-09-09",
  "category": "Security",
  "permalink": "/2019/09/continuous-security-take-care-of-your",
  "content": "<img src=\"/images/blog/photo-1519575706483-221027bfbb31.jpeg\" alt=\"\">\n\n<p>In my last &#39;<a href=\"https://www.awesome-testing.com/2019/08/continuous-security-how-to-get-involved.html\" target=\"_blank\" rel=\"noreferrer\">Continuous Security - how to get involved</a>?&#39; post I showed you quickstart guide on how to start helping your team in reaching the desired security level. The article contained simple <a href=\"https://www.awesome-testing.com/2018/12/continuous-security-with-owasp-zap.html\" target=\"_blank\" rel=\"noreferrer\">OWASP ZAP</a> scanning technique and very easy <a href=\"https://www.awesome-testing.com/2016/07/restful-api-testing-with-rest-assured-1.html\" target=\"_blank\" rel=\"noreferrer\">Rest Assured</a> tests which were ensuring HTTP headers presence. Today I&#39;ll focus on yet another avenue where testers can excel: regression testing.</p><p>Software testing can never prove that application under test contains no bugs. Even if we spend a significant amount of time doing all things correctly, bugs may still get through. It&#39;s a good practice to add automated tests which check that bugs found on production can never happen again. Security bugs are no different. Once detected, they should never happen again.</p><p>As usual, there will be a practical demo explaining a theory in action.</p><h2>OWASP Juice Shop</h2>\n<p><a href=\"https://www.owasp.org/index.php/OWASP_Juice_Shop_Project\" target=\"_blank\" rel=\"noreferrer\">OWASP Juice Shop</a> will be an application under test. According to the official description, it&#39;s the most modern and sophisticated insecure web application. It can be used in security training, awareness demos, CTFs and as a guinea pig for security tools. Juice Shop encompasses vulnerabilities from the entire <a href=\"https://www.owasp.org/index.php/OWASP_Top_Ten\" target=\"_blank\" rel=\"noreferrer\">OWASP Top Ten</a>along with many other security flaws found in real-world applications.</p><p>WARNING: This article contains spoilers for existing vulnerabilities in Juice Shop. If you prefer to find them by yourself come back here later.</p><h2>Rest Template</h2>\n<p>Just to change things a bit we will use Spring Rest Template. If you are not familiar with this library I recommend <a href=\"https://www.baeldung.com/rest-template\" target=\"_blank\" rel=\"noreferrer\">Baeldung tutorial</a>. A more complete description can be found in <a href=\"https://www.amazon.com/Spring-Action-Craig-Walls/dp/1617294942\" target=\"_blank\" rel=\"noreferrer\">Spring in Action</a> book.</p><p>To start we need to add a couple of dependencies:</p><p>a) <a href=\"https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/integration.html#rest-client-access\" target=\"_blank\" rel=\"noreferrer\">Spring web</a> for core Rest Template methods</p><p>b) <a href=\"https://github.com/FasterXML/jackson\" target=\"_blank\" rel=\"noreferrer\">Jackson</a> for Java JSON serialization</p><p>c) <a href=\"https://github.com/stleary/JSON-java\" target=\"_blank\" rel=\"noreferrer\">JSON-Java</a></p><pre><code class=\"hljs language-plaintext\">\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.9.3&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.9&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.json&lt;/groupId&gt;\n    &lt;artifactId&gt;json&lt;/artifactId&gt;\n    &lt;version&gt;20190722&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre><p>Each test will require simple setup. Juice Shop runs on default port 3000.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">private</span> RestTemplate restTemplate;\n\n    <span class=\"hljs-meta\">@Before</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setUp</span><span class=\"hljs-params\">()</span> {\n        restTemplate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();\n        restTemplate.setUriTemplateHandler(\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultUriBuilderFactory</span>(<span class=\"hljs-string\">&quot;http://localhost:3000&quot;</span>));\n    }\n\n</code></pre><h2>Vulnerability a - client-side error</h2>\n<p>The secure application should never show internal errors to end-user. It does not only create a terrible user experience for the customer but also leaves a risk of exposing sensitive data. Attacker benefits a lot in such a situation because he can understand what&#39;s going on internally on server-side.</p><p>When we try to log in as an inexisting user we receive HTTP 401 which is correct.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@Test</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldNotBeAbleToLoginOnInexisingUser</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">LoginDto</span> <span class=\"hljs-variable\">loginDto</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoginDto</span>(INVALID_LOGIN, PASSWORD);\n    HttpEntity&lt;LoginDto&gt; body = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpEntity</span>&lt;&gt;(loginDto);\n    assertThatThrownBy(() -&gt; restTemplate.postForEntity(LOGIN_ENDPOINT, body, String.class))\n        .isInstanceOf(HttpClientErrorException.class)\n        .hasMessageContaining(<span class=\"hljs-string\">&quot;401 Unauthorized&quot;</span>);\n}\n</code></pre><p>However when we use &#39; as login server responds with HTTP 500 and exposes implementation details.</p><img src=\"/images/blog/error_js-console.png\" alt=\"\">\n\n<p>The following test reproduces this vulnerability:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">REDIRECTION_URL</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://awesome-testing.com&quot;</span>;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldNotFollowRedirectWithWhitelistedUrl</span><span class=\"hljs-params\">()</span> {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrlWithWhitelistedUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(<span class=\"hljs-string\">&quot;406 Not Acceptable&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getRedirectionUrlWithWhitelistedUrl</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> String.format(\n            <span class=\"hljs-string\">&quot;/redirect?to=%s?pwned=https://github.com/bkimminich/juice-shop&quot;</span>, REDIRECTION_URL);\n    }\n\n</code></pre><h2>Vulnerability b - open redirect</h2>\n<p>Juice shop allows for redirection on a whitelisted <a href=\"https://github.com/bkimminich/juice-shop\" target=\"_blank\" rel=\"noreferrer\">GitHub page</a>. When we try to change this URL application correctly blocks us with HTTP 406.</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">REDIRECTION_URL</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://awesome-testing.com&quot;</span>;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldNotFollowRedirect</span><span class=\"hljs-params\">()</span> {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(<span class=\"hljs-string\">&quot;406 Not Acceptable&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getRedirectionUrl</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> String.format(<span class=\"hljs-string\">&quot;/redirect?to=%s&quot;</span>, REDIRECTION_URL);\n    }\n\n</code></pre><p>Unfortunately whitelisting isn&#39;t implemented on <em>to</em> parameter but on any of them. Adding a dummy parameter meeting whitelisting criteria results in redirection to any website.</p><p>The following test reproduces this vulnerability:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">REDIRECTION_URL</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://awesome-testing.com&quot;</span>;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldNotFollowRedirectWithWhitelistedUrl</span><span class=\"hljs-params\">()</span> {\n        assertThatThrownBy(\n            () -&gt; restTemplate.getForEntity(getRedirectionUrlWithWhitelistedUrl(), String.class))\n                .isInstanceOf(HttpClientErrorException.class)\n                .hasMessageContaining(<span class=\"hljs-string\">&quot;406 Not Acceptable&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title function_\">getRedirectionUrlWithWhitelistedUrl</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> String.format(\n            <span class=\"hljs-string\">&quot;/redirect?to=%s?pwned=https://github.com/bkimminich/juice-shop&quot;</span>, REDIRECTION_URL);\n    }\n\n</code></pre><h2>Vulnerability 3 - admin access</h2>\n<p>The last vulnerability is probably the worst one. An attacker can prepare JSON request which will register him as shop admin. Only a couple of Java code lines are required!</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@Test</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldNotBeAbleToRegisterAsAdmin</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">AdminRegisterDto</span> <span class=\"hljs-variable\">adminRegisterDto</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AdminRegisterDto</span>();\n    <span class=\"hljs-type\">JSONObject</span> <span class=\"hljs-variable\">jsonObj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JSONObject</span>(adminRegisterDto);\n\n    <span class=\"hljs-type\">HttpHeaders</span> <span class=\"hljs-variable\">headers</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpHeaders</span>();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n    HttpEntity&lt;String&gt; body = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpEntity</span>&lt;&gt;(jsonObj.toString(), headers);\n\n    assertThatThrownBy(\n        () -&gt; restTemplate.postForEntity(<span class=\"hljs-string\">&quot;/api/Users&quot;</span>, body, AdminRegisterResultDto.class))\n            .isInstanceOf(HttpClientErrorException.class)\n            .hasMessageContaining(<span class=\"hljs-string\">&quot;401 Unauthorized&quot;</span>);\n    }\n\n</code></pre><h2>Summary</h2>\n<p>I didn&#39;t delve too deep into why those bugs exist (although it&#39;s perfectly reasonable for you to do a root cause analysis in a similar situation) or how those tests implementation (details on my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a>). I just wanted to you show a certain mindset.</p><p>If there is a bug on production you should think how to avoid it next time, but also add a regression tests just to make sure it never happens again. For security bugs there is an additional benefit, you expand your knowledge in much-needed field!</p>"
}