{
  "id": "2018-09-25-how-to-speed-up-your-tests-in-one-simple-step",
  "title": "How to speed up your tests in one simple step",
  "date": "2018-09-25",
  "categories": [
    "CI/CD"
  ],
  "tags": [
    "CI/CD",
    "testing tools"
  ],
  "permalink": "/2018/09/how-to-speed-up-your-tests-in-one",
  "content": "<p><img src=\"/images/blog/traffic-car-vehicle-black.jpg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Every tester<br>with <a href=\"https://www.awesome-testing.com/2017/01/testops-4-continuous-improvement.html\" target=\"_blank\" rel=\"noreferrer\">Continuous Improvement</a> mindset<br>cares about overall test execution time. We aim for quick feedback loops ending before developer switches to another<br>task. This is not always easy as projects becomes bigger and bigger, teams focus on delivering new features and other<br>issues receive higher priority.</p>\n<p>Today I&#39;d like to present you a very simple way of speeding up your tests. Most of the times we try to introduce test<br>parallelism on code level. Unfortunately that&#39;s usually very costly and hard to implement. Often we end up with<br>complicated code that resolves our timing problems, but introduces new issues (increased code maintenance costs, flaky<br>tests, timing problems, random test dependencies).</p>\n<p>Approach presented here is different. Instead of costly software test parallelism we multiply test environments and<br>split tests by basic regex (or <a href=\"https://github.com/isaacs/node-glob#glob-primer\" target=\"_blank\" rel=\"noreferrer\">Globs</a> for Javascript).</p>\n<h2>Concept</h2>\n<p>Idea is very simple. We spawn multiple test environment instances (ideally using lightweight Dockers) and execute only<br>arbitrary percent of full test suite. In my example I split the tests by name. First suite execute tests matched by<br>[a-m]* pattern and the second suite is running tests matched by [n-z]* pattern. This should theoretically create<br>split close to 50-50.</p>\n<h2>Implementation</h2>\n<p>In order to give you better view on how it works I prepared complete Continuous Integration job definition<br>using <a href=\"https://about.gitlab.com/features/gitlab-ci-cd/\" target=\"_blank\" rel=\"noreferrer\">Gitlab CI</a> .gitlab-ci.yml file. First example is from Java<br>world (<a href=\"https://maven.apache.org/\" target=\"_blank\" rel=\"noreferrer\">Maven</a>) and the second one is from Javascript<br>world (<a href=\"http://node.js/\" target=\"_blank\" rel=\"noreferrer\">Node.js</a>, <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noreferrer\">npm</a>, <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noreferrer\">mocha</a>).</p>\n<h3>Java example</h3>\n<pre><code class=\"language-yaml\">image: maven:3-jdk-8\n\nstages:\n  - build\n  - test\n\ncompile:\n  stage: build\n  script:\n    - mvn -U -B clean compile\n\ntests-am:\n  stage: test\n  script:\n    - echo &#39;[A-M] TESTS&#39;\n    - mvn -U -B test -Dtest=&#39;%regex[.*/[A-M].*Test.class]&#39;\n\ntests-nz:\n  stage: test\n  script:\n    - echo &#39;[N-Z] TESTS&#39;\n    - mvn -U -B test -Dtest=&#39;%regex[.*/[N-Z].*Test.class]&#39;\n</code></pre>\n<p>To those unfamiliar with Gitlab CI few words of explanation. This is <a href=\"http://yaml.org/\" target=\"_blank\" rel=\"noreferrer\">YAML</a> file that stores our<br>Continuous Integration job definition. First line (image) defines Docker container which will be pulled from Docker<br>registry at the beginning. We get official maven image which guarantees us that <em>mvn</em> command is working properly. Next<br>the application code is downloaded inside a container and scipt starts.</p>\n<p>We split the tasks into two stages. First stage (build) contains only one job: execute &#39;<em>mvn -U -B clean compile</em>&#39;<br>command. Remember that we want to detect failures as soon as possible, so compilation is our first quality gate.</p>\n<p>If first stage succeeds we move into phase two (test). This time though tasks start simultaneously. Two set of tests (<br>matched by regex) are executed on the same time.</p>\n<h3>Javascript example</h3>\n<pre><code class=\"language-yaml\">image: node:10\n\nstages:\n  - test\n\ntests-am:\n  stage: test\n  script:\n    - npm install\n    - echo &#39;[A-M] TESTS&#39;\n    - mocha &quot;server-test/[a-m]*/**/*.js&quot;\n\ntests-nz:\n  stage: test\n  script:\n    - npm install\n    - echo &#39;[N-Z] TESTS&#39;\n    - mocha &quot;server-test/[n-z]*/**/*.js&quot;\n</code></pre>\n<p>This time we have only one stage (test). Each one use mocha to run ~50% of tests present in server-test folder.</p>\n<h2>Conclusion</h2>\n<p>This simple trick shortens overall test execution time and provides us with faster feedback. Please note that this<br>solution is also scalable (by adding new Docker and splitting test suite into more separate chunks).</p>\n"
}