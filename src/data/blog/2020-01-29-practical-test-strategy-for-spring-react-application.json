{
  "id": "2020-01-29-practical-test-strategy-for-spring-react-application",
  "title": "Practical test strategy for Spring & React application",
  "date": "2020-01-29",
  "category": "Test strategy",
  "permalink": "/2020/01/practical-test-strategy-for-spring",
  "content": "<img src=\"/images/blog/photo-1523875194681-bedd468c58bf.jpeg\" alt=\"\">\n\n<p>There are two leading approaches for tests: isolated and end to end (E2E). As usual, both approaches have upsides and downsides, and it&#39;s impossible to say which one is better. Everything is dependent on application context and architecture.</p><p>There are though few guidelines which can be followed most of the time:</p><ul>\n<li>high test coverage should be achieved for a single application. Other parts of the system (i.e. connected<br>microservices) should be stubbed/mocked</li>\n<li>important business cases should be tested in the E2E manner without any mocks. E2E tests should give us a high amount<br>of confidence that our system will work on the production</li>\n<li>isolated tests should make up the majority of your overall test count</li>\n<li>E2E test count should be low because they may<br>be <a href=\"https://testing.googleblog.com/2017/04/where-do-our-flaky-tests-come-from.html\" target=\"_blank\" rel=\"noreferrer\">flaky</a></li>\n</ul>\n<p>It remains to be seen whether contract tests would make a list of best practices. I certainly recommend adding them to the list.</p><p>Enough of theory, let&#39;s move into applying it in real life.</p><h3>System overview</h3>\n<p>Let&#39;s say we want to test a very simple system with:</p><p>a) <a href=\"https://github.com/slawekradzyminski/vistulasampleapi\" target=\"_blank\" rel=\"noreferrer\">Spring Boot backendÂ </a></p><p>b) <a href=\"https://github.com/slawekradzyminski/reactfrontend\" target=\"_blank\" rel=\"noreferrer\">React frontend</a></p><p>To complicate things a bit let&#39;s also assume that our backend is interacting with external API served by the other service (which we have limited control of).</p><img src=\"/images/blog/Screenshot%2B2020-01-18%2Bat%2B12.41.12.png\" alt=\"\">\n\n<p>The application I wrote is very simple, it only allows to CRUD (create, read, update, delete) a user but it&#39;s about to overcome Facebook soon as the most popular social media platform so we need to prepare a comprehensive test strategy.</p><img src=\"/images/blog/Screenshot%2B2020-01-18%2Bat%2B12.16.13.png\" alt=\"\">\n\n<h3>Functional test strategy</h3>\n<p>We need the following functional tests:</p><ul>\n<li>Isolated API tests with external API mocked<br>using <a href=\"https://www.awesome-testing.com/2017/12/get-rid-of-your-external-dependencies.html\" target=\"_blank\" rel=\"noreferrer\">Wiremock</a> (<br>or <a href=\"http://www.mock-server.com/\" target=\"_blank\" rel=\"noreferrer\">MockServer</a>). All tests should be written using<br>standard <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html\" target=\"_blank\" rel=\"noreferrer\">libraries provided by Spring</a></li>\n<li>Isolated <a href=\"https://www.valentinog.com/blog/testing-react/\" target=\"_blank\" rel=\"noreferrer\">React components tests</a> (+ actions, reducers, views, hooks,<br>etc.)</li>\n<li>Isolated <a href=\"https://github.com/slawekradzyminski/PactExample\" target=\"_blank\" rel=\"noreferrer\">Pact contract tests</a> (external API &lt;-&gt; our API)</li>\n<li>Isolated <a href=\"https://github.com/slawekradzyminski/PactExample\" target=\"_blank\" rel=\"noreferrer\">Pact contract tests</a> (our API &lt;-&gt; our frontend)</li>\n<li>Isolated <a href=\"https://www.cypress.io/\" target=\"_blank\" rel=\"noreferrer\">Cypress GUI tests</a></li>\n<li>E2E <a href=\"https://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">Selenium tests</a> covering business cases with no mocks</li>\n</ul>\n<p>Isolated tests should be in the same repository as applications, and they should run in pipelines after each commit. For E2E tests we need a separate repository. They should run as often as possible. Results should be recorded and displayed on a screen placed in a visible area.</p><p>For simplicity let&#39;s assume we are not covering non-functional characteristics at this point.</p><h3>Non-functional test strategy</h3>\n<p>We need the following performance tests:</p><ul>\n<li>Our API backend should be tested in isolation with tools like<a href=\"https://gatling.io/\" target=\"_blank\" rel=\"noreferrer\">Gatling</a><br>or<a href=\"https://locust.io/\" target=\"_blank\" rel=\"noreferrer\">Locust</a>. JMeter is not recommended because we want to store performance tests as a code</li>\n<li>We measure website performance using Lighthouse on test environment and production. Results should be recorded and<br>displayed on a screen placed in a visible area.</li>\n</ul>\n<p>In the beginning, we assume that the application should handle 100 simultaneous users. Tests should prove that we can handle 200.</p>"
}