{
  "id": "2019-03-28-selenium-page-object-pattern-how-to-handle-common-components",
  "title": "Selenium Page Object Pattern - how to handle common components?",
  "date": "2019-03-28",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium"
  ],
  "permalink": "/2019/03/selenium-page-object-pattern-how-to",
  "content": "<p><img src=\"/images/blog/photo-1522542550221-31fd19575a2d.jpeg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Page Object Pattern (POP) is probably the most widely adopted Selenium design pattern in the world. It has one very<br>simple principle: every action (method), field (page element) available for a user on a single page should be<br>implemented in one place (class). This class is popularly called Page Object.</p>\n<p>Unfortunately, this overly simplified definition often causes confusion because it’s incomplete. In order to make it<br>more precise, we have to add that Page Object represents fields and methods available on this page exclusively. Every<br>piece of shared logic (header, footer, sidebars) should be stored in separate classes. Let’s call those shared elements<br>components from now on.</p>\n<p>Imagine a very simple website that has multiple pages using a common template with certain components. All Page Objects<br>using this template should represent functionalities available only in non-shared space (see image below).</p>\n<p><img src=\"/images/blog/Screen%2BShot%2B2019-03-29%2Bat%2B17.20.17.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Page Object should cover only the orange section. Header, footer and sidebar should be implemented as separate entities<br>which can be accessed by each page class.</p>\n<h2>Task definition</h2>\n<p>Now imagine you are a tester responsible for testing such a website from scratch. The project is new and promising so<br>every test design decision you make today can have a significant impact tomorrow, next year, and maybe even 10 years<br>from now. How would you do it?</p>\n<p>To make things more realistic let’s also say that there is one page which doesn’t have a sidebar and we expect to create<br>more pages with various templates soon.</p>\n<h2>Inheritance</h2>\n<p>The first and probably the most straightforward choice is inheritance. Inheritance is an important pillar of Object<br>Oriented Programming (OOP). It is the mechanism by which one class (called subclass) is allowed to inherit the<br>features (fields and methods) of another class (called superclass).</p>\n<p>In order to use inheritance, we would create an abstract class containing every component.</p>\n<pre><code class=\"language-java\">public abstract class TemplatePage {\n\n    protected Header header = new Header();\n    protected Sidebar sidebar = new Sidebar();\n    protected Footer footer = new Footer();\n\n}\n</code></pre>\n<p>Each of our pages would be a subclass extending TemplatePage with components actions available via inheritance.</p>\n<pre><code class=\"language-java\">public class MainPage extends TemplatePage {\n\n    public void logout() {\n        header.clickLogout();\n    }\n}\n</code></pre>\n<h2>Composition</h2>\n<p>As usual, when it comes to development every problem can have multiple solutions. One of the alternatives is<br>composition. The composition is a &quot;has-a&quot; relationship. You do composition by having an instance of another class as a<br>field of your class, instead of inheriting it.</p>\n<p>With inheritance, our code would most likely look similar to this simplified implementation.</p>\n<pre><code class=\"language-java\">public class MainPage {\n\n    private Header header;\n    private Footer footer;\n    private Sidebar sidebar;\n\n    public MainPage() {\n        this.footer = new Footer();\n        this.sidebar = new Sidebar();\n        this.header = new Header();\n    }\n\n    public void logout() {\n        header.clickLogout();\n    }\n\n}\n</code></pre>\n<h2>Why is composition better than inheritance?</h2>\n<p>Having all that in mind, let&#39;s think which approach should we choose to complete a task defined in point 2?</p>\n<p>If it was the year 2000 most likely inheritance approach would be much better. Unfortunately, modern websites can change<br>on an almost daily basis and having one core template class can be now considered obsolete.</p>\n<p>Even when it comes to our task I have mentioned that one page doesn&#39;t have a sidebar. Should this page object extend<br>TemplatePage? Or should we create a separate template for this class? What if TemplatePage has multiple utility methods<br>we want to reuse? It would be tempting to rely on this single template forever. In reality with inheritance sooner or<br>later we end up with page objects having access to field/methods which shouldn&#39;t be there. That&#39;s a fundamental design<br>flaw.</p>\n<p>Composition gives flexibility. Each page object has to have explicitly defined components it wants to rely on. We don&#39;t<br>have to worry about surplus code available just because we extend the superclass.</p>\n<h2>Dependency Injection (DI)</h2>\n<p>Modern Java code relies mostly on composition with one very important tweak - Dependency Injection (DI). In software<br>engineering, dependency injection is a technique whereby one object (or static method) supplies the dependencies of<br>another object. A dependency is an object that can be used (a service).</p>\n<p>Dependency Injection frameworks like Spring uses Java reflection to make our lives easier. We don&#39;t have to create every<br>object by ourselves. Instead, we can rely on an external library. This is how our MainPage will look like with DI.</p>\n<pre><code class=\"language-java\">public class MainPage {\n\n    @Inject\n    private Header header;\n\n    @Inject\n    private Footer footer;\n\n    @Inject\n    private Sidebar sidebar;\n\n    public MainPage() {\n    }\n\n    public void logout() {\n        header.clickLogout();\n    }\n\n}\n</code></pre>\n<h2>Explaining FluentLenium component</h2>\n<p>This long introduction leads us slowly to my main point - FluentLenium component demonstration.</p>\n<p>First of all fundamental POP support provided by Selenium - only Page Object elements can be found by @FindBy<br>annotation. They are not injected - we have to initialize them using initElements() method</p>\n<pre><code class=\"language-java\">public PageObject(WebDriver driver) {\n        this.driver = driver;\n        PageFactory.initElements(driver, this);\n    }\n</code></pre>\n<p>Components handling has to be implemented by a test developer separately using inheritance or composition. This is<br>visualized below.</p>\n<p><img src=\"/images/blog/Screen%2BShot%2B2019-03-30%2Bat%2B16.42.07.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>With <a href=\"https://fluentlenium.com/\" target=\"_blank\" rel=\"noreferrer\">FluentLenium framework</a>, life is much easier for a test developer. FluentLenium treats<br>custom Components in the same way as WebElements (wrapped by FluentWebElemet class) and injects them dynamically when<br>needed. This fixes the fundamental POP flaw described in point one. We can finally implement Page Object as full-page<br>visible for the customer perspective.</p>\n<p>The image below shows the difference comparing to standard Selenium.</p>\n<p><img src=\"/images/blog/Screen%2BShot%2B2019-03-30%2Bat%2B21.47.28.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>For those who prefer actual implementation here is Page Object example:</p>\n<pre><code class=\"language-java\">@PageUrl(&quot;https://fluentlenium.com&quot;)\npublic class MainPage extends FluentPage {\n\n    @FindBy(css = &quot;div.sidebar&quot;)\n    private Sidebar sidebar;\n\n    @FindBy(css = &quot;div.footer&quot;)\n    private Footer footer;\n\n    @FindBy(css = &quot;nav&quot;)\n    private Header header;\n\n    @FindBy(className = &quot;whats-fluentlenium&quot;)\n    private FluentWebElement mainContent;\n\n    public void assertThatPageIsLoaded() {\n        assertThat(mainContent).isDisplayed();\n    }\n\n    public Header getHeader() {\n        return header;\n    }\n\n}\n</code></pre>\n<h2>Demo</h2>\n<p>As usual, I have prepared a working demo for my readers. Complete code together with a working project can be found<br>on <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">my GitHub</a>.</p>\n<p>We are going to test <a href=\"https://fluentlenium.com/\" target=\"_blank\" rel=\"noreferrer\">FluentLenium.com</a>website with the following header:</p>\n<pre><code class=\"language-java\">public class Header extends FluentWebElement {\n\n    @FindBy(css = &quot;nav ul li:nth-of-type(1)&quot;)\n    private FluentWebElement homeLink;\n\n    @FindBy(css = &quot;nav ul li:nth-of-type(2)&quot;)\n    private FluentWebElement quickstartLink;\n\n    @FindBy(css = &quot;nav ul li:nth-of-type(5)&quot;)\n    private FluentWebElement aboutLink;\n\n    public Header(WebElement element, FluentControl control, ComponentInstantiator instantiator) {\n        super(element, control, instantiator);\n    }\n\n    public MainPage clickHomeLink() {\n        homeLink.click();\n        return newInstance(MainPage.class);\n    }\n\n    public QuickStartPage clickQuickstartLink() {\n        quickstartLink.click();\n        return newInstance(QuickStartPage.class);\n    }\n\n    public AboutPage clickAboutLink() {\n        aboutLink.click();\n        return newInstance(AboutPage.class);\n    }\n\n}\n</code></pre>\n<p>Constructor implementation may seem a bit complicated, but it&#39;s automatically generated by IDE (like IntelliJ) when we<br>extend FluentWebElement class.</p>\n<p>In order to use such component we only have to inject it by @FindBy annotation to any Page Object:</p>\n<pre><code class=\"language-java\">@PageUrl(&quot;https://fluentlenium.com&quot;)\npublic class MainPage extends FluentPage {\n\n    @FindBy(css = &quot;div.sidebar&quot;)\n    private Sidebar sidebar;\n\n    @FindBy(css = &quot;div.footer&quot;)\n    private Footer footer;\n\n    @FindBy(css = &quot;nav&quot;)\n    private Header header;\n\n    @FindBy(className = &quot;whats-fluentlenium&quot;)\n    private FluentWebElement mainContent;\n\n    public void assertThatPageIsLoaded() {\n        assertThat(mainContent).isDisplayed();\n    }\n\n    public Header getHeader() {\n        return header;\n    }\n</code></pre>\n<p>And finally tests using FirefoxDriver() and Full HD resolution</p>\n<pre><code class=\"language-java\">public class ComponentTest extends FluentTest {\n\n    private static final Dimension FULL_HD = new Dimension(1920, 1080);\n\n    @Page\n    private QuickStartPage quickStartPage;\n\n    @Page\n    private MainPage mainPage;\n\n    @Before\n    public void setUp() {\n        getDriver().manage().window().setSize(FULL_HD);\n    }\n\n    @Override\n    public WebDriver newWebDriver() {\n        return new FirefoxDriver();\n    }\n\n    @Test\n    public void quickStartLink() {\n        mainPage.go();\n        mainPage.assertThatPageIsLoaded();\n\n        mainPage.getHeader()\n                .clickQuickstartLink()\n                .assertThatPageIsLoaded();\n    }\n\n    @Test\n    public void homeLink() {\n        quickStartPage.go();\n        quickStartPage.assertThatPageIsLoaded();\n\n        quickStartPage.getHeader()\n                .clickHomeLink()\n                .assertThatPageIsLoaded();\n    }\n\n    @Test\n    public void shouldShowSlawomir() {\n        mainPage.go();\n        mainPage.assertThatPageIsLoaded();\n\n        mainPage.getHeader()\n                .clickAboutLink()\n                .assertThatPageIsLoaded()\n                .verifySlawomirPresence();\n    }\n\n}\n</code></pre>\n<p>Please let me know if you have any questions.</p>\n"
}