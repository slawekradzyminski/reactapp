{
  "id": "2020-04-13-android-testing-tools",
  "title": "Android testing tools",
  "date": "2020-04-13",
  "category": "Mobile testing",
  "permalink": "/2020/04/android-testing-tools",
  "content": "<img src=\"/images/blog/android-robot-vector.jpg\" alt=\"\">\n\n<p>I&#39;m pretty sure everyone has heard about the test pyramid. Famous Google testing blog <a href=\"https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html\" target=\"_blank\" rel=\"noreferrer\">article</a> suggests a 70/20/10 split: 70% unit tests, 20% integration tests, and 10% end-to-end (E2E) tests.</p><p>The question is, how does it map to Android native app testing? In my article, I&#39;ll familiarize you with multiple Android tools that may enhance your testing skills. To get the most of them it&#39;s important to understand where are they placed on the test pyramid.</p><p><strong>Android test pyramid</strong></p><p>In a typical Android project, there are two places for tests:</p><ul>\n<li>test package - non-instrumented tests requiring JVM only to run. This folder contains standard JUnit unit tests and Roboelectric scenarios using Android simulator underneath</li>\n<li>androidTest package - instrumented tests which require both JVM and physical or emulated device. This folder contains Espresso and UI Automator tests</li>\n</ul>\n<img src=\"/images/blog/akhFNsmGnK3r0aLGcxgS4HS3qRVoLHgq4REVTCcJ35RO2PyIJCAHXb5foMJR4HYRPE-Eiz-Et3AHipBXTanwXQbhP48TWMTGEmSKVysxl97VDeqUceimjpKZ2XJ_TWsjUXbvpN4TeQc\" alt=\"\">\n\n<p>Additionally, you can also have E2E Appium tests in a separate repository (outside your project).</p><p>The mapping of those tools on the standard test pyramid isn&#39;t straightforward. Roboelectric tests verify integration.<br>Similarly, UIAutomator allows you to run E2E scenarios. Here is how the visualization looks like:</p><img src=\"/images/blog/LG9HGHuem9DyWnJqPbJ66oHJwjf3KN0r1aa17iDaQpm2lxksSrk5VE3DFxmYAXp2yCcJcvibXwXcUosjSUz3N2OCvKpsnbhVKda8RKd2vFQFtYZhM9oGaMrCmsybYFmhOfLzKsgqTCw\" alt=\"\">\n\n<p>Now I&#39;m going to describe what each tool allows you to test.<br></p><p><strong>Junit (unit tests)</strong></p><p>Whenever you plan your tests you should start from the units. They&#39;re the fastest, the cheapest, and the most flexible.<br>Android is no exception here. Unfortunately, unit testing Android project is surprisingly complicated. Why? Unit tests are in close relationship with a tested app. Usually, good architecture is testable, meaning writing unit tests is easy.<br>How about Android app architecture? Let&#39;s take a look at the popular approach: VIPER.</p><p>In VIPER we split our classes into five distinct logic parts:</p><ul>\n<li>The_View_corresponds to an Activity or Fragment in the app.* The_Interactor_performs actions requested by the<br>                                                         Presenter.</li>\n<li>The_Presenter_is the app command center. it commands actions, forces View display, and Router navigation.</li>\n<li>The_Entity_represents the app data.</li>\n<li>The_Router_handles navigation.</li>\n</ul>\n<img src=\"/images/blog/6mjOFgyCIz0V6FLgc1m1gZP0aCLLDG9xnl6dvKcMr6hwSICST4bADYwpyo8sjdgsNQn6v2D950z9wetPWkqyJlXigivLPC6n31L9crY27Q_lbWLHcsQxUS7YHGhu_Vga45ZqKdtan5o\" alt=\"\">\n\n<p>Classes marked by blue color have no dependencies on the Android platform code. With proper implementation, you should be able to test them without excessive use of mocks.</p><p>On the other hand, green classes do depend on the core Android code (Activity, Context, SharedPreferences, and more).<br>They are very hard to test on a unit level without relying too much on <a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noreferrer\">Mockito</a> (or Kotlin <a href=\"https://mockk.io/\" target=\"_blank\" rel=\"noreferrer\">Mockk</a>). Even worse, a lot of Android core methods are static meaning that <a href=\"https://powermock.github.io/\" target=\"_blank\" rel=\"noreferrer\">PowerMock</a> may be required.</p><p>This is why Android developers usually like to write clean tests on higher levels, for example using Roboelectric.</p><p><strong>Roboelectric (non-instrumented integration tests)</strong></p><p>In simple words, <a href=\"http://robolectric.org/\" target=\"_blank\" rel=\"noreferrer\">Roboelectric</a> is an Android simulator. It allows you to run UI-like tests on JVM only, meaning they&#39;re cheap, fast, reliable, and excellent for Continuous Integration (CI) systems. Robolectric handles inflation of views, resource loading, and lots of other stuff that’s implemented in native C code on Android devices. This allows tests to do most things you could do on a real device.</p><p>Since Robolectric 4.0, Espresso APIs are now supported in Robolectric tests. Even more, you can have shared test implementation for both Roboelectric and Espresso as in the following <a href=\"https://github.com/slawekradzyminski/Kotlin-Espresso-sample\" target=\"_blank\" rel=\"noreferrer\">GitHub example</a>.</p><p>Below you can find an example non-instrumented Roboelectric test:</p><pre><code class=\"hljs language-typescript\">\n<span class=\"hljs-keyword\">import</span> androidx.<span class=\"hljs-property\">test</span>.<span class=\"hljs-property\">espresso</span>.<span class=\"hljs-property\">Espresso</span>.<span class=\"hljs-property\">onView</span>\n\n<span class=\"hljs-meta\">@RunWith</span>(<span class=\"hljs-title class_\">AndroidJUnit4</span>::<span class=\"hljs-keyword\">class</span>)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddContactActivityTest</span> {\n\n    <span class=\"hljs-meta\">@Test</span> fun <span class=\"hljs-title function_\">inputTextShouldBeRetainedAfterActivityRecreation</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-comment\">// GIVEN</span>\n        val contactName = <span class=\"hljs-string\">&quot;Test User&quot;</span>\n        val scenario = launchActivity&lt;<span class=\"hljs-title class_\">AddContactActivity</span>&gt;()\n\n        <span class=\"hljs-comment\">// WHEN</span>\n        <span class=\"hljs-comment\">// Enter contact name</span>\n        <span class=\"hljs-title function_\">onView</span>(<span class=\"hljs-title function_\">withId</span>(R.<span class=\"hljs-property\">id</span>.<span class=\"hljs-property\">contact_name_text</span>)).<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-title function_\">typeText</span>(contactName))\n        <span class=\"hljs-comment\">// Destroy and recreate Activity</span>\n        scenario.<span class=\"hljs-title function_\">recreate</span>()\n\n        <span class=\"hljs-comment\">// THEN</span>\n        <span class=\"hljs-comment\">// Check contact name was preserved.</span>\n        <span class=\"hljs-title function_\">onView</span>(<span class=\"hljs-title function_\">withId</span>(R.<span class=\"hljs-property\">id</span>.<span class=\"hljs-property\">contact_name_text</span>)).<span class=\"hljs-title function_\">check</span>(<span class=\"hljs-title function_\">matches</span>(<span class=\"hljs-title function_\">withText</span>(contactName)))\n     }\n}\n</code></pre><p>It looks pretty much like Espresso test, isn&#39;t it?</p><p><strong>Espresso (instrumented integration tests)</strong></p><p>Espresso tests are excellent for collaboration between Test Engineers and Android Developers. They are very fun to create because we see our actual app in action on an emulator or physical device. Espresso allows you to test one app only.</p><p>You may be wondering why Espresso tests are on the integration level. UI tests shouldn&#39;t be here, right? Well, not exactly. To understand why we need to take a look into how Android Activity works.</p><img src=\"/images/blog/eGaXXCeUufyrbYI95PVuur5RyajIB0S3KF1_2143e_3xNhxL4t1zqbdUio4Y-26IXLkkeCqjrPVZjZisBba5c_E8MaSt5JsoGCdgkxBgPUjZJjTZi2hh_vvhmVVQqK46tVX5Mjevra8\" alt=\"\">\n\n<p>Whenever there is a screen change on Android device Android OS is involved. Each app sends startActivity(Intent) to Activity Manager and it decides what to do next. We have two types on Intents:</p><ul>\n<li>Explicit Intent tells Android OS which Activity on which app should be opened</li>\n<li>Implicit Intent tells OS what we would like to do (for example open navigation) and OS decides which app should be<br>opened</li>\n</ul>\n<p>Espresso allows opening any Activity you want so you can start your test on the first, second, middle, or even last screen. Assuming you test the eCommerce app, you can write tests that open the order summary only. Some Activities require Bundle of data. In Espresso you can insert it manually.</p><p>What if our app integrates with other apps via Implicit Intents? They can be easily mocked in Mockito-like way.</p><p>Below you can find an example of Espresso test which mocks Intents:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@Test</span> fun <span class=\"hljs-title function_\">activityResult_DisplaysContactsPhoneNumber</span><span class=\"hljs-params\">()</span> {\n<span class=\"hljs-comment\">// Build the result to return when the activity is launched.</span>\n<span class=\"hljs-type\">val</span> <span class=\"hljs-variable\">resultData</span> <span class=\"hljs-operator\">=</span> Intent()\n<span class=\"hljs-type\">val</span> <span class=\"hljs-variable\">phoneNumber</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;123-345-6789&quot;</span>\nresultData.putExtra(<span class=\"hljs-string\">&quot;phone&quot;</span>, phoneNumber)\n<span class=\"hljs-type\">val</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> Instrumentation.ActivityResult(Activity.RESULT_OK, resultData)\n\n    <span class=\"hljs-comment\">// Set up result stubbing when an intent sent to &quot;contacts&quot; is seen.</span>\n    intending(toPackage(<span class=\"hljs-string\">&quot;com.android.contacts&quot;</span>)).respondWith(result)\n\n    <span class=\"hljs-comment\">// User action that results in &quot;contacts&quot; activity being launched.</span>\n    <span class=\"hljs-comment\">// Launching activity expects phoneNumber to be returned and displayed.</span>\n    onView(withId(R.id.pickButton)).perform(click())\n\n    <span class=\"hljs-comment\">// Assert that the data we set up above is shown.</span>\n    onView(withId(R.id.phoneNumber)).check(matches(withText(phoneNumber)))\n}\n</code></pre><p>What to do when we want to control a device and use multiple apps? Use UI Automator or Appium.</p><p><strong>UI Automator (instrumented E2E tests)</strong></p><p>UI Automator is perhaps the least popular tool from this article. It doesn&#39;t even have its logo - I had to create one using online generators. It is a powerful tool though, and it works quite well. Appium uses it underneath to control Android devices.</p><p>The approach for testing using UI Automator is quite different comparing to Espresso. Your write tests that control a device (or emulator), not an app. Of course on a given device you can install your app and verify it works well but Espresso is much faster.</p><p>You can find an example of a UI Automator test <a href=\"https://github.com/android/testing-samples/blob/master/ui/uiautomator/BasicSample/app/src/androidTest/java/com/example/android/testing/uiautomator/BasicSample/ChangeTextBehaviorTest.java\" target=\"_blank\" rel=\"noreferrer\">here</a>.</p><p>I&#39;ll show you a few use cases for UI Automator (or Appium) in section 8.</p><p><strong>Appium (E2E tests)</strong></p><p>Appium is a very mature and powerful tool that allows you to automate Windows, Android, and iOS apps. Appium is built on the idea that testing native apps shouldn&#39;t require including an SDK or recompiling your app. Appium aims to automate any mobile app from any language and any test framework, with full access to back-end APIs and DBs from test code.</p><p>Unfortunately, Appium tests are slow. So what are the use cases for them?</p><ul>\n<li>the team wants to write test in a different language than Java/Kotlin</li>\n<li>the team wants to write mobile tests in Selenium API</li>\n<li>we prefer it ahead of UI Automator in E2E scenarios described in section 8</li>\n<li>we can reuse Web/Native Android/Native iOS/Native Windows automation code (see snippet below)</li>\n</ul>\n<pre><code class=\"hljs language-java\">\n<span class=\"hljs-meta\">@FindBy(css = &quot;.myClass&quot;)</span>\n<span class=\"hljs-meta\">@WindowsFindBy(id = &quot;windowsId&quot;)</span>\n<span class=\"hljs-meta\">@AndroidFindBy(accessibility = &quot;android&quot;)</span>\n<span class=\"hljs-meta\">@iOSXCUITFindBy(tagName = &quot;ios&quot;)</span>\n<span class=\"hljs-keyword\">private</span> FluentWebElement multiPlatformElement;\n</code></pre><p>Here is the proof that the Appium test looks pretty much like Selenium:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">SAMPLE_TITLE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;SampleTitle&quot;</span>;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">SAMPLE_BODY</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;SampleBody&quot;</span>;\n\n    <span class=\"hljs-meta\">@Page</span>\n    <span class=\"hljs-keyword\">private</span> SwiftNoteHomePage noteApp;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">shouldCorrectlyAddNote</span><span class=\"hljs-params\">()</span> {\n        noteApp\n                .verifyIfIsLoaded()\n                .verifyNoteCount(<span class=\"hljs-number\">0</span>)\n                .clickAddNote()\n                .addNote(SAMPLE_TITLE, SAMPLE_BODY)\n                .verifyIfIsLoaded()\n                .verifyNoteCount(<span class=\"hljs-number\">1</span>)\n                .clickAddNote()\n                .addNote(SAMPLE_TITLE, SAMPLE_BODY)\n                .verifyIfIsLoaded()\n                .verifyNoteCount(<span class=\"hljs-number\">2</span>);\n    }\n</code></pre><p>More Appium examples can be found in <a href=\"https://github.com/FluentLenium/FluentLenium/tree/develop/examples/appium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium project</a>.</p><p><strong>E2E Android tests use cases</strong></p><p>I can think of at least two test cases which forces you to write slow, hard to maintain and long UI Automator or Appium tests</p><ul>\n<li>testing Proguard/R8 final Release build</li>\n</ul>\n<p>According to <a href=\"https://developer.android.com/studio/build/shrink-code\" target=\"_blank\" rel=\"noreferrer\">Google Android docs</a> &#39;to make your app as small as possible, you should enable_shrinking_in your release build to remove unused code and resources. When enabling shrinking, you also benefit from_obfuscation_, which shortens the names of your app’s classes and members, and <em>optimization</em>, which applies more aggressive strategies to further reduce the size of your app&#39;.</p><p>Espresso tests can&#39;t be run on obfuscated Release build (only Debug) so if you want to perform final checks on your app you have to test it in the E2E scenario. In theory, Progruard shouldn&#39;t break anything, but trust me, it does.</p><ul>\n<li>testing internal database upgrade between versions</li>\n</ul>\n<p>Android apps can have an internal database stored on the user&#39;s device. If we release a new version we have to make sure it migrates properly into a new schema. You need to automate the following steps:</p><ul>\n<li>install old (current) revision on device</li>\n<li>open app</li>\n<li>install new (the one being released) revision on device</li>\n<li>make sure it works and the internal data wasn&#39;t corrupted</li>\n</ul>\n<p><strong>Android test pyramid - a different approach</strong></p><p>As you can see visualizing the Android test pyramid isn&#39;t simple. Maybe this image is better? Let me know what do you think in the comments.</p><img src=\"/images/blog/7TfzCleqRznu3w_aUrjCNJhar1SdHOri0WxBYRZI9wDsixhEKzMiVVoYhGc3E_XwI0JzLA76qVOM891SRKnsWbHpBjCb4EsYJGpAFrcVe6pYuzeXlJuknpjpqQUeBnIAgVKv0D4auFc\" alt=\"\">\n\n<p><strong>Sources</strong></p><ul>\n<li><a href=\"https://www.amazon.com/Android-Programming-Ranch-Guide-Guides-ebook/dp/B07XVLNGX1/ref=sr_1_1?dchild=1&keywords=Android+Programming%3A+The+Big+Nerd+Ranch+Guide&qid=1587901255&s=books&sr=1-1\" target=\"_blank\" rel=\"noreferrer\"></a><a href=\"https://www.amazon.com/Android-Programming-Ranch-Guide-Guides-ebook/dp/B07XVLNGX1/ref=sr_1_1?dchild=1&keywords=Android+Programming%3A+The+Big+Nerd+Ranch+Guide&qid=1587901255&s=books&sr=1-1\" target=\"_blank\" rel=\"noreferrer\">Android Programming: The Big Nerd Ranch Guide</a>* <a href=\"https://www.amazon.com/Android-Espresso-Revealed-Writing-Automated/dp/1484243145\" target=\"_blank\" rel=\"noreferrer\">Android Espresso Revealed</a></li>\n<li><a href=\"https://proandroiddev.com/a-guide-to-test-pyramid-in-android-part-1-8b3b42d0a150\" target=\"_blank\" rel=\"noreferrer\">A guide to test pyramid in Android</a></li>\n<li><a href=\"https://developer.android.com/training/testing/fundamentals\" target=\"_blank\" rel=\"noreferrer\">Fundamentals of testing - Android developers</a></li>\n<li><a href=\"https://www.raywenderlich.com/5192-android-viper-tutorial\" target=\"_blank\" rel=\"noreferrer\">Android VIPER tutorial</a></li>\n<li><a href=\"https://saucelabs.com/blog/simulators-vs-emulators-whats-the-difference-anyway\" target=\"_blank\" rel=\"noreferrer\">Sauce Labs - Simulator vs Emulator</a></li>\n<li><a href=\"https://github.com/slawekradzyminski/Kotlin-Espresso-sample\" target=\"_blank\" rel=\"noreferrer\">GitHub Roboelectric/Espresso example</a></li>\n</ul>\n"
}