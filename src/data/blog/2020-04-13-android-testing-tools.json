{
  "id": "2020-04-13-android-testing-tools",
  "title": "Android testing tools",
  "date": "2020-04-13",
  "categories": [
    "Mobile testing"
  ],
  "tags": [
    "mobile testing"
  ],
  "permalink": "/2020/04/android-testing-tools",
  "content": "<p><img src=\"/images/blog/android-robot-vector.jpg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>I&#39;m pretty sure everyone has heard about the test pyramid. Famous Google testing<br>blog <a href=\"https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html\" target=\"_blank\" rel=\"noreferrer\">article</a> suggests a 70/20/10<br>split: 70% unit tests, 20% integration tests, and 10% end-to-end (E2E) tests.</p>\n<p>The question is, how does it map to Android native app testing? In my article, I&#39;ll familiarize you with multiple<br>Android tools that may enhance your testing skills. To get the most of them it&#39;s important to understand where are they<br>placed on the test pyramid.</p>\n<p><strong>Android test pyramid</strong></p>\n<p>In a typical Android project, there are two places for tests:</p>\n<ul>\n<li>test package - non-instrumented tests requiring JVM only to run. This folder contains standard JUnit unit tests and<br>Roboelectric scenarios using Android simulator underneath</li>\n<li>androidTest package - instrumented tests which require both JVM and physical or emulated device. This folder contains<br>Espresso and UI Automator tests</li>\n</ul>\n<p><img src=\"/images/blog/akhFNsmGnK3r0aLGcxgS4HS3qRVoLHgq4REVTCcJ35RO2PyIJCAHXb5foMJR4HYRPE-Eiz-Et3AHipBXTanwXQbhP48TWMTGEmSKVysxl97VDeqUceimjpKZ2XJ_TWsjUXbvpN4TeQc\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Additionally, you can also have E2E Appium tests in a separate repository (outside your project).</p>\n<p>The mapping of those tools on the standard test pyramid isn&#39;t straightforward. Roboelectric tests verify integration.<br>Similarly, UIAutomator allows you to run E2E scenarios. Here is how the visualization looks like:</p>\n<p><img src=\"/images/blog/LG9HGHuem9DyWnJqPbJ66oHJwjf3KN0r1aa17iDaQpm2lxksSrk5VE3DFxmYAXp2yCcJcvibXwXcUosjSUz3N2OCvKpsnbhVKda8RKd2vFQFtYZhM9oGaMrCmsybYFmhOfLzKsgqTCw\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Now I&#39;m going to describe what each tool allows you to test.  </p>\n<p><strong>Junit (unit tests)</strong></p>\n<p>Whenever you plan your tests you should start from the units. They&#39;re the fastest, the cheapest, and the most flexible.<br>Android is no exception here. Unfortunately, unit testing Android project is surprisingly complicated. Why? Unit tests<br>are in close relationship with a tested app. Usually, good architecture is testable, meaning writing unit tests is easy.<br>How about Android app architecture? Let&#39;s take a look at the popular approach: VIPER.</p>\n<p>In VIPER we split our classes into five distinct logic parts:</p>\n<ul>\n<li>The_View_corresponds to an Activity or Fragment in the app.* The_Interactor_performs actions requested by the<br>                                                         Presenter.</li>\n<li>The_Presenter_is the app command center. it commands actions, forces View display, and Router navigation.</li>\n<li>The_Entity_represents the app data.</li>\n<li>The_Router_handles navigation.</li>\n</ul>\n<p><img src=\"/images/blog/6mjOFgyCIz0V6FLgc1m1gZP0aCLLDG9xnl6dvKcMr6hwSICST4bADYwpyo8sjdgsNQn6v2D950z9wetPWkqyJlXigivLPC6n31L9crY27Q_lbWLHcsQxUS7YHGhu_Vga45ZqKdtan5o\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Classes marked by blue color have no dependencies on the Android platform code. With proper implementation, you should<br>be able to test them without excessive use of mocks.</p>\n<p>On the other hand, green classes do depend on the core Android code (Activity, Context, SharedPreferences, and more).<br>They are very hard to test on a unit level without relying too much on <a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noreferrer\">Mockito</a> (or<br>Kotlin <a href=\"https://mockk.io/\" target=\"_blank\" rel=\"noreferrer\">Mockk</a>). Even worse, a lot of Android core methods are static meaning<br>that <a href=\"https://powermock.github.io/\" target=\"_blank\" rel=\"noreferrer\">PowerMock</a> may be required.</p>\n<p>This is why Android developers usually like to write clean tests on higher levels, for example using Roboelectric.</p>\n<p><strong>Roboelectric (non-instrumented integration tests)</strong></p>\n<p>In simple words, <a href=\"http://robolectric.org/\" target=\"_blank\" rel=\"noreferrer\">Roboelectric</a> is an Android simulator. It allows you to run UI-like tests on<br>JVM only, meaning they&#39;re cheap, fast, reliable, and excellent for Continuous Integration (CI) systems. Robolectric<br>handles inflation of views, resource loading, and lots of other stuff that’s implemented in native C code on Android<br>devices. This allows tests to do most things you could do on a real device.</p>\n<p>Since Robolectric 4.0, Espresso APIs are now supported in Robolectric tests. Even more, you can have shared test<br>implementation for both Roboelectric and Espresso as in the<br>following <a href=\"https://github.com/slawekradzyminski/Kotlin-Espresso-sample\" target=\"_blank\" rel=\"noreferrer\">GitHub example</a>.</p>\n<p>Below you can find an example non-instrumented Roboelectric test:</p>\n<pre><code class=\"language-kotlin\">import androidx.test.espresso.Espresso.onView\n\n@RunWith(AndroidJUnit4::class)\nclass AddContactActivityTest {\n\n    @Test fun inputTextShouldBeRetainedAfterActivityRecreation() {\n        // GIVEN\n        val contactName = &quot;Test User&quot;\n        val scenario = launchActivity&lt;AddContactActivity&gt;()\n\n        // WHEN\n        // Enter contact name\n        onView(withId(R.id.contact_name_text)).perform(typeText(contactName))\n        // Destroy and recreate Activity\n        scenario.recreate()\n\n        // THEN\n        // Check contact name was preserved.\n        onView(withId(R.id.contact_name_text)).check(matches(withText(contactName)))\n     }\n}\n</code></pre>\n<p>It looks pretty much like Espresso test, isn&#39;t it?</p>\n<p><strong>Espresso (instrumented integration tests)</strong></p>\n<p>Espresso tests are excellent for collaboration between Test Engineers and Android Developers. They are very fun to<br>create because we see our actual app in action on an emulator or physical device. Espresso allows you to test one app<br>only.</p>\n<p>You may be wondering why Espresso tests are on the integration level. UI tests shouldn&#39;t be here, right? Well, not<br>exactly. To understand why we need to take a look into how Android Activity works.</p>\n<p><img src=\"/images/blog/eGaXXCeUufyrbYI95PVuur5RyajIB0S3KF1_2143e_3xNhxL4t1zqbdUio4Y-26IXLkkeCqjrPVZjZisBba5c_E8MaSt5JsoGCdgkxBgPUjZJjTZi2hh_vvhmVVQqK46tVX5Mjevra8\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Whenever there is a screen change on Android device Android OS is involved. Each app sends startActivity(Intent) to<br>Activity Manager and it decides what to do next. We have two types on Intents:</p>\n<ul>\n<li>Explicit Intent tells Android OS which Activity on which app should be opened</li>\n<li>Implicit Intent tells OS what we would like to do (for example open navigation) and OS decides which app should be<br>opened</li>\n</ul>\n<p>Espresso allows opening any Activity you want so you can start your test on the first, second, middle, or even last<br>screen. Assuming you test the eCommerce app, you can write tests that open the order summary only. Some Activities<br>require Bundle of data. In Espresso you can insert it manually.</p>\n<p>What if our app integrates with other apps via Implicit Intents? They can be easily mocked in Mockito-like way.</p>\n<p>Below you can find an example of Espresso test which mocks Intents:</p>\n<pre><code class=\"language-kotlin\">@Test fun activityResult_DisplaysContactsPhoneNumber() {\n// Build the result to return when the activity is launched.\nval resultData = Intent()\nval phoneNumber = &quot;123-345-6789&quot;\nresultData.putExtra(&quot;phone&quot;, phoneNumber)\nval result = Instrumentation.ActivityResult(Activity.RESULT_OK, resultData)\n\n    // Set up result stubbing when an intent sent to &quot;contacts&quot; is seen.\n    intending(toPackage(&quot;com.android.contacts&quot;)).respondWith(result)\n\n    // User action that results in &quot;contacts&quot; activity being launched.\n    // Launching activity expects phoneNumber to be returned and displayed.\n    onView(withId(R.id.pickButton)).perform(click())\n\n    // Assert that the data we set up above is shown.\n    onView(withId(R.id.phoneNumber)).check(matches(withText(phoneNumber)))\n}\n</code></pre>\n<p>What to do when we want to control a device and use multiple apps? Use UI Automator or Appium.</p>\n<p><strong>UI Automator (instrumented E2E tests)</strong></p>\n<p>UI Automator is perhaps the least popular tool from this article. It doesn&#39;t even have its logo - I had to create one<br>using online generators. It is a powerful tool though, and it works quite well. Appium uses it underneath to control<br>Android devices.</p>\n<p>The approach for testing using UI Automator is quite different comparing to Espresso. Your write tests that control a<br>device (or emulator), not an app. Of course on a given device you can install your app and verify it works well but<br>Espresso is much faster.</p>\n<p>You can find an example of a UI Automator<br>test <a href=\"https://github.com/android/testing-samples/blob/master/ui/uiautomator/BasicSample/app/src/androidTest/java/com/example/android/testing/uiautomator/BasicSample/ChangeTextBehaviorTest.java\" target=\"_blank\" rel=\"noreferrer\">here</a>.</p>\n<p>I&#39;ll show you a few use cases for UI Automator (or Appium) in section 8.</p>\n<p><strong>Appium (E2E tests)</strong></p>\n<p>Appium is a very mature and powerful tool that allows you to automate Windows, Android, and iOS apps. Appium is built on<br>the idea that testing native apps shouldn&#39;t require including an SDK or recompiling your app. Appium aims to automate<br>any mobile app from any language and any test framework, with full access to back-end APIs and DBs from test code.</p>\n<p>Unfortunately, Appium tests are slow. So what are the use cases for them?</p>\n<ul>\n<li>the team wants to write test in a different language than Java/Kotlin</li>\n<li>the team wants to write mobile tests in Selenium API</li>\n<li>we prefer it ahead of UI Automator in E2E scenarios described in section 8</li>\n<li>we can reuse Web/Native Android/Native iOS/Native Windows automation code (see snippet below)</li>\n</ul>\n<pre><code class=\"language-java\">@FindBy(css = &quot;.myClass&quot;)\n@WindowsFindBy(id = &quot;windowsId&quot;)\n@AndroidFindBy(accessibility = &quot;android&quot;)\n@iOSXCUITFindBy(tagName = &quot;ios&quot;)\nprivate FluentWebElement multiPlatformElement;\n</code></pre>\n<p>Here is the proof that the Appium test looks pretty much like Selenium:</p>\n<pre><code class=\"language-java\">private static final String SAMPLE_TITLE = &quot;SampleTitle&quot;;\nprivate static final String SAMPLE_BODY = &quot;SampleBody&quot;;\n\n    @Page\n    private SwiftNoteHomePage noteApp;\n\n    @Test\n    public void shouldCorrectlyAddNote() {\n        noteApp\n                .verifyIfIsLoaded()\n                .verifyNoteCount(0)\n                .clickAddNote()\n                .addNote(SAMPLE_TITLE, SAMPLE_BODY)\n                .verifyIfIsLoaded()\n                .verifyNoteCount(1)\n                .clickAddNote()\n                .addNote(SAMPLE_TITLE, SAMPLE_BODY)\n                .verifyIfIsLoaded()\n                .verifyNoteCount(2);\n    }\n</code></pre>\n<p>More Appium examples can be found<br>in <a href=\"https://github.com/FluentLenium/FluentLenium/tree/develop/examples/appium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium project</a>.</p>\n<p><strong>E2E Android tests use cases</strong></p>\n<p>I can think of at least two test cases which forces you to write slow, hard to maintain and long UI Automator or Appium<br>tests</p>\n<ul>\n<li>testing Proguard/R8 final Release build</li>\n</ul>\n<p>According to <a href=\"https://developer.android.com/studio/build/shrink-code\" target=\"_blank\" rel=\"noreferrer\">Google Android docs</a> &#39;to make your app as small as<br>possible, you should enable_shrinking_in your release build to remove unused code and resources. When enabling<br>shrinking, you also benefit from_obfuscation_, which shortens the names of your app’s classes and members, and<br><em>optimization</em>, which applies more aggressive strategies to further reduce the size of your app&#39;.</p>\n<p>Espresso tests can&#39;t be run on obfuscated Release build (only Debug) so if you want to perform final checks on your app<br>you have to test it in the E2E scenario. In theory, Progruard shouldn&#39;t break anything, but trust me, it does.</p>\n<ul>\n<li>testing internal database upgrade between versions</li>\n</ul>\n<p>Android apps can have an internal database stored on the user&#39;s device. If we release a new version we have to make sure<br>it migrates properly into a new schema. You need to automate the following steps:</p>\n<ul>\n<li>install old (current) revision on device</li>\n<li>open app</li>\n<li>install new (the one being released) revision on device</li>\n<li>make sure it works and the internal data wasn&#39;t corrupted</li>\n</ul>\n<p><strong>Android test pyramid - a different approach</strong></p>\n<p>As you can see visualizing the Android test pyramid isn&#39;t simple. Maybe this image is better? Let me know what do you<br>think in the comments.</p>\n<p><img src=\"/images/blog/7TfzCleqRznu3w_aUrjCNJhar1SdHOri0WxBYRZI9wDsixhEKzMiVVoYhGc3E_XwI0JzLA76qVOM891SRKnsWbHpBjCb4EsYJGpAFrcVe6pYuzeXlJuknpjpqQUeBnIAgVKv0D4auFc\" alt=\"\" style=\"width: 100%;\"></p>\n<p><strong>Sources</strong></p>\n<ul>\n<li><a href=\"https://www.amazon.com/Android-Programming-Ranch-Guide-Guides-ebook/dp/B07XVLNGX1/ref=sr_1_1?dchild=1&keywords=Android+Programming%3A+The+Big+Nerd+Ranch+Guide&qid=1587901255&s=books&sr=1-1\" target=\"_blank\" rel=\"noreferrer\"></a><a href=\"https://www.amazon.com/Android-Programming-Ranch-Guide-Guides-ebook/dp/B07XVLNGX1/ref=sr_1_1?dchild=1&keywords=Android+Programming%3A+The+Big+Nerd+Ranch+Guide&qid=1587901255&s=books&sr=1-1\" target=\"_blank\" rel=\"noreferrer\">Android Programming: The Big Nerd Ranch Guide</a>* <a href=\"https://www.amazon.com/Android-Espresso-Revealed-Writing-Automated/dp/1484243145\" target=\"_blank\" rel=\"noreferrer\">Android Espresso Revealed</a></li>\n<li><a href=\"https://proandroiddev.com/a-guide-to-test-pyramid-in-android-part-1-8b3b42d0a150\" target=\"_blank\" rel=\"noreferrer\">A guide to test pyramid in Android</a></li>\n<li><a href=\"https://developer.android.com/training/testing/fundamentals\" target=\"_blank\" rel=\"noreferrer\">Fundamentals of testing - Android developers</a></li>\n<li><a href=\"https://www.raywenderlich.com/5192-android-viper-tutorial\" target=\"_blank\" rel=\"noreferrer\">Android VIPER tutorial</a></li>\n<li><a href=\"https://saucelabs.com/blog/simulators-vs-emulators-whats-the-difference-anyway\" target=\"_blank\" rel=\"noreferrer\">Sauce Labs - Simulator vs Emulator</a></li>\n<li><a href=\"https://github.com/slawekradzyminski/Kotlin-Espresso-sample\" target=\"_blank\" rel=\"noreferrer\">GitHub Roboelectric/Espresso example</a></li>\n</ul>\n"
}