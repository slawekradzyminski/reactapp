{
  "id": "2016-04-14-introducing-fluentlenium-2-selenium-waiting-game",
  "title": "Introducing FluentLenium 2 - Selenium waiting game",
  "date": "2016-04-14",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium",
    "fluentlenium",
    "firefox",
    "test automation",
    "UI testing",
    "chrome"
  ],
  "permalink": "/2016/04/introducing-fluentlenium-2-selenium",
  "content": "<p><img src=\"/images/blog/myfacewhilewaitingforittoload_97763284cc024193ded2f45d572c0e98.jpg\" alt=\"\" style=\"width: 100%;\"></p>\n<p><a href=\"https://awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">Introducing FluentLenium</a> is so far my most popular<br>technical post and I will continue the series today with a very important subject - test waiting. For those who don&#39;t<br>know - <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> is an actively developed Selenium extension that<br>simplifies writing GUI tests.</p>\n<p>Before I delve deeper into FluentLenium powerful waiting methods let me explain why I decided to cover this topic more<br>deeply:</p>\n<p>a) Good implementation of waiting makes your tests:</p>\n<ul>\n<li>stable</li>\n<li>maintainable</li>\n<li>readable</li>\n<li>faster</li>\n</ul>\n<p>All dots listed here are extremely important factors to your testing project success/failure. I will come back to those<br>characteristics while discussing various waiting methods.</p>\n<p>b) There aren&#39;t many reliable sources in this subject (as usual, I<br>recommend<a href=\"http://www.amazon.com/Mastering-Selenium-WebDriver-Mark-Collin/dp/1784394351\" target=\"_blank\" rel=\"noreferrer\">Mastering Selenium WebDriver</a>)<br>and, a lot of false/obsolete information. For<br>example,<a href=\"http://stackoverflow.com/questions/12858972/how-can-i-ask-the-selenium-webdriver-to-wait-for-few-seconds-in-java?rq=1\" target=\"_blank\" rel=\"noreferrer\">this</a><br>post with +11 recommends static 5 seconds waiting.</p>\n<p>c) The topic isn&#39;t covered in Java books (because it&#39;s the framework-specific), and most of the Selenium courses treat<br>it falsely as an advanced topic</p>\n<p>The waiting methods are ordered from the worst one to the best one:</p>\n<p><strong>1. Sleeping</strong></p>\n<pre><code class=\"language-java\">Thread.sleep(3000);\n</code></pre>\n<p>The most obvious method which you should never, ever use. Probably most of us started our automation journeys with it.<br>Selenium can&#39;t find locator so we wait 2 seconds. Then we decide that 4 seconds is necessary. After that our tests<br>become slow so we trim the time to 3 seconds. Then we change machine or run tests on Grid and it&#39;s really, really bad.</p>\n<p>See characteristics I have listed in point a) - we meet none of them by using Thread.sleep().</p>\n<p><strong>2. Implicit waits</strong></p>\n<p>The implicitWait is configured globally (i.e. it&#39;s declared per driver), and it defines the time before throwing &#39;No<br>Such Element Exception&#39;. The default is 0 seconds. The line below configures ImplicitWait for 10 seconds.</p>\n<pre><code class=\"language-java\">driver.manage().timeouts.implicitWait(10,TimeUnit.SECONDS);\n</code></pre>\n<p>So far it looks good. Now imagine that you want to check if the loading element disappears on the page in 5 seconds time<br>margin. We will stay in clean Selenium and use explicitWait:</p>\n<pre><code class=\"language-java\">WebDriverWait wait = new WebDriverWait(getDriver(), 5, 500);\nwait.until(not(presenceOfElementLocated(By.id(&quot;disappearingelement&quot;))));\n</code></pre>\n<p>Effect? Element disappears after one second, but the test still waits for something. After 5 seconds test fails with<br>Timeout Exception! Why? Unfortunately, implicitWait is always associated with the driver, and the sequence of events is<br>rather undesired:</p>\n<ol>\n<li>0s - First explicitWait poll was made and implicitWait was triggered for the element. The element was found so<br>implicitWait ended</li>\n<li>0.5s - Second explicitWait poll was made and implicitWait was triggered for the element. The element was found so<br>implicitWait ended</li>\n<li>1s - Third explicitWait poll was made and implicitWait was triggered for the element. However, since the element has<br>disappeared implicitWait doesn&#39;t end (it&#39;s 10 seconds)</li>\n<li>5s - Test times out due to explicitWait 5 seconds threshold</li>\n</ol>\n<p>Not really cool, huh? Don&#39;t even think of manipulating those timers. Trust me, you don&#39;t want to debug every Timeout<br>Exception.</p>\n<p>There is more. Imagine you have a huge suite with ~500 tests. The sloppy programmer has committed something bad, and you<br>have an obvious mistake on the main page. Feedback should be as fast as possible, but with implicitWait, every test will<br>most likely have a 10-second delay before failure. Even with concurrent test execution, your run will be really slow...</p>\n<p><strong>3. Explicit Waits</strong></p>\n<p>We are getting closer to correct wait usage. ExplicitWait (example above) isn&#39;t bad but supports only a limited number<br>of ExpectedConditions. You can find all of them<br>on <a href=\"http://www.guru99.com/implicit-explicit-waits-selenium.html\" target=\"_blank\" rel=\"noreferrer\">the guru99 blog</a>. If you use them in your project I<br>suggest treating them as deprecated code. Changes aren&#39;t necessary but recommended.</p>\n<p><strong>4. Fluent Waits</strong><br>Not yet FluentLenium, but we are almost there. Hopefully, you use it already in your Selenium project. We have to define<br>two things before using them:</p>\n<p>Wait for parameters</p>\n<pre><code class=\"language-java\">Wait&lt;WebDriver&gt; wait = new FluentWait&lt;WebDriver&gt;(driver)\n        .withTimeout(5, TimeUnit.SECONDS)\n        .pollingEvery(500, TimeUnit.MILLISECONDS)\n        .ignoring(NoSuchElementException.class)\n        .withMessage(&quot;Oops, element didn&#39;t disappear!&quot;);\n</code></pre>\n<p>Guava Predicate or Function</p>\n<pre><code class=\"language-java\">Predicate&lt;WebDriver&gt; loadingElementDisappeared = new Predicate&lt;WebDriver&gt;() {\n    public boolean apply(WebDriver driver) {\n        return driver.findElements(By.id(&quot;disappearingelement&quot;)).size() = 0;\n    }\n};\n</code></pre>\n<p>Now if we want to wait for our loading element to disappear (assuming implicitWait was removed) we have to write:</p>\n<pre><code class=\"language-java\">wait.until(loadingElementDisappeared);\n</code></pre>\n<p>Go back to the good test characteristic I have mentioned in a). There is a big difference in almost every aspect, don&#39;t<br>you think?</p>\n<p><strong>5. FluentLenium await() methods</strong>  </p>\n<p>Finally! :)</p>\n<p>After this long entry, you can probably easily understand why FluentLenium await() methods are very useful. They<br>basically wrap all good things from selenium waiting methods and make one-liners. In my<br>previous <a href=\"https://awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">FluentLenium post</a>, I had already used<br>them. This method verifies that the Facebook login was successful.</p>\n<pre><code class=\"language-java\">public void verifySuccessfulLogin() {\n        await().until(WAITER_SELECTOR_AFTER_LOGIN).areDisplayed();\n    }\n</code></pre>\n<p>I love especially await().until(locator).isClickable() method and click() right after it&#39;s possible. I will redirect you<br>now to <a href=\"https://github.com/FluentLenium/FluentLenium#wait-for-an-ajax-call\" target=\"_blank\" rel=\"noreferrer\">FluentLenium await() readme</a> where you can<br>check more examples. No need to be redundant.</p>\n<p><strong>Demo time</strong></p>\n<p>I&#39;ll give you something to play with at the end. This test clearly shows how important waitings are for Selenium. I bet<br>it would be hard for you to make it pass faster :)</p>\n<pre><code class=\"language-java\">private Predicate&lt;Fluent&gt; ajaxCallCompleted = new Predicate&lt;Fluent&gt;() {\n        @Override\n        public boolean apply(Fluent fluent) {\n            return (Boolean) ((JavascriptExecutor) getDriver()).executeScript(&quot;return (window.jQuery != null) &amp;&amp; (jQuery.active === 0);&quot;);\n        }\n    }\n\n    private static final String URL = &quot;https://resttesttest.com/&quot;;\n    private static final String SUCCESS_TEXT = &quot;HTTP 200 OK&quot;;\n\n    private static final String AJAX_BUTTON_CSS = &quot;#submitajax&quot;;\n    private static final String ALERT_RESULT_CSS = &quot;.alert-success&quot;;\n\n    @Test\n    public void ajaxCallTest() {\n        goTo(URL);\n        await().until(AJAX_BUTTON_CSS).isClickable();\n        findFirst(AJAX_BUTTON_CSS).click();\n        await().atMost(5000L).untilPredicate(ajaxCallCompleted);\n        assertThat(findFirst(ALERT_RESULT_CSS).getText()).isEqualTo(SUCCESS_TEXT);\n    }\n</code></pre>\n<p>PS1</p>\n<p>As you can see on top <a href=\"https://pracowniamandragor.wordpress.com/\" target=\"_blank\" rel=\"noreferrer\">Pracownia Mondragor</a>made me a new logo. Details about<br>that on <a href=\"http://awesome-bookreviews.blogspot.com/2016/03/blog-update-awesome-logo.html\" target=\"_blank\" rel=\"noreferrer\">Awesome Book Reviews blog</a>.</p>\n<p>PS2</p>\n<p>I&#39;m looking for reviewers who can make my blog posts better when it comes to English language details. Contact me if you<br>want to help. I offer online recognition and a good book :)</p>\n"
}