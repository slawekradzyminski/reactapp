{
  "id": "2016-04-14-introducing-fluentlenium-2-selenium-waiting-game",
  "title": "Introducing FluentLenium 2 - Selenium waiting game",
  "date": "2016-04-14",
  "category": "Selenium",
  "permalink": "/2016/04/introducing-fluentlenium-2-selenium",
  "content": "<img src=\"/images/blog/myfacewhilewaitingforittoload_97763284cc024193ded2f45d572c0e98.jpg\" alt=\"\">\n\n<p><a href=\"https://awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">Introducing FluentLenium</a> is so far my most popular technical post and I will continue the series today with a very important subject - test waiting. For those who don&#39;t know - <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> is an actively developed Selenium extension that simplifies writing GUI tests.</p><p>Before I delve deeper into FluentLenium powerful waiting methods let me explain why I decided to cover this topic more deeply:</p><p>a) Good implementation of waiting makes your tests:</p><ul>\n<li>stable</li>\n<li>maintainable</li>\n<li>readable</li>\n<li>faster</li>\n</ul>\n<p>All dots listed here are extremely important factors to your testing project success/failure. I will come back to those characteristics while discussing various waiting methods.</p><p>b) There aren&#39;t many reliable sources in this subject (as usual, I recommend<a href=\"http://www.amazon.com/Mastering-Selenium-WebDriver-Mark-Collin/dp/1784394351\" target=\"_blank\" rel=\"noreferrer\">Mastering Selenium WebDriver</a>)<br>and, a lot of false/obsolete information. For example,<a href=\"http://stackoverflow.com/questions/12858972/how-can-i-ask-the-selenium-webdriver-to-wait-for-few-seconds-in-java?rq=1\" target=\"_blank\" rel=\"noreferrer\">this</a><br>post with +11 recommends static 5 seconds waiting.</p><p>c) The topic isn&#39;t covered in Java books (because it&#39;s the framework-specific), and most of the Selenium courses treat it falsely as an advanced topic</p><p>The waiting methods are ordered from the worst one to the best one:</p><p><strong>1. Sleeping</strong></p><pre><code class=\"hljs language-java\">\nThread.sleep(<span class=\"hljs-number\">3000</span>);\n</code></pre><p>The most obvious method which you should never, ever use. Probably most of us started our automation journeys with it.<br>Selenium can&#39;t find locator so we wait 2 seconds. Then we decide that 4 seconds is necessary. After that our tests become slow so we trim the time to 3 seconds. Then we change machine or run tests on Grid and it&#39;s really, really bad.</p><p>See characteristics I have listed in point a) - we meet none of them by using Thread.sleep().</p><p><strong>2. Implicit waits</strong></p><p>The implicitWait is configured globally (i.e. it&#39;s declared per driver), and it defines the time before throwing &#39;No Such Element Exception&#39;. The default is 0 seconds. The line below configures ImplicitWait for 10 seconds.</p><pre><code class=\"hljs language-java\">\ndriver.manage().timeouts.implicitWait(<span class=\"hljs-number\">10</span>,TimeUnit.SECONDS);\n</code></pre><p>So far it looks good. Now imagine that you want to check if the loading element disappears on the page in 5 seconds time margin. We will stay in clean Selenium and use explicitWait:</p><pre><code class=\"hljs language-java\">\n<span class=\"hljs-type\">WebDriverWait</span> <span class=\"hljs-variable\">wait</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebDriverWait</span>(getDriver(), <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">500</span>);\nwait.until(not(presenceOfElementLocated(By.id(<span class=\"hljs-string\">&quot;disappearingelement&quot;</span>))));\n</code></pre><p>Effect? Element disappears after one second, but the test still waits for something. After 5 seconds test fails with Timeout Exception! Why? Unfortunately, implicitWait is always associated with the driver, and the sequence of events is rather undesired:</p><ol>\n<li>0s - First explicitWait poll was made and implicitWait was triggered for the element. The element was found so<br>implicitWait ended 2. 0.5s - Second explicitWait poll was made and implicitWait was triggered for the element. The element was found so<br>implicitWait ended 3. 1s - Third explicitWait poll was made and implicitWait was triggered for the element. However, since the element has<br>disappeared implicitWait doesn&#39;t end (it&#39;s 10 seconds)</li>\n<li>5s - Test times out due to explicitWait 5 seconds threshold</li>\n</ol>\n<p>Not really cool, huh? Don&#39;t even think of manipulating those timers. Trust me, you don&#39;t want to debug every Timeout Exception.</p><p>There is more. Imagine you have a huge suite with ~500 tests. The sloppy programmer has committed something bad, and you have an obvious mistake on the main page. Feedback should be as fast as possible, but with implicitWait, every test will most likely have a 10-second delay before failure. Even with concurrent test execution, your run will be really slow...</p><p><strong>3. Explicit Waits</strong></p><p>We are getting closer to correct wait usage. ExplicitWait (example above) isn&#39;t bad but supports only a limited number of ExpectedConditions. You can find all of them on <a href=\"http://www.guru99.com/implicit-explicit-waits-selenium.html\" target=\"_blank\" rel=\"noreferrer\">the guru99 blog</a>. If you use them in your project I suggest treating them as deprecated code. Changes aren&#39;t necessary but recommended.</p><p><strong>4. Fluent Waits</strong><br><br>Not yet FluentLenium, but we are almost there. Hopefully, you use it already in your Selenium project. We have to define two things before using them:</p><p>Wait for parameters</p><pre><code class=\"hljs language-java\">\nWait&lt;WebDriver&gt; wait = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FluentWait</span>&lt;WebDriver&gt;(driver)\n        .withTimeout(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS)\n        .pollingEvery(<span class=\"hljs-number\">500</span>, TimeUnit.MILLISECONDS)\n        .ignoring(NoSuchElementException.class)\n        .withMessage(<span class=\"hljs-string\">&quot;Oops, element didn&#x27;t disappear!&quot;</span>);\n</code></pre><p>Guava Predicate or Function</p><pre><code class=\"hljs language-java\">\nPredicate&lt;WebDriver&gt; loadingElementDisappeared = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Predicate</span>&lt;WebDriver&gt;() {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">apply</span><span class=\"hljs-params\">(WebDriver driver)</span> {\n        <span class=\"hljs-keyword\">return</span> driver.findElements(By.id(<span class=\"hljs-string\">&quot;disappearingelement&quot;</span>)).size() = <span class=\"hljs-number\">0</span>;\n    }\n};\n</code></pre><p>Now if we want to wait for our loading element to disappear (assuming implicitWait was removed) we have to write:</p><pre><code class=\"hljs language-java\">\nwait.until(loadingElementDisappeared);\n</code></pre><p>Go back to the good test characteristic I have mentioned in a). There is a big difference in almost every aspect, don&#39;t you think?</p><p><strong>5. FluentLenium await() methods</strong><br></p><p>Finally! :)</p><p>After this long entry, you can probably easily understand why FluentLenium await() methods are very useful. They basically wrap all good things from selenium waiting methods and make one-liners. In my previous <a href=\"https://awesome-testing.com/2016/01/introducing-fluentlenium-1.html\" target=\"_blank\" rel=\"noreferrer\">FluentLenium post</a>, I had already used them. This method verifies that the Facebook login was successful.</p><pre><code class=\"hljs language-java\">\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">verifySuccessfulLogin</span><span class=\"hljs-params\">()</span> {\n        await().until(WAITER_SELECTOR_AFTER_LOGIN).areDisplayed();\n    }\n</code></pre><p>I love especially await().until(locator).isClickable() method and click() right after it&#39;s possible. I will redirect you now to <a href=\"https://github.com/FluentLenium/FluentLenium#wait-for-an-ajax-call\" target=\"_blank\" rel=\"noreferrer\">FluentLenium await() readme</a> where you can check more examples. No need to be redundant.</p><p><strong>Demo time</strong></p><p>I&#39;ll give you something to play with at the end. This test clearly shows how important waitings are for Selenium. I bet it would be hard for you to make it pass faster :)</p><pre><code class=\"hljs language-java\">\n   <span class=\"hljs-keyword\">private</span> Predicate&lt;Fluent&gt; ajaxCallCompleted = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Predicate</span>&lt;Fluent&gt;() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">apply</span><span class=\"hljs-params\">(Fluent fluent)</span> {\n            <span class=\"hljs-keyword\">return</span> (Boolean) ((JavascriptExecutor) getDriver()).executeScript(<span class=\"hljs-string\">&quot;return (window.jQuery != null) &amp;&amp; (jQuery.active === 0);&quot;</span>);\n        }\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">URL</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;https://resttesttest.com/&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">SUCCESS_TEXT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;HTTP 200 OK&quot;</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">AJAX_BUTTON_CSS</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;#submitajax&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">ALERT_RESULT_CSS</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;.alert-success&quot;</span>;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">ajaxCallTest</span><span class=\"hljs-params\">()</span> {\n        goTo(URL);\n        await().until(AJAX_BUTTON_CSS).isClickable();\n        findFirst(AJAX_BUTTON_CSS).click();\n        await().atMost(<span class=\"hljs-number\">5000L</span>).untilPredicate(ajaxCallCompleted);\n        assertThat(findFirst(ALERT_RESULT_CSS).getText()).isEqualTo(SUCCESS_TEXT);\n    }\n</code></pre><p>PS1</p><p>As you can see on top <a href=\"https://pracowniamandragor.wordpress.com/\" target=\"_blank\" rel=\"noreferrer\">Pracownia Mondragor</a>made me a new logo. Details about that on <a href=\"http://awesome-bookreviews.blogspot.com/2016/03/blog-update-awesome-logo.html\" target=\"_blank\" rel=\"noreferrer\">Awesome Book Reviews blog</a>.</p><p>PS2</p><p>I&#39;m looking for reviewers who can make my blog posts better when it comes to English language details. Contact me if you want to help. I offer online recognition and a good book :)</p>"
}