{
  "id": "2023-04-10-exploring-selenium-bidi-functionality-a-guide-with-java-examples",
  "title": "Exploring Selenium BiDi Functionality",
  "date": "2023-04-10",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "Java",
    "selenium",
    "UI testing",
    "test automation"
  ],
  "permalink": "/2023/04/exploring-selenium-bidi-functionality",
  "content": "<p><img src=\"/images/blog/selenium_logo_square_green.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Selenium is a widely-used open-source testing framework designed for automating web browsers and validating web<br>applications. Initially, Selenium consisted of Selenium IDE, a plugin for record-and-playback testing, and Selenium<br>Remote Control (RC), which allowed for browser automation using various programming languages. However, as the web grew<br>more complex, so did the need for more advanced testing capabilities.</p>\n<p>Selenium WebDriver was introduced as a successor to Selenium RC, providing a simpler and more efficient API for browser<br>automation. WebDriver quickly gained traction as it enabled developers to write test scripts in multiple programming<br>languages, including Java, C#, Ruby, and Python, and execute them across different browsers such as Chrome, Firefox, and<br>IE.</p>\n<p>Over the years, Selenium has become the industry standard for web application testing, thanks to its robustness,<br>flexibility, and extensive community support. However, with the increasing complexity of modern web applications and the<br>advent of single-page applications (SPAs), Selenium WebDriver faced certain limitations in terms of real-time<br>communication and control over browser internals.</p>\n<p>To address these challenges and further improve the testing experience, the Selenium project introduced the Selenium<br>BiDi (short for Bidirectional) protocol. In the following sections, we&#39;ll explore Selenium BiDi in detail. Working Java<br>project will be provided as an example usage.</p>\n<h2>Selenium BiDi</h2>\n<p>Selenium BiDi, short for Selenium Bidirectional, is an exciting new addition to the Selenium ecosystem that aims to<br>improve the way we interact with and automate web browsers. Its primary goal is to enable real-time communication<br>between WebDriver clients and web browsers using WebSockets. This bidirectional communication allows for more efficient<br>control and monitoring of browser activities, enabling advanced features and better performance.</p>\n<p>One of the main benefits of using Selenium BiDi over traditional WebDriver APIs is that it provides a more powerful and<br>flexible way of automating web browsers. In addition to the standard WebDriver commands, Selenium BiDi allows for<br>advanced actions like executing JavaScript commands, intercepting network requests, and handling browser events in<br>real-time.</p>\n<p>As you can see in <a href=\"https://www.selenium.dev/documentation/webdriver/bidirectional/\" target=\"_blank\" rel=\"noreferrer\">Selenium documentation</a> there are<br>two implementations of Selenium BiDi:</p>\n<ul>\n<li><p><a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noreferrer\">Chrome DevTools Protocol</a> (CDP)</p>\n</li>\n<li><p><a href=\"https://w3c.github.io/webdriver-bidi/\" target=\"_blank\" rel=\"noreferrer\">WebDriver BiDirectional Protocol</a> (WebDriver BiDi)</p>\n</li>\n</ul>\n<p>In this blog post, we will dive into the various aspects of Selenium BiDi and showcase its capabilities using Java<br>examples. We will explore the differences between CDP and WebDriver BiDi, understand the architecture, and demonstrate<br>how to perform advanced actions and debugging with Selenium BiDi. By the end of this post, you will have a solid<br>understanding of how Selenium BiDi can enhance your web automation and testing experience. So, let&#39;s get started!</p>\n<h2>Chrome DevTools Protocol (CDP)</h2>\n<p>The <a href=\"https://chromedevtools.github.io/devtools-protocol/\" target=\"_blank\" rel=\"noreferrer\">Chrome DevTools Protocol (CDP)</a> is a powerful and versatile<br>API that allows developers to interact with and control Google Chrome and other Chromium-based browsers<br>programmatically. CDP provides a wide range of capabilities, such as inspecting and manipulating the DOM, monitoring<br>network activity, emulating different devices, evaluating JavaScript expressions, and profiling performance, among<br>others. These functionalities facilitate in-depth debugging, testing, and analysis of web applications, making CDP an<br>essential tool for developers striving to create high-quality, performant, and reliable web experiences. CDP operates<br>over a WebSocket-based communication channel, enabling bidirectional communication between client and browser, which<br>allows for real-time updates and more granular control over the browser&#39;s internal workings.</p>\n<h3>CDP support in Selenium</h3>\n<p>While Selenium offers support for Chrome DevTools Protocol (CDP), its integration can be somewhat awkward and<br>challenging. One major issue with the CDP support in Selenium is that Java bindings need to maintain separate packages<br>for each Chromium version. This can result in compatibility issues and increased maintenance overhead, as developers<br>must ensure that their test scripts work correctly with the specific version of Chromium being used (see screenshot<br>from <a href=\"https://www.javadoc.io/doc/org.seleniumhq.selenium/selenium-devtools-v111/latest/overview-summary.html\" target=\"_blank\" rel=\"noreferrer\">javadoc</a><br>below).</p>\n<p><img src=\"/images/blog/dTW_B6D4YbtqekhvrURTrGLRo3RUX3U44W4n0O9E5rI5XAKNvuOYLWw3IGya8N52I2ORyzdVjo2ePVr6rlihBJUMat2xEUGplaU-uD-yLW5RIppq8ml1j-CDRvL8ys1rY3YpRyZY3K3EG1amAcQABqs=w520-h640\" alt=\"\" style=\"width: 100%;\"></p>\n<p>Additionally, the <a href=\"https://www.selenium.dev/documentation/webdriver/bidirectional/\" target=\"_blank\" rel=\"noreferrer\">official Selenium documentation</a><br>highlights the drawbacks of relying on CDP for testing purposes. It states, &quot;As it is not a good idea to tie your tests<br>to a specific version of any browser, the Selenium project recommends using WebDriver BiDi wherever possible.&quot; This<br>recommendation underscores the importance of adopting WebDriver BiDi, which aims to provide a more standardized and<br>future-proof solution for browser automation and testing, without the need to keep up with the ever-changing Chromium<br>versions and their corresponding CDP APIs.</p>\n<p>Despite the challenges associated with using CDP in Selenium, it&#39;s worth noting that integrating CDP can unlock some<br>powerful functionalities that can significantly enhance your web application testing capabilities. For example, by<br>leveraging CDP, you can:</p>\n<ul>\n<li><strong>Mock the network</strong>: Simulate various network conditions and intercept HTTP requests and responses, allowing you to<br>test how your application behaves under different network scenarios, such as slow connections, high latency, or even<br>offline mode.</li>\n<li><strong>Listen to console/JavaScript errors</strong>: Monitor the browser console for JavaScript errors, warnings, or other logs in<br>real-time. This can help you quickly identify and address issues in your application&#39;s code, ensuring a smooth user<br>experience.</li>\n<li><strong>Collect <a href=\"https://stackoverflow.com/questions/48630430/i-need-more-info-about-puppeteer-page-metrics-and-queryobjects\" target=\"_blank\" rel=\"noreferrer\">performance metrics</a></strong>: Gather detailed performance data, such as rendering times, memory usage, and the number of nodes, to help you<br>identify bottlenecks and optimize your web application&#39;s performance.</li>\n</ul>\n<p>These advanced functionalities offered by CDP can provide valuable insights into your web application&#39;s behavior,<br>stability, and performance, making it an attractive option for developers seeking more granular control and deeper<br>analysis of their applications. However, it&#39;s essential to weigh these benefits against the challenges of maintaining<br>compatibility with different Chromium versions and the recommendation to use WebDriver BiDi whenever possible.</p>\n<h3>Mocking the network</h3>\n<p>The code snippet provided demonstrates how to mock an HTTP request using Selenium, specifically by intercepting a<br>request triggered by clicking on a &quot;here&quot; link in the application being tested. Here&#39;s a step-by-step explanation of how<br>the mocking process works in this example:</p>\n<pre><code class=\"language-java\">@SuppressWarnings(&quot;resource&quot;)\nprivate void mockRequestWhichIsTriggeredByClickingOnHereLink() {\nnew NetworkInterceptor(\n           driver,\n           Route.matching(req -&gt; req.getUri().contains(&quot;status_codes&quot;))\n                   .to(() -&gt; req -&gt; new HttpResponse()\n                        .setStatus(200)\n                        .addHeader(&quot;Content-Type&quot;, MediaType.HTML_UTF_8.toString())\n                        .setContent(utf8String(MOCKED_RESPONSE))));\n}\n</code></pre>\n<p>a) First, a new instance of <em>NetworkInterceptor</em> is created, which is responsible for intercepting and manipulating<br>network requests and responses in the browser session controlled by the Selenium driver.</p>\n<p>b) The <em>Route.matching()</em> method is used to define a custom route that will be intercepted. The <em>req -&gt; req.getUri()<br>.contains(&quot;status_codes&quot;)</em> lambda expression specifies that the route should match any request with a URI containing<br>the string <em>&quot;status_codes&quot;</em>.</p>\n<p>c) The <em>to()</em> method is then called to provide a custom response for the matched route. In this case, it defines a<br>lambda expression <em>req -&gt; new HttpResponse()</em> that takes the intercepted request and constructs a new <em>HttpResponse</em><br>object.</p>\n<p>d) The <em>HttpResponse</em> object is configured with a status code of 200 (HTTP OK), indicating a successful response. It<br>also includes an appropriate Content-Type header (in this case, <em>MediaType.HTML_UTF_8.toString()</em>), which tells the<br>browser that the response body contains HTML content encoded in UTF-8.</p>\n<p>e) Finally, the setContent() method is called to set the content of the mocked response using <em>utf8String(<br>MOCKED_RESPONSE)</em>. This method converts the <em>MOCKED_RESPONSE</em> string into a byte array with the appropriate UTF-8<br>encoding, which is then used as the response body.</p>\n<p>When this method is executed, any request matching the specified route will be intercepted, and the custom response will<br>be returned instead of the actual response from the server. This allows you to test how your application behaves when<br>specific requests return different responses, without the need to modify the server-side implementation or configure an<br>external mocking tool.</p>\n<p>The whole test looks like this:</p>\n<pre><code class=\"language-java\">public class NetworkInterceptorTest extends LocalTest {\n\n   private static final String MOCKED_RESPONSE = &quot;That&#39;s mocked response&quot;;\n\n   @BeforeEach\n   public void setUp() {\n       driver.get(&quot;https://the-internet.herokuapp.com/redirector&quot;);\n       mockRequestWhichIsTriggeredByClickingOnHereLink();\n   }\n\n   @Test\n   public void networkInterceptor() {\n       // when\n       driver.findElement(By.linkText(&quot;here&quot;)).click();\n\n       // then\n       assertThat(driver.getPageSource()).contains(MOCKED_RESPONSE);\n   }\n\n   @SuppressWarnings(&quot;resource&quot;)\n   private void mockRequestWhichIsTriggeredByClickingOnHereLink() {\n       new NetworkInterceptor(\n               driver,\n               Route.matching(req -&gt; req.getUri().contains(&quot;status_codes&quot;))\n                       .to(() -&gt; req -&gt; new HttpResponse()\n                        .setStatus(200)\n                        .addHeader(&quot;Content-Type&quot;, MediaType.HTML_UTF_8.toString())\n                        .setContent(utf8String(MOCKED_RESPONSE))));\n   }\n}\n</code></pre>\n<h3>Listening to javascript errors in console</h3>\n<p>The code snippet provided demonstrates how to listen for JavaScript errors in the browser console using Selenium and the<br>Chrome DevTools Protocol (CDP). Below is an explanation of each part of the code snippet:</p>\n<pre><code class=\"language-java\">import static org.awaitility.Awaitility.await;\n\npublic class JavascriptExceptionLoggerTest extends LocalTest {\n\n   private final List&lt;JavascriptException&gt; jsExceptionsList = new ArrayList&lt;&gt;();\n\n   @BeforeEach\n   public void setUpLogger() {\n       DevTools devTools = driver.getDevTools();\n       devTools.createSession();\n       devTools.getDomains().events().addJavascriptExceptionListener(jsExceptionsList::add);\n   }\n\n   @Test\n   public void logEvents() {\n       // when\n       driver.get(&quot;http://the-internet.herokuapp.com/javascript_error&quot;);\n\n       // then\n       await().until(() -&gt; jsExceptionsList.size() &gt; 0);\n   }\n}\n</code></pre>\n<p>a) Import the necessary classes and packages, including <em>org.awaitility.Awaitility.await</em> for waiting for a condition to<br>be met before proceeding in the test.</p>\n<p>b) Define a new class called <em>JavascriptExceptionLoggerTest</em> that extends a base test class named <em>LocalTest</em>. This base<br>class is assumed to set up the Selenium WebDriver and other required configurations.</p>\n<p>c) Create a new instance variable <em>jsExceptionsList</em>, which is an <em>ArrayList</em> of <em>JavascriptException</em> objects. This<br>list will be used to store any JavaScript exceptions caught during the test execution.</p>\n<p>d) In the <em>setUpLogger()</em> method, which is annotated with <em>@BeforeEach</em>, perform the following steps:</p>\n<ul>\n<li>Get the <em>DevTools</em> instance from the WebDriver by calling <em>driver.getDevTools()</em>.</li>\n<li>Create a new <em>DevTools</em> session by invoking <em>devTools.createSession().</em></li>\n<li>Add a new listener for JavaScript exceptions by calling <em>devTools.getDomains().events()<br>.addJavascriptExceptionListener(jsExceptionsList::add)</em>. This listener adds any JavaScript exceptions encountered to<br>the <em>jsExceptionsList</em>.</li>\n</ul>\n<p>e) Define the <em>logEvents()</em> test method, which is annotated with <em>@Test</em>:</p>\n<ul>\n<li>Navigate to the target web page by calling driver.get(&quot;<a href=\"http://the-internet.herokuapp.com/javascript\\_error\" target=\"_blank\" rel=\"noreferrer\">http://the-internet.herokuapp.com/javascript\\_error</a>&quot;). This<br>page is assumed to contain a JavaScript error that will be logged in the browser console.</li>\n<li>Use the <em>await()</em> method from the Awaitility library to wait for the condition <em>jsExceptionsList.size() &gt; 0</em> to be<br>true, meaning that at least one JavaScript exception has been logged.</li>\n</ul>\n<p>By following these steps, the JavascriptExceptionLoggerTest class will listen for JavaScript errors in the browser<br>console and store them in the <em>jsExceptionsList</em> ArrayList. This functionality can be useful for identifying and<br>debugging issues in your web application&#39;s JavaScript code during test execution, helping to ensure a smooth and<br>error-free user experience.</p>\n<h3>Gathering performance metrics</h3>\n<p>The provided code snippet demonstrates how to gather performance metrics for a web application using Selenium and the<br>Chrome DevTools Protocol (CDP). Here&#39;s a step-by-step explanation of the code:</p>\n<pre><code class=\"language-java\">public class PerformanceMetricsTest extends LocalTest {\n\n   private List&lt;Metric&gt; metricList;\n\n   @BeforeEach\n   public void setUp() {\n       DevTools devTools = driver.getDevTools();\n       devTools.createSession();\n       devTools.send(Performance.enable(Optional.empty()));\n       metricList = devTools.send(Performance.getMetrics());\n   }\n\n   @Test\n   public void shouldCollectPerformanceMetrics() {\n       // when\n       driver.get(&quot;https://awesome-testing.com&quot;);\n\n       // then\n       metricList.forEach(PerformanceMetricsTest::logAndAssert);\n   }\n\n   private static void logAndAssert(Metric metric) {\n       log.info(&quot;{} = {}&quot;, metric.getName(), metric.getValue());\n       assertThat(metric.getValue().longValue()).isGreaterThanOrEqualTo(0);\n   }\n\n}\n</code></pre>\n<p>a) Define a new class called <em>PerformanceMetricsTest</em> that extends a base test class named <em>LocalTest</em>. This base class<br>is assumed to set up the Selenium WebDriver and other required configurations.</p>\n<p>b) Create a new instance variable <em>metricList</em> of type <em>List<Metric></em>. This list will be used to store the performance<br>metrics gathered from the browser.</p>\n<p>c) In the <em>setUp()</em> method, which is annotated with <em>@BeforeEach</em>, perform the following steps:</p>\n<ul>\n<li>Get the <em>DevTools</em> instance from the WebDriver by calling <em>driver.getDevTools()</em>.</li>\n<li>Create a new <em>DevTools</em> session by invoking <em>devTools.createSession()</em>.</li>\n<li>Enable the Performance domain in <em>DevTools</em> by calling <em>devTools.send(Performance.enable(Optional.empty()))</em>.</li>\n<li>Retrieve the current performance metrics by sending a <em>Performance.getMetrics()</em> command, and store the results in the<br>metricList.</li>\n</ul>\n<p>d) Define the <em>shouldCollectPerformanceMetrics()</em> test method, which is annotated with <em>@Test</em>:</p>\n<ul>\n<li>Navigate to the target web page by calling <em>driver.get(&quot;<a href=\"https://awesome-testing.com\" target=\"_blank\" rel=\"noreferrer\">https://awesome-testing.com</a>&quot;)</em>. The performance metrics will<br>be collected for this page.</li>\n<li>Call the <em>metricList.forEach(PerformanceMetricsTest::logAndAssert)</em> method to process each metric in the <em>metricList</em>.<br>For each metric, the <em>logAndAssert()</em> method is called.</li>\n</ul>\n<p>e) Implement the <em>logAndAssert()</em> method, which takes a Metric object as input:</p>\n<ul>\n<li>Log the metric&#39;s name and value using <em>log.info(&quot;{} = {}&quot;, metric.getName(), metric.getValue())</em>.</li>\n<li>Assert that the metric&#39;s value is greater than or equal to 0 using <em>assertThat(metric.getValue().longValue())<br>.isGreaterThanOrEqualTo(0)</em>.</li>\n</ul>\n<p>By following these steps, the PerformanceMetricsTest class gathers performance metrics from the browser and logs them<br>for analysis. This functionality can help developers identify potential performance bottlenecks in their web<br>applications, leading to improved user experience and overall application performance.</p>\n<h2>WebDriver BiDi</h2>\n<p>WebDriver BiDi (short for Bidirectional) is a modern, standardized protocol designed to enhance browser automation<br>capabilities and overcome the limitations of WebDriver and the Chrome DevTools Protocol (CDP). WebDriver BiDi enables<br>real-time, bidirectional communication between the client and browser, allowing for more granular control over the<br>browser&#39;s internal workings and improved responsiveness in automation tasks.</p>\n<p>Some of the key features of WebDriver BiDi include:</p>\n<ul>\n<li>Support for multiple browser vendors: Unlike CDP, which is specific to Chromium-based browsers, WebDriver BiDi aims to<br>provide a unified and standardized API across all major browsers, such as Chrome, Firefox, Safari, and Edge. This<br>ensures consistent automation behavior and reduces the need for browser-specific code in test scripts.</li>\n<li>Improved stability and maintainability: WebDriver BiDi addresses the maintenance challenges associated with CDP by<br>offering a more stable and standardized API that is less likely to change with each browser release. This reduces the<br>need to update test scripts frequently and ensures better compatibility across browser versions.</li>\n</ul>\n<p>As explained in the <a href=\"https://developer.chrome.com/blog/webdriver-bidi/\" target=\"_blank\" rel=\"noreferrer\">Google article</a> all browser vendors are involved<br>in the specification process. Here are some of them:</p>\n<ul>\n<li>Apple</li>\n<li>BrowserStack</li>\n<li>Google</li>\n<li>Microsoft</li>\n<li>Mozilla</li>\n<li>Sauce Labs</li>\n</ul>\n<p>The work is mostly done in the <a href=\"https://github.com/w3c/webdriver-bidi\" target=\"_blank\" rel=\"noreferrer\">GitHub repository</a>. There are monthly meetings<br>with all major browser vendors reporting actual progress and discussing arguable and unknown specifics. The<br>cross-companies working group makes sure the decisions are aligned with all stakeholders.</p>\n<p>The Draft is <a href=\"https://w3c.github.io/webdriver-bidi/\" target=\"_blank\" rel=\"noreferrer\">available here</a> and the adoption rate<br>is <a href=\"https://wpt.fyi/results/webdriver/tests/bidi?label=experimental&label=master&aligned&view=subtest\" target=\"_blank\" rel=\"noreferrer\">visualized here</a>.</p>\n<h3>WebDriver BiDi support in Selenium</h3>\n<p>Selenium has embraced the WebDriver BiDi protocol as a key component of its browser automation capabilities. The<br>integration of WebDriver BiDi into Selenium aims to provide a more seamless and reliable automation experience for<br>developers, with improved control and stability compared to using the Chrome DevTools Protocol. By adopting WebDriver<br>BiDi, Selenium users can benefit from its advanced features and cross-browser support, ensuring more consistent and<br>maintainable test scripts for web applications.</p>\n<h3>Listening to JavaScript errors in console</h3>\n<p>One notable example of WebDriver BiDi&#39;s capabilities is its complete logging API, which allows developers to listen to<br>JavaScript errors in the browser console. This feature is particularly useful for identifying and debugging issues in<br>your web application&#39;s JavaScript code during test execution. With WebDriver BiDi, you can monitor and capture these<br>errors in a standardized manner, regardless of the browser being used, providing a consistent and reliable approach to<br>error detection and handling.</p>\n<p>The following tests show how to do it:</p>\n<pre><code class=\"language-java\">public class LogInspectorTest extends LocalFirefoxTest {\n\n   private static final String SELENIUM_CUSTOM_PAGE = &quot;https://www.selenium.dev/selenium/web/bidi/logEntryAdded.html&quot;;\n\n   private List&lt;ConsoleLogEntry&gt; consoleLogEntries;\n   private List&lt;JavascriptLogEntry&gt; javascriptLogEntries;\n   private List&lt;JavascriptLogEntry&gt; javascriptExceptions;\n\n   @SuppressWarnings(&quot;resource&quot;)\n   @BeforeEach\n   public void setUp() {\n       consoleLogEntries = new ArrayList&lt;&gt;();\n       javascriptLogEntries = new ArrayList&lt;&gt;();\n       javascriptExceptions = new ArrayList&lt;&gt;();\n       LogInspector logInspector = new LogInspector(driver);\n       logInspector.onJavaScriptLog(log -&gt; javascriptLogEntries.add(log));\n       logInspector.onConsoleEntry(log -&gt; consoleLogEntries.add(log));\n       logInspector.onJavaScriptException(log -&gt; javascriptExceptions.add(log));\n   }\n\n   @SneakyThrows\n   @Test\n   void testListenToConsoleLog() {\n       // given\n       driver.get(SELENIUM_CUSTOM_PAGE);\n\n       // when\n       driver.findElement(By.id(&quot;consoleLog&quot;)).click();\n\n       // then\n       await().until(() -&gt; consoleLogEntries.size() == 1);\n       ConsoleLogEntry consoleLogEntry = consoleLogEntries.get(0);\n       assertThat(consoleLogEntry.getText()).isEqualTo(&quot;Hello, world!&quot;);\n       assertThat(consoleLogEntry.getRealm()).isNull();\n       assertThat(consoleLogEntry.getType()).isEqualTo(&quot;console&quot;);\n       assertThat(consoleLogEntry.getMethod()).isEqualTo(&quot;log&quot;);\n       assertThat(consoleLogEntry.getStackTrace()).isNull();\n   }\n\n   @SneakyThrows\n   @Test\n   void testListenToJavascriptLog() {\n       // given\n       driver.get(SELENIUM_CUSTOM_PAGE);\n\n       // when\n       driver.findElement(By.id(&quot;jsException&quot;)).click();\n\n       // then\n       await().until(() -&gt; javascriptLogEntries.size() == 1);\n       JavascriptLogEntry javascriptLogEntry = javascriptLogEntries.get(0);\n       assertThat(javascriptLogEntry.getText()).isEqualTo(&quot;Error: Not working&quot;);\n       assertThat(javascriptLogEntry.getType()).isEqualTo(&quot;javascript&quot;);\n       assertThat(javascriptLogEntry.getLevel()).isEqualTo(LogLevel.ERROR);\n   }\n\n   @SneakyThrows\n   @Test\n   void testListenToJavascriptErrorLog() {\n       // given\n       driver.get(SELENIUM_CUSTOM_PAGE);\n\n       // when\n       driver.findElement(By.id(&quot;jsException&quot;)).click();\n\n       // then\n       await().until(() -&gt; javascriptExceptions.size() == 1);\n       JavascriptLogEntry javascriptLogEntry = javascriptExceptions.get(0);\n       assertThat(javascriptLogEntry.getText()).isEqualTo(&quot;Error: Not working&quot;);\n       assertThat(javascriptLogEntry.getType()).isEqualTo(&quot;javascript&quot;);\n   }\n\n   @SneakyThrows\n   @Test\n   void testRetrieveStacktraceForALog() {\n       // given\n       driver.get(SELENIUM_CUSTOM_PAGE);\n\n       // when\n       driver.findElement(By.id(&quot;logWithStacktrace&quot;)).click();\n\n       // then\n       await().until(() -&gt; javascriptExceptions.size() == 1);\n       JavascriptLogEntry javascriptLogEntry = javascriptExceptions.get(0);\n       assertThat(javascriptLogEntry.getStackTrace()).isNotNull();\n       assertThat(javascriptLogEntry.getStackTrace().getCallFrames()).hasSize(4);\n   }\n\n}\n</code></pre>\n<p>The <em>LogInspectorTest</em> class contains four test cases that demonstrate how to listen to and capture different types of<br>log entries in a web application using WebDriver BiDi. The test cases are designed to work with Firefox, as indicated by<br>the LocalFirefoxTest base class. The tests interact with a custom Selenium page containing buttons to trigger different<br>types of log entries.</p>\n<ul>\n<li><em>testListenToConsoleLog</em>: This test navigates to the custom Selenium page, clicks the &quot;consoleLog&quot; button, and listens<br>for a console log entry. It verifies that the captured console log entry contains the expected text, realm, type,<br>method, and stack trace.</li>\n<li><em>testListenToJavascriptLog</em>: This test navigates to the custom Selenium page, clicks the &quot;jsException&quot; button, and<br>listens for a JavaScript log entry. It verifies that the captured JavaScript log entry contains the expected text,<br>type, and log level.</li>\n<li><em>testListenToJavascriptErrorLog</em>: This test navigates to the custom Selenium page, clicks the &quot;jsException&quot; button,<br>and listens for a JavaScript error log entry. It verifies that the captured JavaScript error log entry contains the<br>expected text and type.</li>\n<li><em>testRetrieveStacktraceForALog</em>: This test navigates to the custom Selenium page, clicks the &quot;logWithStacktrace&quot;<br>button, and listens for a JavaScript error log entry with a stack trace. It verifies that the captured JavaScript<br>error log entry contains a non-null stack trace and the correct number of call frames.</li>\n</ul>\n<p>These tests showcase how WebDriver BiDi can be used to monitor and capture various types of log entries in a web<br>application, providing valuable insights into the application&#39;s behavior and helping developers identify and debug<br>issues more efficiently.</p>\n<h2>Summary: WebDriver BiDi over CDP</h2>\n<p>As the browser automation landscape evolves, it&#39;s essential for testers to understand the long-term implications of<br>using different protocols, such as the Chrome DevTools Protocol (CDP) and WebDriver BiDi. In the long run, it is<br>expected that support for CDP in Selenium will diminish, as WebDriver BiDi is explicitly designed to be the future of<br>browser automation.</p>\n<p>WebDriver BiDi offers numerous advantages over CDP, including cross-browser support, stability, and maintainability.<br>This makes it the preferred choice for web application testing and automation. As a result, developers should be<br>cautious about overinvesting in CDP-based tests and instead prioritize adopting WebDriver BiDi wherever possible.</p>\n<p>By focusing on WebDriver BiDi, developers can ensure that their test scripts remain relevant and compatible with future<br>browser releases, reducing the need for frequent updates and maintenance. Additionally, WebDriver BiDi&#39;s standardized<br>API allows for a more consistent automation experience across different browsers, further enhancing the reliability and<br>robustness of your test suite.</p>\n<p>In conclusion, while CDP has served as a valuable tool for browser automation and testing, its limitations and<br>browser-specific nature make it less suitable for long-term use. WebDriver BiDi, on the other hand, represents the<br>future of browser automation, with its cross-browser support and stable API. By embracing WebDriver BiDi and<br>transitioning away from CDP, developers can ensure that their test scripts remain relevant, maintainable, and compatible<br>with the ever-evolving world of web browsers.</p>\n<h2>Java examples</h2>\n<p>In this blog post, I have explored various browser automation concepts, including Chrome DevTools Protocol (CDP) and<br>WebDriver BiDi. To help you better understand and implement these concepts, I have created a repository on GitHub<br>containing practical Java examples for both CDP and WebDriver BiDi.</p>\n<p>You can access the repository at the following link:<br><a href=\"https://github.com/slawekradzyminski/seleniumjava\" target=\"_blank\" rel=\"noreferrer\">https://github.com/slawekradzyminski/seleniumjava</a></p>\n<p>The repository contains examples for both CDP and WebDriver BiDi, demonstrating their capabilities and usage in<br>real-world scenarios. Please note that some of these examples require a Selenium Grid running locally. To help you set<br>up the local Selenium Grid, I have included a <a href=\"http://docker-compose.yml\" target=\"_blank\" rel=\"noreferrer\">docker-compose.yml</a> file in the repository,<br>which allows you to easily create a grid using <a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noreferrer\">Docker</a>.</p>\n<p>By exploring the provided examples, you can gain hands-on experience working with CDP and WebDriver BiDi in Selenium and<br>learn how to harness their full potential in your web application testing and automation efforts.</p>\n"
}