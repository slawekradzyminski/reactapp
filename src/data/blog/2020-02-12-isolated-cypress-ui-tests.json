{
  "id": "2020-02-12-isolated-cypress-ui-tests",
  "title": "Isolated Cypress UI tests",
  "date": "2020-02-12",
  "categories": [
    "Cypress"
  ],
  "tags": [
    "cypress"
  ],
  "permalink": "/2020/02/isolated-cypress-ui-tests",
  "content": "<p><img src=\"/images/blog/Screenshot%2B2020-02-08%2Bat%2B14.09.16.png\" alt=\"\"></p><p>In my previous post, I described the whole <a href=\"https://www.awesome-testing.com/2020/01/practical-test-strategy-for-spring.html\" target=\"_blank\" rel=\"noreferrer\">test automation strategy</a> for Spring + React application. One of the items there was isolated Cypress UI tests.</p><p>In this post, I&#39;d like to describe what isolation means and how to achieve it using Cypress. As usual, the theory will be supported by a practical and working demo. All code on <a href=\"https://github.com/slawekradzyminski\" target=\"_blank\" rel=\"noreferrer\">my GitHub</a> is 100% free to use by anyone.</p><h2>Understanding isolation</h2>\n<p>So what are the characteristics of an isolated test?</p><p>First of all, it needs to work offline. All external traffic should be controlled inside a test. Of course, in real-world we are connected to the network but all your isolated tests should pass in the following scenario:</p><ul>\n<li>download dependencies (maven, npm, sbt...)</li>\n<li>run the app you test (if needed)</li>\n<li>disable network connection</li>\n<li>run tests</li>\n</ul>\n<p>All tests should also be fully idempotent. They should work in any order. Each of them should set the desired application state before running.</p><h2>Isolation in Cypress</h2>\n<p>Let&#39;s look again at the system under test and analyze what isolation means for us.</p><p><img src=\"/images/blog/Screenshot%2B2020-01-18%2Bat%2B12.41.12.png\" alt=\"\"></p><p>We need to do two things:</p><ul>\n<li><p>stubbing incoming backend requests</p></li>\n<li><p>asserting that outgoing frontend requests are correctly built</p></li>\n</ul>\n<p>Cypress seems to be build-in having stubbing in mind. We only need two lines and static object to stub GET requests in cypress:</p><pre><code class=\"hljs language-plaintext\">cy.route(&#x27;/users/1&#x27;, firstUser);\nview raw</code></pre><pre><code class=\"hljs language-plaintext\">    &quot;id&quot;: 1,\n    &quot;firstName&quot;: &quot;Slawomir&quot;,\n    &quot;lastName&quot;: &quot;Radzyminski&quot;,\n    &quot;userName&quot;: &quot;slawenty&quot;,\n    &quot;salary&quot;: 666,\n    &quot;age&quot;: 66\n};</code></pre><p>cy.server() needs to be called only once. It enables custom cy.route() stubbing for test. As you can see stubbing GET requests requires providing a response body only. Of course, you can also provide custom headers, delays, etc. Details in the <a href=\"https://docs.cypress.io/api/commands/route.html#Options\" target=\"_blank\" rel=\"noreferrer\">command documentation</a>.</p><h2>Demo - testing data display on the front page</h2>\n<p>I assume you have successfully installed Cypress and <a href=\"https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#Add-a-test-file\" target=\"_blank\" rel=\"noreferrer\">run the first test</a>.<br>Cypress documentation guides you very well through the initial setup.</p><p>So let&#39;s get started with my application tests. I usually define the most useful get stubs in custom command and run them before each test:</p><pre><code class=\"hljs language-plaintext\">        cy.prepareBackend();\n        cy.visit(&#x27;/&#x27;);\n    });</code></pre><p>To define your custom commands you need to implement them:</p><pre><code class=\"hljs language-plaintext\">    cy.server();\n    cy.route(&#x27;/users&#x27;, usersJson);\n    cy.route(&#x27;/users/1&#x27;, firstUser);\n    cy.route(&#x27;/users/2&#x27;, secondUser);\n});</code></pre><p>And import in index.js file:</p><pre><code class=\"hljs language-plaintext\"></code></pre><p>Optionally, for better IDE support, you may want to define this command in index.d.ts TypeScript file.</p><pre><code class=\"hljs language-plaintext\">    interface Chainable {\n        prepareBackend(): Chainable\n    }\n}</code></pre><p>Having all that in place we can verify that our front page displays data properly:</p><pre><code class=\"hljs language-plaintext\">        const numberOfUsers = usersJson.length;\n        for (let i = 0; i &lt; numberOfUsers; i++) {\n            cy.get(`.MuiTableBody-root tr:nth-of-type(${i + 1})`).within(() =&gt; {\n                cy.get(&#x27;[name=firstname]&#x27;).should(&#x27;have.text&#x27;, usersJson[i].firstName);\n                cy.get(&#x27;[name=lastname]&#x27;).should(&#x27;have.text&#x27;, usersJson[i].lastName);\n                cy.get(&#x27;[name=username]&#x27;).should(&#x27;have.text&#x27;, usersJson[i].userName);\n                cy.get(&#x27;[name=age]&#x27;).should(&#x27;have.text&#x27;, usersJson[i].age.toString());\n                cy.get(&#x27;[name=salary]&#x27;).should(&#x27;have.text&#x27;, usersJson[i].salary.toString());\n            })\n        }\n    });</code></pre><h2>Demo - asserting outgoing requests</h2>\n<p>When it comes to asserting that our frontend app builds and sends correct requests the flow isn&#39;t so simple.</p><p>At first, we need to make sure that our fake backend will respond in the desired way (usually HTTP 200). The request should be tagged in .as() so we can access and verify it later.</p><pre><code class=\"hljs language-plaintext\">            url: &#x27;/users/1&#x27;,\n            method: &#x27;PUT&#x27;,\n            status: 200,\n            response: {}\n        }).as(&#x27;updateUser&#x27;);</code></pre><p>So in a test, we would edit the existing user and override its data to the following:</p><pre><code class=\"hljs language-plaintext\">        userName: &#x27;sampleLogin&#x27;,\n        firstName: &#x27;John&#x27;,\n        lastName: &#x27;Doe&#x27;,\n        age: 19,\n        salary: 99999\n    };</code></pre><p>We click on the first edit button, override data and save changes:</p><pre><code class=\"hljs language-plaintext\">cy.get(&#x27;[name=userName&#x27;).clear().type(testData.userName);\ncy.get(&#x27;[name=firstName&#x27;).clear().type(testData.firstName);\ncy.get(&#x27;[name=lastName&#x27;).clear().type(testData.lastName);\ncy.get(&#x27;[name=age&#x27;).clear().type(testData.age);\ncy.get(&#x27;[name=salary&#x27;).clear().type(testData.salary);\ncy.get(&#x27;button.MuiButton-containedPrimary&#x27;).click();</code></pre><p>And now the clue. Here is how to assert outgoing request:</p><pre><code class=\"hljs language-plaintext\">            let body = xhr.request.body;\n            expect(body.id).to.equal(firstUser.id);\n            expect(body.userName).to.equal(testData.userName);\n            expect(body.firstName).to.equal(testData.firstName);\n            expect(body.lastName).to.equal(testData.lastName);\n            expect(body.age).to.equal(testData.age.toString());\n            expect(body.salary).to.equal(testData.salary.toString());\n        });</code></pre><h2>Fetch API and Cypress</h2>\n<p>There are two leading technologies which browser use to make requests: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noreferrer\">XHR</a><br>and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"noreferrer\">Fetch</a> API. XHR (often called AJAX) is older and more popular, whereas Fetch is a modern approach that relies on <a href=\"https://javascript.info/async\" target=\"_blank\" rel=\"noreferrer\">Promise/async</a> javascript syntax.</p><p>Unfortunately, Cypress supports only XHR right now. Fetch support is in progress, but with no release date commitments.<br>There is a very interesting <a href=\"https://github.com/cypress-io/cypress/issues/95\" target=\"_blank\" rel=\"noreferrer\">GitHub issue</a> where you can track work progress and read about possible workarounds.</p><p>If your application relies on Fetch API I suggest you use the following workaround:</p><ul>\n<li>set <code>win.fetch</code> for null before each test (disable it)</li>\n<li>replace <code>win.fetch</code> with <a href=\"https://github.com/github/fetch\" target=\"_blank\" rel=\"noreferrer\">Fetch polyfill</a></li>\n</ul>\n<p>Your application would think that its making Fetch requests and you will be able to stub them.</p><p>Hack implementation is here:</p><pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//  See: https://github.com/cypress-io/cypress/issues/95 enableFetchWorkaround();</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">enableFetchWorkaround</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> polyfill;\n\n    <span class=\"hljs-title function_\">before</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        cy.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Load fetch XHR polyfill&#x27;</span>);\n        cy.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&#x27;./cypress/support/polyfills/unfetch.umd.js&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">content</span>) =&gt;</span> {\n            polyfill = content\n        })\n    });\n\n    <span class=\"hljs-title class_\">Cypress</span>.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;window:before:load&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">win</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">delete</span> win.<span class=\"hljs-property\">fetch</span>;\n        win.<span class=\"hljs-built_in\">eval</span>(polyfill);\n        win.<span class=\"hljs-property\">fetch</span> = win.<span class=\"hljs-property\">unfetch</span>\n    })\n}</code></pre><p>Now you only need to import this hack in index.js:</p><pre><code class=\"hljs language-plaintext\"></code></pre><p>And copy/paste fetch polyfill:</p><pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// https://unpkg.com/unfetch@4.1.0/dist/unfetch.umd.js</span>\n\n!<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e,n</span>){<span class=\"hljs-string\">&quot;object&quot;</span>==<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">exports</span>&amp;&amp;<span class=\"hljs-string\">&quot;undefined&quot;</span>!=<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">module</span>?<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span>=<span class=\"hljs-title function_\">n</span>():<span class=\"hljs-string\">&quot;function&quot;</span>==<span class=\"hljs-keyword\">typeof</span> define&amp;&amp;define.<span class=\"hljs-property\">amd</span>?<span class=\"hljs-title function_\">define</span>(n):e.<span class=\"hljs-property\">unfetch</span>=<span class=\"hljs-title function_\">n</span>()}(<span class=\"hljs-variable language_\">this</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e,n</span>){<span class=\"hljs-keyword\">return</span> n=n||{},<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">t,o</span>){<span class=\"hljs-keyword\">var</span> r=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>,s=[],u=[],i={},f=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span>{<span class=\"hljs-attr\">ok</span>:<span class=\"hljs-number\">2</span>==(r.<span class=\"hljs-property\">status</span>/<span class=\"hljs-number\">100</span>|<span class=\"hljs-number\">0</span>),<span class=\"hljs-attr\">statusText</span>:r.<span class=\"hljs-property\">statusText</span>,<span class=\"hljs-attr\">status</span>:r.<span class=\"hljs-property\">status</span>,<span class=\"hljs-attr\">url</span>:r.<span class=\"hljs-property\">responseURL</span>,<span class=\"hljs-attr\">text</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(r.<span class=\"hljs-property\">responseText</span>)},<span class=\"hljs-attr\">json</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(r.<span class=\"hljs-property\">responseText</span>))},<span class=\"hljs-attr\">blob</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Blob</span>([r.<span class=\"hljs-property\">response</span>]))},<span class=\"hljs-attr\">clone</span>:f,<span class=\"hljs-attr\">headers</span>:{<span class=\"hljs-attr\">keys</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> s},<span class=\"hljs-attr\">entries</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-keyword\">return</span> u},<span class=\"hljs-attr\">get</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){<span class=\"hljs-keyword\">return</span> i[e.<span class=\"hljs-title function_\">toLowerCase</span>()]},<span class=\"hljs-attr\">has</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){<span class=\"hljs-keyword\">return</span> e.<span class=\"hljs-title function_\">toLowerCase</span>()<span class=\"hljs-keyword\">in</span> i}}}};<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> a <span class=\"hljs-keyword\">in</span> r.<span class=\"hljs-title function_\">open</span>(n.<span class=\"hljs-property\">method</span>||<span class=\"hljs-string\">&quot;get&quot;</span>,e,!<span class=\"hljs-number\">0</span>),r.<span class=\"hljs-property\">onload</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){r.<span class=\"hljs-title function_\">getAllResponseHeaders</span>().<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm</span>,<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e,n,t</span>){s.<span class=\"hljs-title function_\">push</span>(n=n.<span class=\"hljs-title function_\">toLowerCase</span>()),u.<span class=\"hljs-title function_\">push</span>([n,t]),i[n]=i[n]?i[n]+<span class=\"hljs-string\">&quot;,&quot;</span>+<span class=\"hljs-attr\">t</span>:t}),<span class=\"hljs-title function_\">t</span>(<span class=\"hljs-title function_\">f</span>())},r.<span class=\"hljs-property\">onerror</span>=o,r.<span class=\"hljs-property\">withCredentials</span>=<span class=\"hljs-string\">&quot;include&quot;</span>==n.<span class=\"hljs-property\">credentials</span>,n.<span class=\"hljs-property\">headers</span>)r.<span class=\"hljs-title function_\">setRequestHeader</span>(a,n.<span class=\"hljs-property\">headers</span>[a]);r.<span class=\"hljs-title function_\">send</span>(n.<span class=\"hljs-property\">body</span>||<span class=\"hljs-literal\">null</span>)})}});</code></pre><p>Working application with the following tests can be found here:</p><p><a href=\"https://github.com/slawekradzyminski/reactfrontend\" target=\"_blank\" rel=\"noreferrer\">https://github.com/slawekradzyminski/reactfrontend</a></p><p>Let me know in comments if you like to see more Cypress posts here :)</p>"
}