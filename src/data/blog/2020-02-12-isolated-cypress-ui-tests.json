{
  "id": "2020-02-12-isolated-cypress-ui-tests",
  "title": "Isolated Cypress UI tests",
  "date": "2020-02-12",
  "categories": [
    "Cypress"
  ],
  "tags": [
    "cypress"
  ],
  "permalink": "/2020/02/isolated-cypress-ui-tests",
  "content": "<p><img src=\"/images/blog/Screenshot%2B2020-02-08%2Bat%2B14.09.16.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>In my previous post, I described the<br>whole <a href=\"https://www.awesome-testing.com/2020/01/practical-test-strategy-for-spring.html\" target=\"_blank\" rel=\"noreferrer\">test automation strategy</a> for<br>Spring + React application. One of the items there was isolated Cypress UI tests.</p>\n<p>In this post, I&#39;d like to describe what isolation means and how to achieve it using Cypress. As usual, the theory will<br>be supported by a practical and working demo. All code on <a href=\"https://github.com/slawekradzyminski\" target=\"_blank\" rel=\"noreferrer\">my GitHub</a> is 100% free<br>to use by anyone.</p>\n<h2>Understanding isolation</h2>\n<p>So what are the characteristics of an isolated test?</p>\n<p>First of all, it needs to work offline. All external traffic should be controlled inside a test. Of course, in<br>real-world we are connected to the network but all your isolated tests should pass in the following scenario:</p>\n<ul>\n<li>download dependencies (maven, npm, sbt...)</li>\n<li>run the app you test (if needed)</li>\n<li>disable network connection</li>\n<li>run tests</li>\n</ul>\n<p>All tests should also be fully idempotent. They should work in any order. Each of them should set the desired<br>application state before running.</p>\n<h2>Isolation in Cypress</h2>\n<p>Let&#39;s look again at the system under test and analyze what isolation means for us.</p>\n<p><img src=\"/images/blog/Screenshot%2B2020-01-18%2Bat%2B12.41.12.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>We need to do two things:</p>\n<ul>\n<li><p>stubbing incoming backend requests</p>\n</li>\n<li><p>asserting that outgoing frontend requests are correctly built</p>\n</li>\n</ul>\n<p>Cypress seems to be build-in having stubbing in mind. We only need two lines and static object to stub GET requests in<br>cypress:</p>\n<pre><code class=\"language-javascript\">cy.server();\ncy.route(&#39;/users/1&#39;, firstUser);\nview raw\n</code></pre>\n<pre><code class=\"language-javascript\">export const firstUser = {\n    &quot;id&quot;: 1,\n    &quot;firstName&quot;: &quot;Slawomir&quot;,\n    &quot;lastName&quot;: &quot;Radzyminski&quot;,\n    &quot;userName&quot;: &quot;slawenty&quot;,\n    &quot;salary&quot;: 666,\n    &quot;age&quot;: 66\n};\n</code></pre>\n<p>cy.server() needs to be called only once. It enables custom cy.route() stubbing for test. As you can see stubbing GET<br>requests requires providing a response body only. Of course, you can also provide custom headers, delays, etc. Details<br>in the <a href=\"https://docs.cypress.io/api/commands/route.html#Options\" target=\"_blank\" rel=\"noreferrer\">command documentation</a>.</p>\n<h2>Demo - testing data display on the front page</h2>\n<p>I assume you have successfully installed Cypress<br>and <a href=\"https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#Add-a-test-file\" target=\"_blank\" rel=\"noreferrer\">run the first test</a>.<br>Cypress documentation guides you very well through the initial setup.</p>\n<p>So let&#39;s get started with my application tests. I usually define the most useful get stubs in custom command and run<br>them before each test:</p>\n<pre><code class=\"language-javascript\">beforeEach(() =&gt; {\n        cy.prepareBackend();\n        cy.visit(&#39;/&#39;);\n    });\n</code></pre>\n<p>To define your custom commands you need to implement them:</p>\n<pre><code class=\"language-javascript\">Cypress.Commands.add(&quot;prepareBackend&quot;, () =&gt; {\n    cy.server();\n    cy.route(&#39;/users&#39;, usersJson);\n    cy.route(&#39;/users/1&#39;, firstUser);\n    cy.route(&#39;/users/2&#39;, secondUser);\n});\n</code></pre>\n<p>And import in index.js file:</p>\n<pre><code class=\"language-javascript\">import &#39;./commands&#39;\n</code></pre>\n<p>Optionally, for better IDE support, you may want to define this command in index.d.ts TypeScript file.</p>\n<pre><code class=\"language-javascript\">declare namespace Cypress {\n    interface Chainable {\n        prepareBackend(): Chainable\n    }\n}\n</code></pre>\n<p>Having all that in place we can verify that our front page displays data properly:</p>\n<pre><code class=\"language-javascript\">it(&#39;should have proper data displayed&#39;, () =&gt; {\n        const numberOfUsers = usersJson.length;\n        for (let i = 0; i &lt; numberOfUsers; i++) {\n            cy.get(`.MuiTableBody-root tr:nth-of-type(${i + 1})`).within(() =&gt; {\n                cy.get(&#39;[name=firstname]&#39;).should(&#39;have.text&#39;, usersJson[i].firstName);\n                cy.get(&#39;[name=lastname]&#39;).should(&#39;have.text&#39;, usersJson[i].lastName);\n                cy.get(&#39;[name=username]&#39;).should(&#39;have.text&#39;, usersJson[i].userName);\n                cy.get(&#39;[name=age]&#39;).should(&#39;have.text&#39;, usersJson[i].age.toString());\n                cy.get(&#39;[name=salary]&#39;).should(&#39;have.text&#39;, usersJson[i].salary.toString());\n            })\n        }\n    });\n</code></pre>\n<h2>Demo - asserting outgoing requests</h2>\n<p>When it comes to asserting that our frontend app builds and sends correct requests the flow isn&#39;t so simple.</p>\n<p>At first, we need to make sure that our fake backend will respond in the desired way (usually HTTP 200). The request<br>should be tagged in .as() so we can access and verify it later.</p>\n<pre><code class=\"language-javascript\">cy.route({\n            url: &#39;/users/1&#39;,\n            method: &#39;PUT&#39;,\n            status: 200,\n            response: {}\n        }).as(&#39;updateUser&#39;);\n</code></pre>\n<p>So in a test, we would edit the existing user and override its data to the following:</p>\n<pre><code class=\"language-javascript\">const testData = {\n        userName: &#39;sampleLogin&#39;,\n        firstName: &#39;John&#39;,\n        lastName: &#39;Doe&#39;,\n        age: 19,\n        salary: 99999\n    };\n</code></pre>\n<p>We click on the first edit button, override data and save changes:</p>\n<pre><code class=\"language-javascript\">cy.get(&#39;[name=edit] svg&#39;).first().click();\ncy.get(&#39;[name=userName&#39;).clear().type(testData.userName);\ncy.get(&#39;[name=firstName&#39;).clear().type(testData.firstName);\ncy.get(&#39;[name=lastName&#39;).clear().type(testData.lastName);\ncy.get(&#39;[name=age&#39;).clear().type(testData.age);\ncy.get(&#39;[name=salary&#39;).clear().type(testData.salary);\ncy.get(&#39;button.MuiButton-containedPrimary&#39;).click();\n</code></pre>\n<p>And now the clue. Here is how to assert outgoing request:</p>\n<pre><code class=\"language-javascript\">cy.wait(&#39;@updateUser&#39;).should((xhr) =&gt; {\n            let body = xhr.request.body;\n            expect(body.id).to.equal(firstUser.id);\n            expect(body.userName).to.equal(testData.userName);\n            expect(body.firstName).to.equal(testData.firstName);\n            expect(body.lastName).to.equal(testData.lastName);\n            expect(body.age).to.equal(testData.age.toString());\n            expect(body.salary).to.equal(testData.salary.toString());\n        });\n</code></pre>\n<h2>Fetch API and Cypress</h2>\n<p>There are two leading technologies which browser use to make<br>requests: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"noreferrer\">XHR</a><br>and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"noreferrer\">Fetch</a> API. XHR (often called AJAX) is older and more<br>popular, whereas Fetch is a modern approach that relies on <a href=\"https://javascript.info/async\" target=\"_blank\" rel=\"noreferrer\">Promise/async</a> javascript<br>syntax.</p>\n<p>Unfortunately, Cypress supports only XHR right now. Fetch support is in progress, but with no release date commitments.<br>There is a very interesting <a href=\"https://github.com/cypress-io/cypress/issues/95\" target=\"_blank\" rel=\"noreferrer\">GitHub issue</a> where you can track work<br>progress and read about possible workarounds.</p>\n<p>If your application relies on Fetch API I suggest you use the following workaround:</p>\n<ul>\n<li>set <code>win.fetch</code> for null before each test (disable it)</li>\n<li>replace <code>win.fetch</code> with <a href=\"https://github.com/github/fetch\" target=\"_blank\" rel=\"noreferrer\">Fetch polyfill</a></li>\n</ul>\n<p>Your application would think that its making Fetch requests and you will be able to stub them.</p>\n<p>Hack implementation is here:</p>\n<pre><code class=\"language-javascript\">//  See: https://github.com/cypress-io/cypress/issues/95\nenableFetchWorkaround();\n\nfunction enableFetchWorkaround() {\n    let polyfill;\n\n    before(() =&gt; {\n        cy.log(&#39;Load fetch XHR polyfill&#39;);\n        cy.readFile(&#39;./cypress/support/polyfills/unfetch.umd.js&#39;).then((content) =&gt; {\n            polyfill = content\n        })\n    });\n\n    Cypress.on(&#39;window:before:load&#39;, (win) =&gt; {\n        delete win.fetch;\n        win.eval(polyfill);\n        win.fetch = win.unfetch\n    })\n}\n</code></pre>\n<p>Now you only need to import this hack in index.js:</p>\n<pre><code class=\"language-javascript\">import &#39;./hooks&#39;\n</code></pre>\n<p>And copy/paste fetch polyfill:</p>\n<pre><code class=\"language-javascript\">// https://unpkg.com/unfetch@4.1.0/dist/unfetch.umd.js\n\n!function(e,n){&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module?module.exports=n():&quot;function&quot;==typeof define&amp;&amp;define.amd?define(n):e.unfetch=n()}(this,function(){return function(e,n){return n=n||{},new Promise(function(t,o){var r=new XMLHttpRequest,s=[],u=[],i={},f=function(){return{ok:2==(r.status/100|0),statusText:r.statusText,status:r.status,url:r.responseURL,text:function(){return Promise.resolve(r.responseText)},json:function(){return Promise.resolve(JSON.parse(r.responseText))},blob:function(){return Promise.resolve(new Blob([r.response]))},clone:f,headers:{keys:function(){return s},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var a in r.open(n.method||&quot;get&quot;,e,!0),r.onload=function(){r.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm,function(e,n,t){s.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+&quot;,&quot;+t:t}),t(f())},r.onerror=o,r.withCredentials=&quot;include&quot;==n.credentials,n.headers)r.setRequestHeader(a,n.headers[a]);r.send(n.body||null)})}});\n</code></pre>\n<p>Working application with the following tests can be found here:</p>\n<p><a href=\"https://github.com/slawekradzyminski/reactfrontend\" target=\"_blank\" rel=\"noreferrer\">https://github.com/slawekradzyminski/reactfrontend</a></p>\n<p>Let me know in comments if you like to see more Cypress posts here :)</p>\n"
}