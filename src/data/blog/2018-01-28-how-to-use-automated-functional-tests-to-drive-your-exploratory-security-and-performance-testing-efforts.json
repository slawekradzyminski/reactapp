{
  "id": "2018-01-28-how-to-use-automated-functional-tests-to-drive-your-exploratory-security-and-performance-testing-efforts",
  "title": "How to use automated functional tests to drive your exploratory, security and performance testing efforts?",
  "date": "2018-01-28",
  "categories": [
    "Security"
  ],
  "tags": [
    "testing thoughts",
    "security",
    "performance testing"
  ],
  "permalink": "/2018/01/how-to-use-automated-functional-tests",
  "content": "<p><img src=\"/images/blog/silly.jpg\" alt=\"\" style=\"width: 100%;\"></p>\n<p>There is a growing need for technical testers who can test applications comprehensively. With such a low amount of top<br>specialists you may have been encouraged to extend your skill set not only in programming domain. Today I&#39;d like to show<br>you how to start with security, performance and exploratory testing in an easy way. What&#39;s important my approach is not<br>only easy, but also very effective.</p>\n<p>Let&#39;s say you are working in a quite mature project which is covered by automated functional tests written<br>using <a href=\"http://www.awesome-testing.com/search/label/API%20testing\" target=\"_blank\" rel=\"noreferrer\">Rest-Assured</a><br>or <a href=\"http://www.awesome-testing.com/search/label/selenium\" target=\"_blank\" rel=\"noreferrer\">Selenium</a> (I&#39;ve chosen these tools because my readers are<br>familiar with them - see blog history for multiple examples).</p>\n<p>The starting point is very simple. We would use existing test scenarios to capture HTTP traffic and play with it. Why?<br>Because I assume testing suites cover the most important functionalities from customer point of view.</p>\n<h2>Proxy basics</h2>\n<p>In order to capture traffic we will need a<a href=\"https://en.wikipedia.org/wiki/Proxy_server\" target=\"_blank\" rel=\"noreferrer\">proxy</a> which is a server (a<br>computer system or an application) that acts as an intermediary for requests from clients seeking resources from other<br>servers. This <a href=\"https://en.wikipedia.org/wiki/Proxy_server\" target=\"_blank\" rel=\"noreferrer\">Wikipedia</a> image explains the idea.</p>\n<p><img src=\"/images/blog/Proxy_concept_en.svg.png\" alt=\"\" style=\"width: 100%;\"></p>\n<h2>How to setup local proxy?</h2>\n<p>There are multiple tools which allow you to setup local proxy very quickly. Here are my recommendations + links to step<br>by step setup guides.</p>\n<p>a) <a href=\"http://jmeter.apache.org/\" target=\"_blank\" rel=\"noreferrer\">JMeter</a> - The Apache JMeter™ application is open source software, a pure 100% Java<br>application designed to load test functional behavior and measure performance.</p>\n<p><a href=\"https://github.com/slawekradzyminski/AwesomeTesting/blob/master/src/test/java/gui/proxy/jmeter_proxy_step_by_step.pdf\" target=\"_blank\" rel=\"noreferrer\">Link to JMeter proxy setup guide</a></p>\n<p>b) <a href=\"https://portswigger.net/burp\" target=\"_blank\" rel=\"noreferrer\">Burp</a> - graphical tool for testing Web application security. The tool is written in<br>Java and developed by PortSwigger Security.</p>\n<p><a href=\"https://support.portswigger.net/customer/portal/articles/1783055-configuring-your-browser-to-work-with-burp\" target=\"_blank\" rel=\"noreferrer\">Link to Burp proxy setup guide</a></p>\n<p>c) <a href=\"https://www.telerik.com/fiddler\" target=\"_blank\" rel=\"noreferrer\">Fiddler</a> - free web debugging tool which logs all HTTP(S) traffic between your<br>computer and the Internet. Inspect traffic, set breakpoints, and fiddle with incoming or outgoing data.</p>\n<p><a href=\"http://docs.telerik.com/fiddler/KnowledgeBase/Proxy\" target=\"_blank\" rel=\"noreferrer\">Link to Fiddler proxy setup guide</a></p>\n<p>d) <a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noreferrer\">Charles</a> - proxy that enables a developer to view all of the HTTP and SSL / HTTPS<br>traffic between their machine and the Internet.</p>\n<p><a href=\"https://www.charlesproxy.com/documentation/configuration/proxy-settings/\" target=\"_blank\" rel=\"noreferrer\">Link to Charles proxy setup guide</a></p>\n<p>e) <a href=\"https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project\" target=\"_blank\" rel=\"noreferrer\">OWASP ZAP</a> - one of the world’s most popular free<br>security tools which is actively maintained by hundreds of international volunteers</p>\n<p><a href=\"https://chrisdecairos.ca/intercepting-traffic-with-zaproxy/\" target=\"_blank\" rel=\"noreferrer\">Link to OWASP ZAP proxy setup guide</a></p>\n<h2>Implementation</h2>\n<p>All right. Traffic is being captured so now we need to generate. Thankfully as I mentioned in the introduction we<br>already have automated functional tests. How to run them via local proxy?</p>\n<p>a) Rest Assured</p>\n<p>For our API test we need... 1 line. In this example we have a local proxy running on port 8888.</p>\n<pre><code class=\"language-java\">RestAssured.proxy = host(&quot;localhost&quot;).withPort(8888);\n</code></pre>\n<p>b) Selenium</p>\n<p>With Selenium it&#39;s a bit more difficult. Let&#39;s assume we are using the most<br>stable <a href=\"https://sites.google.com/a/chromium.org/chromedriver/\" target=\"_blank\" rel=\"noreferrer\">chromedriver</a>. I have already explained how to play with<br>Chrome options in<br>my <a href=\"http://www.awesome-testing.com/2016/02/selenium-browser-capabilities-explained.html\" target=\"_blank\" rel=\"noreferrer\">Browser Capabilities Explained</a><br>post.</p>\n<p>Here is the code:</p>\n<pre><code class=\"language-java\">@Override\n    public WebDriver newWebDriver() {\n        return new ChromeDriver(getChromeCapabilities());\n    }\n\n    private DesiredCapabilities getChromeCapabilities() {\n        DesiredCapabilities capabilities = DesiredCapabilities.chrome();\n        capabilities.setCapability(ChromeOptions.CAPABILITY, getChromeOptions());\n        return capabilities;\n    }\n\n    private ChromeOptions getChromeOptions() {\n        ChromeOptions options = new ChromeOptions();\n        options.addArguments(getChromeSwitches());\n        return options;\n    }\n\n    private List&lt;String&gt; getChromeSwitches() {\n        List&lt;String&gt; chromeSwitches = new ArrayList&lt;&gt;();\n        chromeSwitches.add(&quot;--proxy-server=http://localhost:8888&quot;);\n        chromeSwitches.add(&quot;--ignore-certificate-errors&quot;);\n        return chromeSwitches;\n    }\n</code></pre>\n<p>Second switch (<code>--ignore-certificate-errors</code>) helps with https/certificate issues.</p>\n<p>After running your tests locally with such configuration you should have already captured http(s) traffic in your proxy.</p>\n<h2>Security testing usage</h2>\n<p>Traffic captured from functional tests is an excellent starting point for active/passive security scanning. At this<br>point you can just press start scanning (in Burp &amp; OWASP ZAP) knowing that you are testing the most important scenarios.<br>It&#39;s worth to add that attackers would probably start exploring your application going through the same scenarios.</p>\n<p>For more experienced security testers there is something even more important. Captured requests expose where untrusted<br>data can be injected into your application. According to<br>OWASP <a href=\"https://www.owasp.org/index.php/Injection_Theory\" target=\"_blank\" rel=\"noreferrer\">Injection Theory</a> document:</p>\n<p>Untrusted data is most often data that comes from the HTTP request, in the form of URL parameters, form fields, headers,<br>or cookies. But data that comes from databases, web services, and other sources is frequently untrusted from a security<br>perspective. That is, untrusted data is input that can be manipulated to contain a web attack payload.<br>The <a href=\"https://www.owasp.org/index.php/Searching_for_Code_in_J2EE/Java\" target=\"_blank\" rel=\"noreferrer\">OWASP Code Review Guide</a> has a decent list of<br>methods that return untrusted data in various languages, but you should be careful about your own methods as well.</p>\n<h2>Performance testing usage</h2>\n<p>Each step of automated functional test can be captured by Jmeter. I probably don&#39;t have to explain what does it mean to<br>you. Just save the steps, randomize some data, increase the number of concurrent threads and you have your performance<br>test ready. Wonderful, isn&#39;t it?</p>\n<h2>Exploratory testing usage</h2>\n<p>Fans of exploratory testing are probably already licking their lips seeing all possibilities. In HTTP request can be<br>twisted, spinned, rolled and reverted. Prizes can suddenly go below zero, shopping promotions above zero, names receive<br>Chinese symbols and checkout basket can suddenly reset to 0. I&#39;m sure you can see how convenient it is to have full<br>application request flow from the beginning of exploratory testing session.</p>\n"
}