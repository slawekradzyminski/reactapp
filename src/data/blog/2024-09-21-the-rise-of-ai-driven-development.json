{
  "id": "2024-09-21-the-rise-of-ai-driven-development",
  "title": "The rise of AI Driven Development",
  "date": "2024-09-21",
  "categories": [
    "AI"
  ],
  "tags": [
    "AI"
  ],
  "permalink": "/2024/09/the-rise-of-ai-driven-development",
  "content": "<p><img src=\"/images/blog/ai-robot.jpg\" alt=\"AI Robot {:width=&quot;50%&quot;}\" style=\"width: 100%;\"></p>\n<p>As the AI hype settles down a bit, now seems like the perfect time to reflect on what we&#39;ve learned so far. Nearly two years have passed since ChatGPT was released, and the majority of AI tools still rely heavily on Large Language Models (LLMs). Despite the hype, there&#39;s been no truly revolutionary advancement since then. However, LLMs are steadily becoming more clever, and that trend is likely to continue.</p>\n<p>From the beginning, my perspective on AI has been somewhat different. I never intended to integrate it into my products or focus on its development. Instead, I concentrated on the productivity boost it could bring to my daily workflow. I write articles, blog posts, speak at conferences, code, and manage a small team. While many others have chosen to focus on building their own AI-driven products, this has often resulted in various tools that are essentially just wrappers around the OpenAI API. A few of these have been successful, but in my view, most have not. The time and effort spent on these projects might have been better used focusing on core business objectives.</p>\n<p>In this post, I’ll share my journey toward understanding AI, what I’ve learned along the way, and my predictions for what’s to come.</p>\n<h2>My journey towards understanding</h2>\n<p>It all started in 2022, when I first began using ChatGPT. I was immediately captivated, and I remember enthusiastically recommending it to my team with a simple Slack message: <code>Use it, this is the future</code>. Not everyone shared my excitement, though. Looking back, I realize this was because their initial experiences were different from mine.</p>\n<p>My mind tends to connect concepts across <a href=\"https://www.ftfs.it/tips/interdisciplinary\" target=\"_blank\" rel=\"noreferrer\">various fields</a>—whether it’s software development or military strategy—and generative AI excels at creatively bridging those gaps. However, many people initially approached ChatGPT as more of an interactive knowledge base than a tool for generating novel insights. Even now in 2024, it’s important to note that while AI is powerful, it’s not an oracle.</p>\n<h3>Starting point</h3>\n<p>The beginnings weren&#39;t glamorous. They felt more like a first trip to the gym than Olympic weightlifting. I started with the math-heavy <a href=\"https://amzn.to/3XKQ1Tn\" target=\"_blank\" rel=\"noreferrer\">Artificial Intelligence: A Modern Approach</a>—a terrible idea for anyone who&#39;s not planning to develop AI themselves. That book is for AI researchers, not someone simply curious about how ChatGPT works. Luckily, I found <a href=\"https://amzn.to/3B90YoT\" target=\"_blank\" rel=\"noreferrer\">Grokking Artificial Intelligence Algorithms</a>, which turned out to be the perfect starting point for beginners.</p>\n<p>It took me some time to realize that I needed to dive deeper into <a href=\"https://amzn.to/3ZrMsma\" target=\"_blank\" rel=\"noreferrer\">Natural Language Processing and Neural Networks</a>. But here&#39;s the catch—studying Neural Networks makes no sense without a solid understanding of <a href=\"https://amzn.to/3MMqToW\" target=\"_blank\" rel=\"noreferrer\">Data Science</a> fundamentals. This led me to <a href=\"https://amzn.to/47x6AFE\" target=\"_blank\" rel=\"noreferrer\">Machine Learning</a>, where I had to grasp key concepts like overfitting, epochs, and cross-validation, which in turn opened the door to many other topics. The learning curve was steep, with each concept leading to several others.</p>\n<p>All of this learning was happening alongside the buzz around <code>Prompt Engineering,</code> a supposed job-stealer that, in reality, turned out to be a skill you can learn with some training. It&#39;s worth reminding here that any skill requires theoretical grounding, practice, and a bit of luck. I&#39;ll come back to this point later.</p>\n<p>Then there was <a href=\"https://github.com/yoheinakajima/babyagi\" target=\"_blank\" rel=\"noreferrer\">Baby AGI</a>, knocking at the door, promising to replace me. <a href=\"https://www.mattprd.com/p/the-complete-beginners-guide-to-autonomous-agents\" target=\"_blank\" rel=\"noreferrer\">Autonomous Agents</a> were, and still are, hyped up as game-changers. But as of today, they’ve been one of the biggest letdowns. The dream of delegating work to them is still just that—a dream. I had to learn this the hard way, because it seems no one was really evaluating them critically. Spoiler alert: even now, you can barely hand over the simplest tasks to these agents.</p>\n<h3>Connecting the dots</h3>\n<p>Fortunately, I wasn’t alone in my curiosity about how ChatGPT works. Many bright minds, including Stephen Wolfram, succeeded in breaking it down in simple terms. Even today, <a href=\"https://writings.stephenwolfram.com/2023/02/what-is-chatgpt-doing-and-why-does-it-work/\" target=\"_blank\" rel=\"noreferrer\">Stephen&#39;s article</a> remains one of the best explanations available. Another excellent resource is the <a href=\"https://ig.ft.com/generative-ai/\" target=\"_blank\" rel=\"noreferrer\">Financial Times piece</a> that came out later in 2023.</p>\n<p>At that time, I was also diving into a lot of obscure, unpublished books through my O’Reilly subscription. Looking back, I see that some of them are still in progress. From the ones that did get published, I highly recommend <a href=\"https://amzn.to/3Xt8cvq\" target=\"_blank\" rel=\"noreferrer\">Quick Start Guide to Large Language Models</a> and <a href=\"https://amzn.to/3TtH3Yb\" target=\"_blank\" rel=\"noreferrer\">Prompt Engineering for Generative AI</a>. These books often cover similar ground, but as someone who doesn’t consider themselves an expert, I found it helpful to see the same concepts explained from different angles. I need a lot of analogies to grasp complex ideas more clearly—and I’m sure I’m not alone in that.</p>\n<h3>Applying the knowledge</h3>\n<p>Alongside gaining theoretical knowledge, I began putting what I learned into practice in my daily work. One of the biggest breakthroughs came when I decided to migrate this blog from Blogger to Jekyll. Almost by accident, I discovered that ChatGPT is brilliant at handling custom, one-off scripts. Without any prior experience with Jekyll, I was able to migrate the entire archive of posts in a reasonable amount of time.</p>\n<p>LLMs also shine when it comes to generating and editing written content. For example, I’m writing this post using Cursor, which provides Copilot-like suggestions (known as Cursor Tab), and then refining the text with ChatGPT. I know fully understand that complex tasks/posts should be broken down into smaller chunks. It’s a great feeling when theory from books translates smoothly into real-world application.</p>\n<h3>Cursor - first WOW moment</h3>\n<p>I started following a few AI experts on Twitter, and one of them mentioned <a href=\"https://www.cursor.com/\" target=\"_blank\" rel=\"noreferrer\">Cursor</a>. I hadn’t heard of it before, but it looked intriguing. So, I created an account—and I was blown away by the user experience. Copy-pasting code into ChatGPT or using <a href=\"https://phind.com\" target=\"_blank\" rel=\"noreferrer\">phind.com</a> had started to feel tedious, but Cursor was a complete game-changer. It let me chat about my coding challenges in a much more natural, fluid way. At times, using Cursor felt like pair programming with an experienced colleague.</p>\n<p>This tool significantly helped me improve my <a href=\"https://github.com/slawekradzyminski/awesome-localstack\" target=\"_blank\" rel=\"noreferrer\">Dockerized localstack</a> for trainings. I&#39;ve also created several repositories with tests on various levels, the <a href=\"https://www.ftfs.it\" target=\"_blank\" rel=\"noreferrer\">ftfs.it</a> website, and even a <a href=\"https://gosiaradzyminska.pl/\" target=\"_blank\" rel=\"noreferrer\">personal site</a> for my wife. Cursor has become an crucial part of my outside daily work activities.</p>\n<h3>Becoming a teacher</h3>\n<p>I didn’t stop there. Richard Feynman once said that the <a href=\"https://www.ftfs.it/tips/feynman-technique\" target=\"_blank\" rel=\"noreferrer\">real understanding</a> comes when you explain a topic to someone else, and that advice stuck with me. As ambitious as it may sound, I decided to run a ChatGPT/AI training session for others, partnering with <a href=\"https://testerzy.pl/szkolenia/praktyka-testowania/efektywne-wykorzystanie-ai-w-testowaniu-od-chatgpt-do-generacji-kodu\" target=\"_blank\" rel=\"noreferrer\">testerzy.pl</a>. I had to build everything from scratch, including the entire course agenda. At first glance, it may not seem like much, but believe me, it was far from easy. Even today, such trainings are rare, so I had to plan every detail myself. I’m really proud of the outcome and grateful for the opportunity to teach others. In fact, the next session has already sold out.</p>\n<p>To maintain the momentum, I’ve also spoken at several conferences. Two of my talks were recorded:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=i5owU7RdC9g\" target=\"_blank\" rel=\"noreferrer\">Effective ChatGPT usage: start with understanding</a> - english</li>\n<li><a href=\"https://www.youtube.com/watch?v=U8iCGim-ro0\" target=\"_blank\" rel=\"noreferrer\">Prompt Engineering</a> - polish</li>\n</ul>\n<p>All I can is that Feynman was right. Teaching is the best way to learn. Writing this article is also a great learning experience.</p>\n<h2>Learnings</h2>\n<p>Enough about my journey—let’s get to the key takeaways. These are personal insights I’ve gained, things you won’t find in textbooks. For deeper theoretical understanding, I recommend the books I’ve mentioned earlier. </p>\n<h3>Don&#39;t show me what AI can&#39;t do, show me what it can do instead</h3>\n<p>Whenever a new AI model is released, we inevitably see countless posts highlighting its supposed stupidity. The internet fills with memes, mocking how &quot;dumb&quot; these tools can be. The issue is that many people expect large language models (LLMs)—which are ultimately just algorithms (albeit incredibly powerful ones)—to reason like humans. The term &quot;AI&quot; carries such weight that we forget these are still just tools designed to assist us, not replace human reasoning.</p>\n<p>My advice is simple: stop using AI for tasks it’s not built to handle. Just like you wouldn’t use a fork to eat soup, don’t expect an LLM to excel at things outside its core function.</p>\n<p><strong>Pro tip</strong>: One of the well-known limitations of LLMs is math. These models weren&#39;t designed for complex mathematical tasks—their training is centered around understanding and generating language. However, if you really need AI to handle more complex reasoning, try combining the <a href=\"https://www.promptingguide.ai/techniques/cot\" target=\"_blank\" rel=\"noreferrer\">Chain of Thought</a> (CoT) prompting technique with tools like OpenAI’s <a href=\"https://platform.openai.com/docs/assistants/tools/code-interpreter\" target=\"_blank\" rel=\"noreferrer\">Code Interpreter</a>. Together, they can significantly improve the performance on certain tasks that involve logical steps or calculations. Here’s an example of a prompt:</p>\n<blockquote class=\"blog-quote\"><p>Help me solve this math challenge:  </p></p></blockquote><blockquote class=\"blog-quote\"><p>A mother deer and a baby deer together weigh</p><p>220 pounds. The mother deer weighs 60 pounds</p><p>more than the baby deer. How much does the</p><p>baby deer weigh?  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Show me thinking step by step. Explain each step. Once you’ve finished write a Python script which will confirm that your calculations are correct. Run this script.  </p></p></blockquote><h3>Do it the hard way</h3>\n<p>In my experience, these are the main factors that determine your success when working with AI:</p>\n<ul>\n<li>50% – Understanding</li>\n<li>40% – Skill</li>\n<li>10% – Luck</li>\n</ul>\n<p>Whether we like it or not, understanding is the most crucial part. All the tools available—whether it&#39;s ChatGPT, AI-powered IDEs like Cursor, or extensions like GitHub Copilot—are simply different ways to interact with LLMs. Prompt engineering, in essence, is the skill of leveraging the strengths of these models while sidestepping their weaknesses. If you understand how tokenization works, how embeddings are created, and how attention mechanism glues everything together, you’ll naturally build better prompts and achieve more effective results.</p>\n<p><strong>Pro tip</strong>: One of the least utilized features of an LLM is its ability to ask you questions. This can be a powerful tool to check if you&#39;ve truly grasped the concept you&#39;re learning. For example, you can prompt it like this:</p>\n<blockquote class=\"blog-quote\"><p>I&#39;d like to test my understanding of how LLM works.  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Ask me a question and verify my answer which I&#39;ll provide later. Rate me from 1 to 10 where 10 is the best rate. Once you finished the rating ask me another question.  </p></p></blockquote><h3>Try to achieve something tangible</h3>\n<p>One of the most effective ways to learn is by setting a specific goal and working toward it using AI. As I mentioned earlier, my first real task with AI was migrating this blog from Blogger to Jekyll. It was a clear and well-defined task: the blog needed to be deployed on GitHub Pages using Jekyll.</p>\n<p>Here are a few ideas for tangible projects you can tackle with AI:</p>\n<ul>\n<li>Write a detailed blog post (like this one)</li>\n<li>Develop a new feature for your product</li>\n<li>Build a new test suite for your codebase</li>\n<li>Refactor the codebase to follow a particular design pattern</li>\n</ul>\n<p>The key advantage of aiming for something tangible is that it stops you from using AI for trivial tasks that don’t matter. You start to develop habits around when it’s smart to prompt and when it’s not. It takes time to replace old habits like Googling or turning to StackOverflow with the new habit of prompting AI, but it’s well worth the effort.</p>\n<p><strong>Pro tip</strong>: For complex tasks, break them into smaller pieces first. Make sure the LLM fully understands your objectives by encouraging it to ask questions about the task. As you continue the conversation in the same chat, the context will remain intact, allowing you to give simple, straightforward instructions instead of repeating detailed prompts.</p>\n<blockquote class=\"blog-quote\"><p>I&#39;d like to write a blogpost which describes why the flooding occur in the world.  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Do not generate it but first suggest me a list of bullet points. If you need more information ask me questions.  </p></p></blockquote><h3>Look at prompt holistically, take care of the context</h3>\n<p>One of the most overlooked aspects of prompt engineering is the use of <a href=\"https://help.openai.com/en/articles/8096356-custom-instructions-for-chatgpt\" target=\"_blank\" rel=\"noreferrer\">Custom instructions</a> and leveraging <a href=\"https://learn.microsoft.com/en-us/visualstudio/ide/copilot-chat-context?view=vs-2022\" target=\"_blank\" rel=\"noreferrer\">Coding Context</a> effectively. Even OpenAI’s official <a href=\"https://platform.openai.com/docs/guides/prompt-engineering\" target=\"_blank\" rel=\"noreferrer\">Prompt Engineering</a> guide, which is excellent overall, doesn’t dive deep into these topics.</p>\n<p>Custom instructions give you the ability to set the tone, style, and preferences for AI responses, allowing you to tailor the AI’s behavior to suit your needs. In coding environments, leveraging coding context, particularly with tools like Visual Studio and GitHub Copilot, can make a huge difference. By feeding the AI relevant information from your project, such as file structure, function names, or import paths, the output becomes much more accurate and context-aware.</p>\n<p>For instance, your coding IDE should let you easily configure this context, either by asking questions about the entire project (like the <code>@Codebase</code> feature in Cursor) or by selecting the necessary files for the task. With this setup, AI tools can better assist with precise, project-specific code suggestions, reducing the need for manual corrections.</p>\n<p>Visualize in your head that the input for an LLM isn’t just the text you type into the chat window—it includes the entire context of your session. It could look something like this:</p>\n<blockquote class=\"blog-quote\"><p>The user is using this system prompt:  </p>\n<p>[YOUR SYSTEM PROMPT]  </p>\n<p>=========================  </p>\n<p>The user has chosen these files for the context:  </p>\n<p>package.json  </p>\n<p>[PACKAGE.JSON CONTENT]  </p>\n<p>login.spec.ts  </p>\n<p>[LOGIN.SPEC.TS CONTENT]  </p>\n<p>userGenerator.ts  </p>\n<p>[USERGENERATOR.TS CONTENT]  </p>\n<p>=========================  </p>\n<p>The user has typed the following message:  </p>\n<p>I&#39;d like to test registration form.  </p>\n<p>This is registration API endpoint documentation  </p>\n<p>[REGISTRATION API ENDPOINT DOCUMENTATION]  </p>\n<p>DOM before action:   </p>\n<p>[DOM BEFORE ACTION]  </p>\n<p>DOM after action:   </p>\n<p>[DOM AFTER ACTION]  </p>\n<p>Generate tests for registration page. Cover success and error scenarios.  </p></p></blockquote><p>Obviously this just an example how AI-rich IDE may work. It is probably smarter in reality.</p>\n<p><strong>Pro tip</strong>: This how I configured ChatGPT to respond in Custom instructions:</p>\n<blockquote class=\"blog-quote\"><p>Answer a question given in a natural, human-like manner. Avoid words which are associated with AI/robot-like language. If you don&#39;t know the answer ask me clarifying questions, do not hallucinate.  </p></p></blockquote><p><strong>Pro tip</strong>: This is how I configured <a href=\"https://docs.cursor.com/context/rules-for-ai\" target=\"_blank\" rel=\"noreferrer\">Rules for AI</a> in Cursor for <a href=\"https://www.ftfs.it\" target=\"_blank\" rel=\"noreferrer\">ftfs.it</a> project:</p>\n<blockquote class=\"blog-quote\"><p>Typescript/JS projects:  </p>\n<ul>\n<li>I&#39;m using npm  </li>\n<li>I prefer arrow functions so always suggest <code>const name = () =&gt; {</code> over <code>function</code>  </li>\n<li>prefer imports over require() syntax  </li>\n<li>I&#39;m using React Router v6</li>\n</ul></p></blockquote><h3>Don&#39;t hurry</h3>\n<p>Social media algorithms are optimized to keep us engaged, which means we&#39;re constantly exposed to the latest hyped-up AI tools. This creates the illusion that AI is evolving at lightning speed. We keep hearing that AGI (Artificial General Intelligence) is just around the corner and that we should brace ourselves for its arrival any moment now.</p>\n<p>Since ChatGPT’s release, my approach has always been grounded in one simple question: How can this tool support the tasks I’ve already been doing? It’s a useful filter. We often get excited about how Autonomous Agents solve problems we don&#39;t even have. But once we try to apply them to our actual work, we quickly notice their limitations and poor results.</p>\n<p>The same goes for open-source LLMs. Every other day, we hear about how they’ve reached some impressive score on a mysterious leaderboard, with claims that they’re nearly as good as Claude or ChatGPT. The reality? These advancements often have little impact on real-world applications. Running these models locally can be more expensive than just using premium accounts for existing, reliable services.</p>\n<p><strong>Pro tip</strong>: When a new AI tool is released, let the hype settle before jumping in. After some time, look at the actual, tangible results it has produced. That’s when you’ll know if it’s worth your attention.</p>\n<h3>LLM loves boundaries and strict validations</h3>\n<p>Large Language Models (LLMs) rely heavily on embeddings to process and understand text. Embeddings are vector representations of words, phrases, or even sentences, which help the model capture semantic meaning and relationships between words. You can visualize embeddings as a set of points in a multi-dimensional space, where each dimension represents a different aspect of the text. The distance between points in this space corresponds to the semantic similarity between the texts they represent.</p>\n<p>While in reality the number of dimensions is much higher, you can imagine it as a 3D graph using this <a href=\"https://www.cs.cmu.edu/~dst/WordEmbeddingDemo/\" target=\"_blank\" rel=\"noreferrer\">interactive demo</a> or image below.</p>\n<p><img src=\"/images/blog/embeddings.png\" alt=\"Embeddings\" style=\"width: 100%;\"></p>\n<p>Image source: <a href=\"https://aws.amazon.com/what-is/embeddings-in-machine-learning/\" target=\"_blank\" rel=\"noreferrer\">AWS</a></p>\n<p>AI excels when operating within environments that have a small, consistent dictionary—such as YAML, JSON, Bash, or Python. These languages have a relatively limited set of instructions, and their clear structure plays to the strengths of LLMs, allowing for more accurate predictions and completions. However, when we switch to more complex and flexible languages like Chinese or Polish, LLMs tend to struggle. This is because the embeddings for these languages are more difficult to map accurately due to the vast number of characters, grammatical rules, and nuances involved.</p>\n<p>For the best results, it’s recommended to prompt LLMs in English whenever possible. English is an easier language for the model to handle because tokenization and embeddings were optimized primarily for it. The simpler grammar and smaller vocabulary make it easier for the model to interpret and generate accurate outputs.</p>\n<p><strong>Pro tip</strong>: This is very simple task for LLM:</p>\n<blockquote class=\"blog-quote\"><p>Write a python script which will generate 1000 rows in users.csv file in the following format:  </p>\n<p>firstName,lastName,age,email  </p>\n<p>Slawomir,Radzyminski,18,<a href=\"mailto:slawomir@gmail.com\" target=\"_blank\" rel=\"noreferrer\">slawomir@gmail.com</a>  </p>\n<p>John,Lennon,30,<a href=\"mailto:john.lennon@yahoo.com\" target=\"_blank\" rel=\"noreferrer\">john.lennon@yahoo.com</a>  </p>\n<p>...  </p>\n<p>...  </p>\n<p>...  </p>\n<p>Once you&#39;ve finished use the Code Interpreter and run the script to test that it indeed has 1000 rows (+ 1 row with header). Give me the link to download the file.  </p></p></blockquote><h3>Let the AI to self examine itself</h3>\n<p>Many prompt engineering guides recommend evaluating the quality of an AI&#39;s response, such as in this helpful <a href=\"https://github.com/BrightPool/prompt-engineering-for-generative-ai-examples/blob/main/images/OnePager-Text.png\" target=\"_blank\" rel=\"noreferrer\">one-pager</a>. However, this step is often overlooked, with many assuming that evaluating and improving responses is something OpenAI or Claude should handle, not us as users.</p>\n<p>You may have noticed that I often ask LLMs to self-examine their responses using tools like the Code Interpreter. This approach significantly improves the quality of outputs, as it allows the model to go through multiple iterations and correct its own mistakes. The process of having the AI review and refine its responses makes a huge difference in accuracy and reliability.</p>\n<p>I expect this trend—getting AI to self-examine and refine its results—to become a standard practice in LLM usage.</p>\n<p><strong>Pro tip</strong>: Despite the memes joking that LLMs can&#39;t count the &quot;r&quot;s in the word strawberry, they actually can—especially when they’re prompted to self-check their work.</p>\n<blockquote class=\"blog-quote\"><p>Using Code Interpreter write a script which count r letters in strawberry word  </p>\n<p>Design and run a test which will confirm that your output is correct.  </p></p></blockquote><h3>Treat LLM as algorithm, not like a human being</h3>\n<p>The paper <em>Principled Instructions Are All You Need</em> available on <a href=\"https://arxiv.org/pdf/2312.16171\" target=\"_blank\" rel=\"noreferrer\">arXiv</a> provides multiple data-backed insights into improving the quality of prompts. A few examples:</p>\n<blockquote class=\"blog-quote\"><p>If you prefer more concise answers, no need to be polite with LLM so there is no need to add phrases like “please”, “if you don’t mind”, “thank you”, “I would like to”, etc., and get straight to the point.  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Add “I’m going to tip $xxx for a better solution!”  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Incorporate the following phrases: “Your task is” and “You MUST”.  </p></p></blockquote><blockquote class=\"blog-quote\"><p>Incorporate the following phrases: “You will be penalized”.  </p></p></blockquote><p>You shouldn’t treat an LLM like a peer; instead, think of it as an algorithm that needs to be ruled by you. Your instructions should be clear, precise, and direct. Use plain, straightforward language when issuing commands. The goal is to give orders, not suggestions. There’s no need for politeness—on the contrary, being polite can actually lead to less efficient results. Micromanagement, while destructive in human-to-human communication, is recommended when dealing with AI. You’re the boss, the decision-maker, the dictator in this relationship with the AI.</p>\n<p>Odd as it may sound, anything branded as <code>AI</code> tends to stir up hidden fears and negative emotions in people. We naturally want to prove we’re smarter, and this leads us to focus on AI’s shortcomings instead of its strengths. But it’s crucial to shift your mindset—treat it like the algorithm it is. Find ways to exploit its capabilities to your advantage.</p>\n<p><strong>Pro tip</strong>: Treat prompts as orders. </p>\n<h3>Don&#39;t get yourself into AI dead-end</h3>\n<p>No matter your knowledge level or experience, you’ll likely encounter situations where you hit a dead-end during an LLM conversation. Here are some signs that you’ve reached one:</p>\n<ul>\n<li>The LLM repeats the same information over and over.</li>\n<li>The LLM suggests solution A, which doesn’t work. You request solution B, which also fails. Instead of offering solution C, it keeps giving you A and B, even though neither works.</li>\n<li>Instead of generating code, the LLM starts providing generic debugging tips.</li>\n</ul>\n<p>If you notice these signs, it’s a good idea to end the conversation and start fresh. In my experience, continuing at this point is often futile. Each new prompt includes the previous conversation’s context, and when that context gets corrupted, further interaction usually becomes a waste of time. In such cases, I recommend rephrasing the task, breaking it down into smaller steps, or seeking help from Google or StackOverflow to deepen your understanding of the issue.</p>\n<p>This is also why I don’t advise delegating tasks entirely to LLMs. They require diligent supervision. If you&#39;re working on something you don’t fully understand, you&#39;re likely to find yourself in a dead-end that’s hard to navigate out of. It’s best to avoid using AI for tasks you can’t oversee or comprehend fully.</p>\n<p><strong>Pro tip</strong>: Dump conversation that is not working. Start fresh with new prompt.</p>\n<h3>Code quality matters</h3>\n<p>The coding process is undergoing a revolution driven by LLMs. Tasks that once required human-level intelligence are now being fully managed by AI, with a growing percentage of production code generated through these models. Repetitive tasks like test creation are now efficiently handled using smart few-shot prompting.</p>\n<p>However, from my experience, clean code principles are as important as ever, especially:</p>\n<ul>\n<li>DRY (Don&#39;t Repeat Yourself)</li>\n<li>KISS (Keep It Simple, Stupid)</li>\n<li>YAGNI (You Ain&#39;t Gonna Need It)</li>\n</ul>\n<p>LLMs operate with limited context, and each token must pass through multiple attention mechanisms to interpret the prompt’s intent. This means that the more tokens (words, characters) involved, the harder it is for the AI to understand and execute tasks accurately. Long, spaghetti-like code not only fills up the model’s context window with unnecessary tokens but also increases the chances of hallucination. Just as unclear code confuses human developers, it also confuses AI.</p>\n<p>Also, keep in mind that the <code>@Codebase</code> feature in Cursor (<code>@workspace</code> in Visual Studio&#39;s GitHub Copilot extension) uses a semantic search algorithm to find relevant files. Since it&#39;s impossible to include every file in a single outgoing prompt, this algorithm works more effectively when the project is well-organized. The IDE will select and send only the files it deems most relevant to the LLM prompt, so keeping your codebase tidy and structured will ensure more accurate and useful results from these tools.</p>\n<p><strong>Pro tip</strong>: If you rely heavily on AI, take extra care with the overall length of your files and classes. Enforce the limits by using code analysis tools like SonarQube or Linters.</p>\n<h3>Low level test coverage is essential</h3>\n<p>Just as simplicity is key in code design, tests serve as a vital safety net to catch AI-generated errors. You’ll quickly notice that LLMs can occasionally produce silly mistakes, which might slip through without a strong test suite in place. Testing ensures these errors are caught before they cause real issues.</p>\n<p>I predict that testing will become even more crucial in the future. In fact, the ability for AI to generate code and verify it through automated tests could be the next major advancement in AI-powered IDEs. Now is the time to invest in low-level tests that focus on a fast feedback loop. AI thrives on iteration, and an efficient testing cycle is critical to enabling rapid refinement. Open AI Code Interpreter is a good example of this approach.</p>\n<p><strong>Pro tip</strong>: Contrary to popular belief, software testing might actually become more important as AI advances.</p>\n<h2>Future</h2>\n<p>The last point offers a glimpse into the future of AI-powered development. You already know I expect AI-rich IDEs to soon be capable of running tests autonomously, but what else might be on the horizon?</p>\n<h3>Book renaissance</h3>\n<p>In the age of AI, we are witnessing a renaissance of deep, structured knowledge—a key reason why <a href=\"https://www.ftfs.it/tips/on-reading-regularly\" target=\"_blank\" rel=\"noreferrer\">books are more relevant</a> than ever. Since it&#39;s crucial to start prompting with the end goal in mind, having extensive knowledge across multiple domains has never been so important. The more you know, the better equipped you are to guide AI toward useful outcomes, avoiding shallow results or errors.</p>\n<p>Additionally, as linguistic nuances are easily managed by LLMs, engineers should elevate their focus to higher-level, more <a href=\"https://www.ftfs.it/tips/elevate-your-perspective\" target=\"_blank\" rel=\"noreferrer\">strategic matters</a>. Rather than getting bogged down in syntax or language details, the emphasis should shift toward design, architecture, and long-term vision. This shift allows engineers to think big, leveraging AI as a tool for generating code.</p>\n<h3>Testing renaissance</h3>\n<p>The role of testing may undergo a major transformation in the future, evolving into more than just a tool for detecting bugs. As Autonomous Agents potentially take over various development tasks, tests could become essential guides. Rather than simply ensuring that code functions as expected, tests may serve as the requirements that define what these agents should strive for. They could provide clear targets for AI to meet, ensuring the output aligns with the intended functionality. In this way, tests may shift from being reactive tools to proactive frameworks shaping the direction of AI-driven development.</p>\n<p>Another crucial change might be the increasing importance of speed optimization in testing. As AI takes on more code generation, the speed at which tests provide feedback may directly influence the efficiency of AI’s iterative processes. Faster testing cycles could lead to quicker corrections and adjustments, enabling AI to produce higher-quality code in less time. In this emerging landscape, optimizing test speed may no longer be just a nice-to-have but a key factor in maintaining the smooth flow of AI code generation.</p>\n<p>Additionally, programmers&#39; roles are likely to shift as more code is generated by algorithms. In the future, programmers may spend less time writing code themselves and more time ensuring the quality of AI-generated code. This change could make robust testing even more essential, as tests will be the primary safeguard against errors and inconsistencies in AI-driven output. Since algorithms cannot yet be fully trusted, tests will be critical to ensuring that AI-generated code meets high standards of functionality and reliability.</p>\n<h3>Learning revolution</h3>\n<p>As an active trainer in both AI and software testing, I have firsthand insight into how people perceive LLMs in their daily work. Broadly, they fall into two groups:</p>\n<ul>\n<li>Enthusiasts: Those who are eager to learn prompting techniques and how LLMs can expand their capabilities.</li>\n<li>Critics: Those who consistently downplay the potential of LLMs, focusing on what they believe the AI cannot do (e.g., X, Y, or Z).</li>\n</ul>\n<p>For the critics, I recommend a more practical approach. Force yourself to use AI for tasks where it excels, such as CI configuration, ad-hoc scripting, test data generation, text editing, or repetitive test creation. The reality is, I can’t see the current trend reversing. While the progress may be slower than some AI advocates suggest, it is undeniably happening.</p>\n<p>This LLM evolution also presents a challenge for newcomers to the industry. On one hand, deep understanding of fundamental concepts is becoming even more critical, but on the other, LLMs are speeding up work in such a way that there is less time to experiment with different approaches, step-by-step debugging, or deep learning. For example, when I mentored an intern who joined my team, I advised him to focus on building a high-level understanding. If he&#39;s working with React, it&#39;s crucial to grasp when re-renders happen, how hooks work, how it translates into JavaScript executed in the browser, and the difference between <a href=\"https://ui.dev/imperative-vs-declarative-programming\" target=\"_blank\" rel=\"noreferrer\">imperative and declarative</a> programming.</p>\n<p>Only time will tell whether this approach will fully prepare newcomers, but the balance between understanding the fundamentals and leveraging AI tools is the key challenge of this new era in learning. </p>\n<h2>Closing thought</h2>\n<p>There is no doubt that we&#39;re approaching the AI-Driven Development. But what does it mean exactly? No one knows for sure.</p>\n"
}