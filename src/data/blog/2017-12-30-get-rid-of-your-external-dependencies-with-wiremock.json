{
  "id": "2017-12-30-get-rid-of-your-external-dependencies-with-wiremock",
  "title": "Get rid of your external dependencies with WireMock",
  "date": "2017-12-30",
  "categories": [
    "API testing"
  ],
  "tags": [
    "API testing",
    "security"
  ],
  "permalink": "/2017/12/get-rid-of-your-external-dependencies",
  "content": "<p><img src=\"/images/blog/wiremock.jpg\" alt=\"\"></p><p>So far in my posts focusing on <a href=\"http://www.awesome-testing.com/search/label/API%20testing\" target=\"_blank\" rel=\"noreferrer\">API testing</a> I was using external services only. This isn&#39;t particularly bad for higher level tests, but sometimes we would like to work on our localhosts only. This eliminates potential flakiness related to network fluctuations, deployment being in progress or general instability of services we rely on. Today I&#39;d like to recommend you one tool that hugely simplifies our quest for testing an app in total isolation - <a href=\"http://wiremock.org/\" target=\"_blank\" rel=\"noreferrer\">WireMock</a>. It&#39;s not a tool just got released and doesn&#39;t work for anyone except the author, it&#39;s more like established industry standard used by many companies (including Pivotal).</p><p>I read once that someone didn&#39;t like my Rest Assured post. Reader was claiming that it&#39;s too old framework to show on blogs. The thing is I want my readers to learn valuable stuff and reuse my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting\" target=\"_blank\" rel=\"noreferrer\">GitHub examples</a> so I don&#39;t want to change my approach in &#39;<br>technical&#39; posts. My general recommendation regarding tools is pretty much aligned with what I present here: always choose older and more popular one unless you are 100% sure that new &#39;cutting-edge&#39; tool is indeed that great. <a href=\"https://gatling.io/\" target=\"_blank\" rel=\"noreferrer\">Gatling</a> is perfect example of that. I know a lot of people who thought it brilliant, but upon problems with more complex scenarios gave it up and came back to<a href=\"http://jmeter.apache.org/\" target=\"_blank\" rel=\"noreferrer\">JMeter</a> instead.</p><h2>Getting started</h2>\n<p>As usual, we need to add Maven dependency first. I&#39;m including also javax.json library for simple JSON creation, but you can choose what you want here.</p><pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>javax.json<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>javax.json-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.1.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.glassfish<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>javax.json<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.1.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.github.tomakehurst<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>wiremock<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.12.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\nview raw</code></pre><p>Unfortunately I had also a lot of problem with my classpath. WireMock uses jetty server 9.22 which is pretty old. This generates conflicts with selenium-java so I had to add a lot of ugly exclusions in my pom.<br>See <a href=\"https://github.com/slawekradzyminski/AwesomeTesting/commit/fec306d18285dc79f6fa24dc80e620c3871d46b4\" target=\"_blank\" rel=\"noreferrer\">commit</a> for details. This may happen for you so get ready to analyse your <em>mvn dependency:tree</em>.</p><h2>Framework preparation</h2>\n<p>A bit of side note first: I often hear that testers would like have some kind of online portfolio available publicly. I recommend to follow my path and integrate blogging with coding. It gives me a lot of online presence with relatively small effort. As a bonus I guarantee you that even with such a simple tests you would learn something extra for yourself.</p><p>End of chit-chat, now real stuff.</p><p>First of all opposite to what I usually do I&#39;ll be using Junit. By the way there is definitely not a good idea to mix TestNG and Junit in on project. My IntelliJ was struggling to choose proper framework automatically and I had to choose import after every @Test. Do yourself a favor and don&#39;t follow my path - chose Junit from start ;)</p><p>I chose to use hierarchical approach in my tests. This class would be extended by each Test class.</p><p>There are three methods:</p><ul>\n<li><p>JUnit WireMock @Rule starts server on random port (it&#39;s important to randomize it because it allows us to run tests simultaneously).</p></li>\n<li><p>We set port for RestAssured baseUrl (it would be <a href=\"http://localhost\" target=\"_blank\" rel=\"noreferrer\">http://localhost</a>: + this port)</p></li>\n<li><p>We cleanUp stubs after each test</p></li>\n</ul>\n<pre><code class=\"hljs language-plaintext\">\n    @Rule\n    public WireMockRule wireMockRule =\n            new WireMockRule(wireMockConfig().dynamicPort().portNumber());\n\n    @Before\n    public void configureRestAssured() {\n        RestAssured.port = wireMockRule.port();\n        RestAssured.registerParser(JSON.toString(), Parser.JSON);\n    }\n\n    @After\n    public void cleanUp() {\n        wireMockRule.resetAll();\n    }\n\n}</code></pre><h2>Simple examples</h2>\n<p>I have prepared three very simple scenarios. Please take a look at @Before section. That&#39;s where all the WireMock magic happens. We can define what kind of requests would be captured and how WireMock would respond for them. In this example GET request for <a href=\"http://localhost:port/ip\" target=\"_blank\" rel=\"noreferrer\">http://localhost:port/ip</a> returns JSON defined in <code>getMockedIpEndpointJson()</code> method.</p><p>For actual request sending I&#39;m using <a href=\"http://rest-assured.io/\" target=\"_blank\" rel=\"noreferrer\">RestAssured</a> which is familiar for my readers.</p><p>As you can see WireMock allows us to build requests in almost the same way as RestAssured. Those two frameworks make great duo.</p><pre><code class=\"hljs language-plaintext\">\n    @Before\n    public void setUp() {\n        stubFor(get(urlEqualTo(&quot;/ip&quot;))\n                .withHeader(&quot;Accept&quot;, equalTo(JSON.toString()))\n                .willReturn(aResponse()\n                        .withStatus(200)\n                        .withHeader(&quot;Content-Type&quot;, JSON.toString())\n                        .withBody(getMockedIpEndpointJson())));\n    }\n\n    private String getMockedIpEndpointJson() {\n        return Json.createObjectBuilder()\n                .add(&quot;ip&quot;, &quot;127.0.0.1&quot;)\n                .build().toString();\n    }\n\n    @Test\n    public void ipTest() {\n        given()\n                .contentType(JSON)\n                .header(&quot;Accept&quot;, JSON.toString())\n                .when()\n                .get(&quot;/ip&quot;)\n                .then()\n                .body(&quot;ip&quot;, containsString(&quot;127.0.0.1&quot;));\n    }</code></pre><p>Second test is almost identical, but contains more complex assertions.</p><pre><code class=\"hljs language-plaintext\">\n    private static final String EMPLOYEES = &quot;employees&quot;;\n    private static final String MANAGER = &quot;managers&quot;;\n    private static final String FIRST_NAME = &quot;firstName&quot;;\n    private static final String LAST_NAME = &quot;lastName&quot;;\n\n    @Before\n    public void setUp() {\n        stubFor(get(urlEqualTo(&quot;/staff&quot;))\n                .withHeader(&quot;Accept&quot;, equalTo(JSON.toString()))\n                .willReturn(aResponse()\n                        .withStatus(200)\n                        .withHeader(&quot;Content-Type&quot;, JSON.toString())\n                        .withBody(getMockedStaffEndpointJson())));\n    }\n\n    private String getMockedStaffEndpointJson() {\n        return Json.createObjectBuilder()\n                .add(EMPLOYEES, Json.createArrayBuilder()\n                        .add(Json.createObjectBuilder()\n                                .add(FIRST_NAME, &quot;John&quot;).add(LAST_NAME, &quot;Doe&quot;))\n                        .add(Json.createObjectBuilder()\n                                .add(FIRST_NAME, &quot;Jessica&quot;).add(LAST_NAME, &quot;Alba&quot;))\n                        .add(Json.createObjectBuilder()\n                                .add(FIRST_NAME, &quot;Emma&quot;).add(LAST_NAME, &quot;Stone&quot;)))\n                .add(MANAGER, Json.createArrayBuilder()\n                        .add(Json.createObjectBuilder()\n                                .add(FIRST_NAME, &quot;Janusz&quot;).add(LAST_NAME, &quot;Biznesu&quot;)))\n                .build().toString();\n    }\n\n    @Test\n    public void staffTest() {\n        given()\n                .contentType(JSON)\n                .header(&quot;Accept&quot;, JSON.toString())\n                .when()\n                .get(&quot;/staff&quot;)\n                .then()\n                .body(&quot;employees[0].lastName&quot;, containsString(&quot;Doe&quot;))\n                .body(&quot;employees.size()&quot;, is(3))\n                .body(&quot;managers.size()&quot;, is(1))\n                .body(&quot;employees.firstName&quot;, containsInAnyOrder(&quot;John&quot;, &quot;Jessica&quot;, &quot;Emma&quot;));\n    }\n\n}</code></pre><p>Last but not least we can of course use POST, PUT, DELETE methods. Here is rather silly POST example.</p><pre><code class=\"hljs language-plaintext\">\n    @Before\n    public void setUp() {\n        stubFor(post(urlEqualTo(&quot;/addPerson&quot;))\n                .withHeader(&quot;Accept&quot;, equalTo(JSON.toString()))\n                .withRequestBody(equalToJson(getUserJson()))\n                .willReturn(ok()));\n    }\n\n    private String getUserJson() {\n        return Json.createObjectBuilder()\n                .add(&quot;firstName&quot;, &quot;Slawomir&quot;)\n                .add(&quot;lastName&quot;, &quot;Radzyminski&quot;)\n                .add(&quot;age&quot;, &quot;18&quot;)\n                .build().toString();\n    }\n\n    @Test\n    public void postTest() {\n        given()\n                .contentType(JSON)\n                .header(&quot;Accept&quot;, JSON.toString())\n                .body(getUserJson())\n                .when()\n                .post(&quot;/addPerson&quot;)\n                .then()\n                .statusCode(SC_OK);\n    }\n\n}</code></pre><p>Isn&#39;t it beautiful? :)</p>"
}