{
  "id": "2019-04-04-headless-browser-testing-with-selenium",
  "title": "Headless Browser Testing with Selenium",
  "date": "2019-04-04",
  "categories": [
    "Selenium"
  ],
  "tags": [
    "selenium"
  ],
  "permalink": "/2019/04/headless-browser-testing-with-selenium",
  "content": "<p><img src=\"/images/blog/suit-158819_960_720.png\" alt=\"\" style=\"width: 100%;\"></p>\n<p>A headless browser is a very popular term in the testing community which refers to a web browser running without<br>Graphical User Interface (GUI). A headless browser can access any website but unlike normal browsers (which you<br>currently use) nothing will appear on the screen. Everything is done on the backend side invisible to the user.</p>\n<p>Recent popularity rise of such browsers led to the creation of a new term: headless testing. It is running a UI-based<br>browser test using a headless browser.</p>\n<p>In this article, I&#39;m going to explain when is it worth to use headless browser and what are the actual limitations. As<br>usual, I have also prepared a Java demo with 5 most popular headless browsers used with Selenium WebDriver - Chrome,<br>Firefox, HtmlUnit, PhantomJS, and JBrowser.</p>\n<h2>Benefits of headless testing</h2>\n<p>Why do people use headless browsers?</p>\n<p>a) Speed - since headless browsers donâ€™t have a UI, they are faster than real browsers.</p>\n<p>b) Dependencies - sometimes you don&#39;t have full access to test environment and headless browsers are much easier to<br>setup on Continuous Integration servers like Jenkins</p>\n<p>c) Data extraction - if your task is to scrape some data from website headless browser would do it much faster</p>\n<p>d) Performance monitoring - headless browsers are often used<br>to <a href=\"https://www.awesome-testing.com/2019/01/measuring-page-load-times-using-selenium.html\" target=\"_blank\" rel=\"noreferrer\">measure the client-side performance</a></p>\n<p>e) Layout testing - headless browsers are useful when testing layout (for example<br>with <a href=\"http://galenframework.com/\" target=\"_blank\" rel=\"noreferrer\">Galen framework</a>). You can even automate screen captures for layout checks</p>\n<h2>Limitations of headless testing</h2>\n<p>When you should not use headless browsers?</p>\n<p>a) Functional tests - your users are not using a headless browser. You need a real browser to provide real feedback.</p>\n<p>b) Debugging - headless browsers are hard to debug. You can&#39;t visually follow your tests step by step.</p>\n<h2>Demo introduction</h2>\n<p>This time demo will be done using pure Selenium which you can copy paste into your project. I&#39;ll reuse page objects<br>which have been fully introduced<br>in <a href=\"https://www.awesome-testing.com/2018/05/selenium-vs-fluentlenium.html\" target=\"_blank\" rel=\"noreferrer\">Selenium vs FluentLenium post</a>. In order to<br>keep this post at a reasonable length, I&#39;ll skip a few implementation details. Please refer to<br>my <a href=\"https://github.com/slawekradzyminski/AwesomeTesting/commit/9a2b73a3c65897c8140394c2588ad03878c0b522\" target=\"_blank\" rel=\"noreferrer\">GitHub project</a><br>for details.</p>\n<p>Each headless driver would run the following scenario:</p>\n<ol>\n<li>Open <a href=\"https://awesome-testing.com/\" target=\"_blank\" rel=\"noreferrer\">Awesome Testing blog</a></li>\n<li>Search for &#39;public speaking&#39; term</li>\n<li>Verify that something has been found</li>\n<li>Click on the first found article</li>\n<li>Verify the comments section is present in the article</li>\n</ol>\n<p>Inheritance will be used to make this method available for each headless test.</p>\n<pre><code class=\"language-java\">abstract class AbstractHeadlessTest {\n\n    MyProperties myProperties = new MyProperties();\n\n    void shouldSuccessfullyFindPostAndDisplayCommentsSection(WebDriver driver) {\n        driver.get(&quot;https://www.awesome-testing.com&quot;);\n\n        new MainPage(driver)\n                .searchFor(&quot;public speaking&quot;)\n                .assertThatPostsAreDisplayed()\n                .clickOnFirstPost()\n                .assertThatCommentSectionIsDisplayed();\n    }\n}\n</code></pre>\n<p>Just for reference here is how search method implementation looks like.</p>\n<pre><code class=\"language-java\">public SearchResultsPage searchFor(String searchTerm) {\n        searchBar.clear();\n        searchBar.sendKeys(searchTerm);\n        searchButton.click();\n        return new SearchResultsPage(driver);\n    }\n</code></pre>\n<p>And final assertion...</p>\n<pre><code class=\"language-java\">public void assertThatCommentSectionIsDisplayed() {\n        wait.until(ExpectedConditions.presenceOfElementLocated(By.id(&quot;comments&quot;)));\n    }\n\n    private Wait&lt;WebDriver&gt; wait = new FluentWait&lt;&gt;(driver)\n            .withTimeout(Duration.ofSeconds(5))\n            .pollingEvery(Duration.ofMillis(500))\n            .ignoring(NoSuchElementException.class)\n            .withMessage(&quot;Oops, element didn&#39;t appear!&quot;);\n</code></pre>\n<h2>Chrome</h2>\n<p>Google Chrome is perhaps the most popular headless browser. In order to use ChromeDriver, the following dependency is<br>required.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-chrome-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.141.59&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Setup requires adding two chrome switches into Chrome options: <code>--headless, --disable-gpu</code></p>\n<pre><code class=\"language-java\">public class HeadlessChromeTest extends AbstractHeadlessTest {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        System.setProperty(&quot;webdriver.chrome.driver&quot;,\n                           myProperties.getProperty(&quot;my_chrome_path&quot;));\n        driver = new ChromeDriver(getChromeOptions());\n    }\n\n    private ChromeOptions getChromeOptions() {\n        ChromeOptions options = new ChromeOptions();\n        List&lt;String&gt; chromeSwitches = new ArrayList&lt;&gt;();\n        chromeSwitches.add(&quot;--headless&quot;);\n        chromeSwitches.add(&quot;--disable-gpu&quot;);\n        options.addArguments(chromeSwitches);\n        return options;\n    }\n\n    @Test\n    public void chromeTest() {\n        shouldSuccessfullyFindPostAndDisplayCommentsSection(driver);\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n}\n</code></pre>\n<p>For details and FluentLenium example, please refer to<br>my <a href=\"https://www.awesome-testing.com/2017/05/headless-testing-with-google-chrome.html\" target=\"_blank\" rel=\"noreferrer\">Headless Chrome</a> post.</p>\n<h2>Firefox</h2>\n<p>Firefox browser doesn&#39;t require an introduction as well. In order to use FirefoxDriver, the following dependency is<br>required.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;3.141.59&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Setup requires adding one argument into Firefox: <code>--headless</code></p>\n<pre><code class=\"language-java\">public class HeadlessFirefoxTest extends AbstractHeadlessTest {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        System.setProperty(&quot;webdriver.gecko.driver&quot;,\n                           myProperties.getProperty(&quot;my_gecko_path&quot;));\n        driver = new FirefoxDriver(getFirefoxOptions());\n    }\n\n    private FirefoxOptions getFirefoxOptions() {\n        FirefoxOptions options = new FirefoxOptions();\n        options.addArguments(&quot;--headless&quot;);\n        return options;\n    }\n\n    @Test\n    public void firefoxTest() {\n        shouldSuccessfullyFindPostAndDisplayCommentsSection(driver);\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n}\n</code></pre>\n<p>For details and FluentLenium example, please refer to<br>my<a href=\"https://www.awesome-testing.com/2017/09/headless-testing-with-firefox.html\" target=\"_blank\" rel=\"noreferrer\">Headless Firefox</a>post.</p>\n<h2>HtmlUnit</h2>\n<p><a href=\"https://github.com/SeleniumHQ/htmlunit-driver\" target=\"_blank\" rel=\"noreferrer\">HtmlUnitDriver</a> is a WebDriver compatible driver<br>for <a href=\"http://htmlunit.sourceforge.net/\" target=\"_blank\" rel=\"noreferrer\">HtmlUnit</a> headless browser. This project is under SeleniumHQ organization so<br>there is no need to worry about maintenance efforts.</p>\n<p>The following dependency is needed.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;htmlunit-driver&lt;/artifactId&gt;\n            &lt;version&gt;2.34.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>HtmlUnitDriver doesn&#39;t require to install any browser or set a path to driver executable. It&#39;s the most lightweight<br>solution of all presented here. This test will work on every platform without any configuration efforts.</p>\n<pre><code class=\"language-java\">public class HeadlessHtmlUnitTest extends AbstractHeadlessTest {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        driver = new HtmlUnitDriver();\n    }\n\n    @Test\n    public void htmlUnitTest() {\n        shouldSuccessfullyFindPostAndDisplayCommentsSection(driver);\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n}\n</code></pre>\n<h2>JBrowser</h2>\n<p><a href=\"https://github.com/MachinePublishers/jBrowserDriver\" target=\"_blank\" rel=\"noreferrer\">jBrowserDriver</a> is A programmable, embeddable web browser driver<br>compatible with the Selenium WebDriver spec. It has a few interesting features that I&#39;d like to present in a separate<br>post one day. No spoilers though :)</p>\n<p>The following dependency is required.</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;com.machinepublishers&lt;/groupId&gt;\n            &lt;artifactId&gt;jbrowserdriver&lt;/artifactId&gt;\n            &lt;version&gt;1.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Unfortunately, jBrowserDriver is the only driver which failed my test so I&#39;m a bit worried about its stability. There<br>are also no guarantees that it will be supported in the long term. For example, it still doesn&#39;t work with Java 11.</p>\n<pre><code class=\"language-java\">public class HeadlessJBrowserTest extends AbstractHeadlessTest {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        driver = new JBrowserDriver(Settings.builder().\n                timezone(Timezone.EUROPE_WARSAW).build());\n    }\n\n    @Test\n    public void jBrowserTest() {\n        shouldSuccessfullyFindPostAndDisplayCommentsSection(driver);\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n}\n</code></pre>\n<h2>PhantomJS</h2>\n<p><a href=\"http://phantomjs.org/\" target=\"_blank\" rel=\"noreferrer\">PhantomJS</a> is no longer and I&#39;m adding it only for reference. I can&#39;t see any reasons to use it<br>in 2019.</p>\n<p>Dependency:</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;com.codeborne&lt;/groupId&gt;\n            &lt;artifactId&gt;phantomjsdriver&lt;/artifactId&gt;\n            &lt;version&gt;1.4.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>And test...</p>\n<pre><code class=\"language-java\">public class HeadlessPhantomJsTest extends AbstractHeadlessTest {\n\n    private WebDriver driver;\n\n    @Before\n    public void setUp() {\n        System.setProperty(&quot;phantomjs.binary.path&quot;,\n                           myProperties.getProperty(&quot;my_phantom_path&quot;));\n        driver = new PhantomJSDriver();\n    }\n\n    @Test\n    public void phantomJsTest() {\n        shouldSuccessfullyFindPostAndDisplayCommentsSection(driver);\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n}\n</code></pre>\n<h2>Summary</h2>\n<p>Headless browsers give us a few interesting benefits (speed being by far the most important), but you have to remember<br>about their limitations. There is no guarantee that website working perfectly with headless mode would work in a real<br>browser.</p>\n<p>If you are about to start your journey with headless Selenium I recommend to use Chrome or Firefox. You can easily debug<br>any issues by commenting <code>--headless</code> switch and see actual browser behavior. For more experienced users I recommend<br>HtmlUnitDriver which we use a lot in <a href=\"https://github.com/FluentLenium/FluentLenium\" target=\"_blank\" rel=\"noreferrer\">FluentLenium</a> project and can confirm<br>that it is a stable solution.</p>\n"
}